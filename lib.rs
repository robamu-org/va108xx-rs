# ! [doc = "Peripheral access API for VA108XX microcontrollers (generated using svd2rust v0.19.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.19.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
# ! [deny (const_err)]
# ! [deny (dead_code)]
# ! [deny (improper_ctypes)]
# ! [deny (missing_docs)]
# ! [deny (no_mangle_generic_items)]
# ! [deny (non_shorthand_field_patterns)]
# ! [deny (overflowing_literals)]
# ! [deny (path_statements)]
# ! [deny (patterns_in_fns_without_body)]
# ! [deny (private_in_public)]
# ! [deny (unconditional_recursion)]
# ! [deny (unused_allocation)]
# ! [deny (unused_comparisons)]
# ! [deny (unused_parens)]
# ! [deny (while_true)]
# ! [allow (non_camel_case_types)]
# ! [allow (non_snake_case)]
# ! [no_std]
use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS : u8 = 2 ; pub use cortex_m :: peripheral :: Peripherals as CorePeripherals ; # [cfg (feature = "rt")]
pub use cortex_m_rt :: interrupt ; # [cfg (feature = "rt")]
pub use self :: Interrupt as interrupt ; pub use cortex_m :: peripheral :: { CBP , CPUID , DCB , DWT , FPB , ITM , MPU , NVIC , SCB , SYST , TPIU , } ; # [allow (unused_imports)]
use generic :: * ; # [doc = r"Common register and bit access and modify traits"]
pub mod generic { use core :: marker ; # [doc = " Raw register type"]
pub trait RegisterSpec { # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
type Ux : Copy ; } # [doc = " Trait implemented by readable registers to enable the `read` method."]
# [doc = ""]
# [doc = " Registers marked with `Writable` can be also `modify`'ed."]
pub trait Readable : RegisterSpec { # [doc = " Result from a call to `read` and argument to `modify`."]
type Reader : From < R < Self > > + core :: ops :: Deref < Target = R < Self > > ; } # [doc = " Trait implemented by writeable registers."]
# [doc = ""]
# [doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
# [doc = ""]
# [doc = " Registers marked with `Readable` can be also `modify`'ed."]
pub trait Writable : RegisterSpec { # [doc = " Writer type argument to `write`, et al."]
type Writer : From < W < Self > > + core :: ops :: DerefMut < Target = W < Self > > ; } # [doc = " Reset value of the register."]
# [doc = ""]
# [doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
# [doc = " register by using the `reset` method."]
pub trait Resettable : RegisterSpec { # [doc = " Reset value of the register."]
fn reset_value () -> Self :: Ux ; } # [doc = " This structure provides volatile access to registers."]
# [repr (transparent)]
pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > { # [doc = " Returns the underlying memory address of register."]
# [doc = ""]
# [doc = " ```ignore"]
# [doc = " let reg_ptr = periph.reg.as_ptr();"]
# [doc = " ```"]
# [inline (always)]
pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > { # [doc = " Reads the contents of a `Readable` register."]
# [doc = ""]
# [doc = " You can read the raw contents of a register by using `bits`:"]
# [doc = " ```ignore"]
# [doc = " let bits = periph.reg.read().bits();"]
# [doc = " ```"]
# [doc = " or get the content of a particular field of a register:"]
# [doc = " ```ignore"]
# [doc = " let reader = periph.reg.read();"]
# [doc = " let bits = reader.field1().bits();"]
# [doc = " let flag = reader.field2().bit_is_set();"]
# [doc = " ```"]
# [inline (always)]
pub fn read (& self) -> REG :: Reader { REG :: Reader :: from (R { bits : self . register . get () , _reg : marker :: PhantomData , }) } } impl < REG : Resettable + Writable > Reg < REG > { # [doc = " Writes the reset value to `Writable` register."]
# [doc = ""]
# [doc = " Resets the register to its initial state."]
# [inline (always)]
pub fn reset (& self) { self . register . set (REG :: reset_value ()) } # [doc = " Writes bits to a `Writable` register."]
# [doc = ""]
# [doc = " You can write raw bits into a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
# [doc = " ```"]
# [doc = " or write only the fields you need:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " In the latter case, other fields will be set to their reset value."]
# [inline (always)]
pub fn write < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > { self . register . set (f (& mut REG :: Writer :: from (W { bits : REG :: reset_value () , _reg : marker :: PhantomData , })) . bits ,) ; } } impl < REG : Writable > Reg < REG > where REG :: Ux : Default , { # [doc = " Writes 0 to a `Writable` register."]
# [doc = ""]
# [doc = " Similar to `write`, but unused bits will contain 0."]
# [inline (always)]
pub unsafe fn write_with_zero < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > { self . register . set ((* f (& mut REG :: Writer :: from (W { bits : REG :: Ux :: default () , _reg : marker :: PhantomData , }))) . bits ,) ; } } impl < REG : Readable + Writable > Reg < REG > { # [doc = " Modifies the contents of the register by reading and then writing it."]
# [doc = ""]
# [doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
# [doc = "    r.bits() | 3"]
# [doc = " ) });"]
# [doc = " ```"]
# [doc = " or"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " Other fields will have the value they had before the call to `modify`."]
# [inline (always)]
pub fn modify < F > (& self , f : F) where for < 'w > F : FnOnce (& REG :: Reader , & 'w mut REG :: Writer) -> & 'w mut W < REG > { let bits = self . register . get () ; self . register . set (f (& REG :: Reader :: from (R { bits , _reg : marker :: PhantomData , }) , & mut REG :: Writer :: from (W { bits , _reg : marker :: PhantomData , }) ,) . bits ,) ; } } # [doc = " Register reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
# [doc = " method."]
pub struct R < REG : RegisterSpec + ? Sized > { pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > R < REG > { # [doc = " Reads raw bits from register."]
# [inline (always)]
pub fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy + Into < REG :: Ux > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& (* other) . into ()) } } # [doc = " Register writer."]
# [doc = ""]
# [doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
pub struct W < REG : RegisterSpec + ? Sized > { # [doc = "Writable bits"]
pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > W < REG > { # [doc = " Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } } # [doc = " Field reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of fields."]
pub struct FieldReader < U , T > { pub (crate) bits : U , _reg : marker :: PhantomData < T > , } impl < U , T > FieldReader < U , T > where U : Copy , { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : U) -> Self { Self { bits , _reg : marker :: PhantomData , } } # [doc = " Reads raw bits from field."]
# [inline (always)]
pub fn bits (& self) -> U { self . bits } } impl < U , T , FI > PartialEq < FI > for FieldReader < U , T > where U : PartialEq , FI : Copy + Into < U > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& (* other) . into ()) } } impl < FI > FieldReader < bool , FI > { # [doc = " Value of the field as raw bits."]
# [inline (always)]
pub fn bit (& self) -> bool { self . bits } # [doc = " Returns `true` if the bit is clear (0)."]
# [inline (always)]
pub fn bit_is_clear (& self) -> bool { ! self . bit () } # [doc = " Returns `true` if the bit is set (1)."]
# [inline (always)]
pub fn bit_is_set (& self) -> bool { self . bit () } } } # [cfg (feature = "rt")]
extern "C" { fn OC0 () ; fn OC1 () ; fn OC2 () ; fn OC3 () ; fn OC4 () ; fn OC5 () ; fn OC6 () ; fn OC7 () ; fn OC8 () ; fn OC9 () ; fn OC10 () ; fn OC11 () ; fn OC12 () ; fn OC13 () ; fn OC14 () ; fn OC15 () ; fn OC16 () ; fn OC17 () ; fn OC18 () ; fn OC19 () ; fn OC20 () ; fn OC21 () ; fn OC22 () ; fn OC23 () ; fn OC24 () ; fn OC25 () ; fn OC26 () ; fn OC27 () ; fn OC28 () ; fn OC29 () ; fn OC30 () ; fn OC31 () ; } # [doc (hidden)]
pub union Vector { _handler : unsafe extern "C" fn () , _reserved : u32 , } # [cfg (feature = "rt")]
# [doc (hidden)]
# [link_section = ".vector_table.interrupts"]
# [no_mangle]
pub static __INTERRUPTS : [Vector ; 32]
= [Vector { _handler : OC0 } , Vector { _handler : OC1 } , Vector { _handler : OC2 } , Vector { _handler : OC3 } , Vector { _handler : OC4 } , Vector { _handler : OC5 } , Vector { _handler : OC6 } , Vector { _handler : OC7 } , Vector { _handler : OC8 } , Vector { _handler : OC9 } , Vector { _handler : OC10 } , Vector { _handler : OC11 } , Vector { _handler : OC12 } , Vector { _handler : OC13 } , Vector { _handler : OC14 } , Vector { _handler : OC15 } , Vector { _handler : OC16 } , Vector { _handler : OC17 } , Vector { _handler : OC18 } , Vector { _handler : OC19 } , Vector { _handler : OC20 } , Vector { _handler : OC21 } , Vector { _handler : OC22 } , Vector { _handler : OC23 } , Vector { _handler : OC24 } , Vector { _handler : OC25 } , Vector { _handler : OC26 } , Vector { _handler : OC27 } , Vector { _handler : OC28 } , Vector { _handler : OC29 } , Vector { _handler : OC30 } , Vector { _handler : OC31 } ,]
; # [doc = r"Enumeration of all the interrupts."]
# [derive (Copy , Clone , Debug , PartialEq , Eq)]
# [repr (u16)]
pub enum Interrupt { # [doc = "0 - OC0"]
OC0 = 0 , # [doc = "1 - OC1"]
OC1 = 1 , # [doc = "2 - OC2"]
OC2 = 2 , # [doc = "3 - OC3"]
OC3 = 3 , # [doc = "4 - OC4"]
OC4 = 4 , # [doc = "5 - OC5"]
OC5 = 5 , # [doc = "6 - OC6"]
OC6 = 6 , # [doc = "7 - OC7"]
OC7 = 7 , # [doc = "8 - OC8"]
OC8 = 8 , # [doc = "9 - OC9"]
OC9 = 9 , # [doc = "10 - OC10"]
OC10 = 10 , # [doc = "11 - OC11"]
OC11 = 11 , # [doc = "12 - OC12"]
OC12 = 12 , # [doc = "13 - OC13"]
OC13 = 13 , # [doc = "14 - OC14"]
OC14 = 14 , # [doc = "15 - OC15"]
OC15 = 15 , # [doc = "16 - OC16"]
OC16 = 16 , # [doc = "17 - OC17"]
OC17 = 17 , # [doc = "18 - OC18"]
OC18 = 18 , # [doc = "19 - OC19"]
OC19 = 19 , # [doc = "20 - OC20"]
OC20 = 20 , # [doc = "21 - OC21"]
OC21 = 21 , # [doc = "22 - OC22"]
OC22 = 22 , # [doc = "23 - OC23"]
OC23 = 23 , # [doc = "24 - OC24"]
OC24 = 24 , # [doc = "25 - OC25"]
OC25 = 25 , # [doc = "26 - OC26"]
OC26 = 26 , # [doc = "27 - OC27"]
OC27 = 27 , # [doc = "28 - OC28"]
OC28 = 28 , # [doc = "29 - OC29"]
OC29 = 29 , # [doc = "30 - OC30"]
OC30 = 30 , # [doc = "31 - OC31"]
OC31 = 31 , } unsafe impl cortex_m :: interrupt :: InterruptNumber for Interrupt { # [inline (always)]
fn number (self) -> u16 { self as u16 } } # [doc = "System Configuration Peripheral"]
pub struct SYSCONFIG { _marker : PhantomData < * const () > } unsafe impl Send for SYSCONFIG { } impl SYSCONFIG { # [doc = r"Pointer to the register block"]
pub const PTR : * const sysconfig :: RegisterBlock = 0x4000_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const sysconfig :: RegisterBlock { Self :: PTR } } impl Deref for SYSCONFIG { type Target = sysconfig :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SYSCONFIG { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SYSCONFIG") . finish () } } # [doc = "System Configuration Peripheral"]
pub mod sysconfig { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - System Reset Status"]
pub rst_stat : crate :: Reg < rst_stat :: RST_STAT_SPEC > , # [doc = "0x04 - ROM Reset Control"]
pub rst_cntl_rom : crate :: Reg < rst_cntl_rom :: RST_CNTL_ROM_SPEC > , # [doc = "0x08 - RAM Reset Control"]
pub rst_cntl_ram : crate :: Reg < rst_cntl_ram :: RST_CNTL_RAM_SPEC > , # [doc = "0x0c - ROM Protection Configuration"]
pub rom_prot : crate :: Reg < rom_prot :: ROM_PROT_SPEC > , # [doc = "0x10 - ROM Scrub Period Configuration"]
pub rom_scrub : crate :: Reg < rom_scrub :: ROM_SCRUB_SPEC > , # [doc = "0x14 - RAM Scrub Period Configuration"]
pub ram_scrub : crate :: Reg < ram_scrub :: RAM_SCRUB_SPEC > , # [doc = "0x18 - ROM Trap Address"]
pub rom_trap_addr : crate :: Reg < rom_trap_addr :: ROM_TRAP_ADDR_SPEC > , # [doc = "0x1c - ROM Trap Syndrome"]
pub rom_trap_synd : crate :: Reg < rom_trap_synd :: ROM_TRAP_SYND_SPEC > , # [doc = "0x20 - RAM Trap Address"]
pub ram_trap_addr : crate :: Reg < ram_trap_addr :: RAM_TRAP_ADDR_SPEC > , # [doc = "0x24 - RAM Trap Syndrome"]
pub ram_trap_synd : crate :: Reg < ram_trap_synd :: RAM_TRAP_SYND_SPEC > , # [doc = "0x28 - Enable EDAC Error Interrupt Register"]
pub irq_enb : crate :: Reg < irq_enb :: IRQ_ENB_SPEC > , # [doc = "0x2c - Raw EDAC Error Interrupt Status"]
pub irq_raw : crate :: Reg < irq_raw :: IRQ_RAW_SPEC > , # [doc = "0x30 - Enabled EDAC Error Interrupt Status"]
pub irq_end : crate :: Reg < irq_end :: IRQ_END_SPEC > , # [doc = "0x34 - Clear EDAC Error Interrupt Status"]
pub irq_clr : crate :: Reg < irq_clr :: IRQ_CLR_SPEC > , # [doc = "0x38 - Count of RAM EDAC Single Bit Errors"]
pub ram_sbe : crate :: Reg < ram_sbe :: RAM_SBE_SPEC > , # [doc = "0x3c - Count of RAM EDAC Multi Bit Errors"]
pub ram_mbe : crate :: Reg < ram_mbe :: RAM_MBE_SPEC > , # [doc = "0x40 - Count of ROM EDAC Single Bit Errors"]
pub rom_sbe : crate :: Reg < rom_sbe :: ROM_SBE_SPEC > , # [doc = "0x44 - Count of ROM EDAC Multi Bit Errors"]
pub rom_mbe : crate :: Reg < rom_mbe :: ROM_MBE_SPEC > , # [doc = "0x48 - IO Configuration Clock Divider Register"]
pub ioconfig_clkdiv0 : crate :: Reg < ioconfig_clkdiv0 :: IOCONFIG_CLKDIV0_SPEC > , # [doc = "0x4c - IO Configuration Clock Divider Register"]
pub ioconfig_clkdiv1 : crate :: Reg < ioconfig_clkdiv :: IOCONFIG_CLKDIV_SPEC > , # [doc = "0x50 - IO Configuration Clock Divider Register"]
pub ioconfig_clkdiv2 : crate :: Reg < ioconfig_clkdiv :: IOCONFIG_CLKDIV_SPEC > , # [doc = "0x54 - IO Configuration Clock Divider Register"]
pub ioconfig_clkdiv3 : crate :: Reg < ioconfig_clkdiv :: IOCONFIG_CLKDIV_SPEC > , # [doc = "0x58 - IO Configuration Clock Divider Register"]
pub ioconfig_clkdiv4 : crate :: Reg < ioconfig_clkdiv :: IOCONFIG_CLKDIV_SPEC > , # [doc = "0x5c - IO Configuration Clock Divider Register"]
pub ioconfig_clkdiv5 : crate :: Reg < ioconfig_clkdiv :: IOCONFIG_CLKDIV_SPEC > , # [doc = "0x60 - IO Configuration Clock Divider Register"]
pub ioconfig_clkdiv6 : crate :: Reg < ioconfig_clkdiv :: IOCONFIG_CLKDIV_SPEC > , # [doc = "0x64 - IO Configuration Clock Divider Register"]
pub ioconfig_clkdiv7 : crate :: Reg < ioconfig_clkdiv :: IOCONFIG_CLKDIV_SPEC > , # [doc = "0x68 - ROM BOOT Retry count"]
pub rom_retries : crate :: Reg < rom_retries :: ROM_RETRIES_SPEC > , # [doc = "0x6c - Register Refresh Control"]
pub refresh_config : crate :: Reg < refresh_config :: REFRESH_CONFIG_SPEC > , # [doc = "0x70 - TIM Reset Control"]
pub tim_reset : crate :: Reg < tim_reset :: TIM_RESET_SPEC > , # [doc = "0x74 - TIM Enable Control"]
pub tim_clk_enable : crate :: Reg < tim_clk_enable :: TIM_CLK_ENABLE_SPEC > , # [doc = "0x78 - Peripheral Reset Control"]
pub peripheral_reset : crate :: Reg < peripheral_reset :: PERIPHERAL_RESET_SPEC > , # [doc = "0x7c - Peripheral Enable Control"]
pub peripheral_clk_enable : crate :: Reg < peripheral_clk_enable :: PERIPHERAL_CLK_ENABLE_SPEC > , # [doc = "0x80 - Lockup Reset Configuration"]
pub lockup_reset : crate :: Reg < lockup_reset :: LOCKUP_RESET_SPEC > , _reserved33 : [u8 ; 0x0f6c]
, # [doc = "0xff0 - EFuse Config Register"]
pub ef_config : crate :: Reg < ef_config :: EF_CONFIG_SPEC > , # [doc = "0xff4 - EFuse ID Register"]
pub ef_id : crate :: Reg < ef_id :: EF_ID_SPEC > , # [doc = "0xff8 - Processor ID Register"]
pub procid : crate :: Reg < procid :: PROCID_SPEC > , # [doc = "0xffc - Peripheral ID Register"]
pub perid : crate :: Reg < perid :: PERID_SPEC > , } # [doc = "RST_STAT register accessor: an alias for `Reg<RST_STAT_SPEC>`"]
pub type RST_STAT = crate :: Reg < rst_stat :: RST_STAT_SPEC > ; # [doc = "System Reset Status"]
pub mod rst_stat { # [doc = "Register `RST_STAT` reader"]
pub struct R (crate :: R < RST_STAT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RST_STAT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RST_STAT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RST_STAT_SPEC >) -> Self { R (reader) } } # [doc = "Register `RST_STAT` writer"]
pub struct W (crate :: W < RST_STAT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RST_STAT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RST_STAT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RST_STAT_SPEC >) -> Self { W (writer) } } # [doc = "Field `POR` reader - Power On Reset Status"]
pub struct POR_R (crate :: FieldReader < bool , bool >) ; impl POR_R { pub (crate) fn new (bits : bool) -> Self { POR_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for POR_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `POR` writer - Power On Reset Status"]
pub struct POR_W < 'a > { w : & 'a mut W , } impl < 'a > POR_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `EXTRST` reader - External Reset Status"]
pub struct EXTRST_R (crate :: FieldReader < bool , bool >) ; impl EXTRST_R { pub (crate) fn new (bits : bool) -> Self { EXTRST_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for EXTRST_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `EXTRST` writer - External Reset Status"]
pub struct EXTRST_W < 'a > { w : & 'a mut W , } impl < 'a > EXTRST_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `SYSRSTREQ` reader - SYSRESETREQ Reset Status"]
pub struct SYSRSTREQ_R (crate :: FieldReader < bool , bool >) ; impl SYSRSTREQ_R { pub (crate) fn new (bits : bool) -> Self { SYSRSTREQ_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for SYSRSTREQ_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `SYSRSTREQ` writer - SYSRESETREQ Reset Status"]
pub struct SYSRSTREQ_W < 'a > { w : & 'a mut W , } impl < 'a > SYSRSTREQ_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `LOOKUP` reader - LOOKUP Reset Status"]
pub struct LOOKUP_R (crate :: FieldReader < bool , bool >) ; impl LOOKUP_R { pub (crate) fn new (bits : bool) -> Self { LOOKUP_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for LOOKUP_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `LOOKUP` writer - LOOKUP Reset Status"]
pub struct LOOKUP_W < 'a > { w : & 'a mut W , } impl < 'a > LOOKUP_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } # [doc = "Field `WATCHDOG` reader - WATCHDOG Reset Status"]
pub struct WATCHDOG_R (crate :: FieldReader < bool , bool >) ; impl WATCHDOG_R { pub (crate) fn new (bits : bool) -> Self { WATCHDOG_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for WATCHDOG_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `WATCHDOG` writer - WATCHDOG Reset Status"]
pub struct WATCHDOG_W < 'a > { w : & 'a mut W , } impl < 'a > WATCHDOG_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 4)) | ((value as u32 & 0x01) << 4) ; self . w } } # [doc = "Field `MEMERR` reader - Memory Error Reset Status"]
pub struct MEMERR_R (crate :: FieldReader < bool , bool >) ; impl MEMERR_R { pub (crate) fn new (bits : bool) -> Self { MEMERR_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for MEMERR_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `MEMERR` writer - Memory Error Reset Status"]
pub struct MEMERR_W < 'a > { w : & 'a mut W , } impl < 'a > MEMERR_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 5)) | ((value as u32 & 0x01) << 5) ; self . w } } impl R { # [doc = "Bit 0 - Power On Reset Status"]
# [inline (always)]
pub fn por (& self) -> POR_R { POR_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - External Reset Status"]
# [inline (always)]
pub fn extrst (& self) -> EXTRST_R { EXTRST_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - SYSRESETREQ Reset Status"]
# [inline (always)]
pub fn sysrstreq (& self) -> SYSRSTREQ_R { SYSRSTREQ_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - LOOKUP Reset Status"]
# [inline (always)]
pub fn lookup (& self) -> LOOKUP_R { LOOKUP_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - WATCHDOG Reset Status"]
# [inline (always)]
pub fn watchdog (& self) -> WATCHDOG_R { WATCHDOG_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - Memory Error Reset Status"]
# [inline (always)]
pub fn memerr (& self) -> MEMERR_R { MEMERR_R :: new (((self . bits >> 5) & 0x01) != 0) } } impl W { # [doc = "Bit 0 - Power On Reset Status"]
# [inline (always)]
pub fn por (& mut self) -> POR_W { POR_W { w : self } } # [doc = "Bit 1 - External Reset Status"]
# [inline (always)]
pub fn extrst (& mut self) -> EXTRST_W { EXTRST_W { w : self } } # [doc = "Bit 2 - SYSRESETREQ Reset Status"]
# [inline (always)]
pub fn sysrstreq (& mut self) -> SYSRSTREQ_W { SYSRSTREQ_W { w : self } } # [doc = "Bit 3 - LOOKUP Reset Status"]
# [inline (always)]
pub fn lookup (& mut self) -> LOOKUP_W { LOOKUP_W { w : self } } # [doc = "Bit 4 - WATCHDOG Reset Status"]
# [inline (always)]
pub fn watchdog (& mut self) -> WATCHDOG_W { WATCHDOG_W { w : self } } # [doc = "Bit 5 - Memory Error Reset Status"]
# [inline (always)]
pub fn memerr (& mut self) -> MEMERR_W { MEMERR_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "System Reset Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rst_stat](index.html) module"]
pub struct RST_STAT_SPEC ; impl crate :: RegisterSpec for RST_STAT_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rst_stat::R](R) reader structure"]
impl crate :: Readable for RST_STAT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rst_stat::W](W) writer structure"]
impl crate :: Writable for RST_STAT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RST_STAT to value 0x01"]
impl crate :: Resettable for RST_STAT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x01 } } } # [doc = "RST_CNTL_ROM register accessor: an alias for `Reg<RST_CNTL_ROM_SPEC>`"]
pub type RST_CNTL_ROM = crate :: Reg < rst_cntl_rom :: RST_CNTL_ROM_SPEC > ; # [doc = "ROM Reset Control"]
pub mod rst_cntl_rom { # [doc = "Register `RST_CNTL_ROM` reader"]
pub struct R (crate :: R < RST_CNTL_ROM_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RST_CNTL_ROM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RST_CNTL_ROM_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RST_CNTL_ROM_SPEC >) -> Self { R (reader) } } # [doc = "Register `RST_CNTL_ROM` writer"]
pub struct W (crate :: W < RST_CNTL_ROM_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RST_CNTL_ROM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RST_CNTL_ROM_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RST_CNTL_ROM_SPEC >) -> Self { W (writer) } } # [doc = "Field `POR` reader - Power On Reset Status"]
pub struct POR_R (crate :: FieldReader < bool , bool >) ; impl POR_R { pub (crate) fn new (bits : bool) -> Self { POR_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for POR_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `POR` writer - Power On Reset Status"]
pub struct POR_W < 'a > { w : & 'a mut W , } impl < 'a > POR_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `EXTRST` reader - External Reset Status"]
pub struct EXTRST_R (crate :: FieldReader < bool , bool >) ; impl EXTRST_R { pub (crate) fn new (bits : bool) -> Self { EXTRST_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for EXTRST_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `EXTRST` writer - External Reset Status"]
pub struct EXTRST_W < 'a > { w : & 'a mut W , } impl < 'a > EXTRST_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `SYSRSTREQ` reader - SYSRESETREQ Reset Status"]
pub struct SYSRSTREQ_R (crate :: FieldReader < bool , bool >) ; impl SYSRSTREQ_R { pub (crate) fn new (bits : bool) -> Self { SYSRSTREQ_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for SYSRSTREQ_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `SYSRSTREQ` writer - SYSRESETREQ Reset Status"]
pub struct SYSRSTREQ_W < 'a > { w : & 'a mut W , } impl < 'a > SYSRSTREQ_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `LOOKUP` reader - LOOKUP Reset Status"]
pub struct LOOKUP_R (crate :: FieldReader < bool , bool >) ; impl LOOKUP_R { pub (crate) fn new (bits : bool) -> Self { LOOKUP_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for LOOKUP_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `LOOKUP` writer - LOOKUP Reset Status"]
pub struct LOOKUP_W < 'a > { w : & 'a mut W , } impl < 'a > LOOKUP_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } # [doc = "Field `WATCHDOG` reader - WATCHDOG Reset Status"]
pub struct WATCHDOG_R (crate :: FieldReader < bool , bool >) ; impl WATCHDOG_R { pub (crate) fn new (bits : bool) -> Self { WATCHDOG_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for WATCHDOG_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `WATCHDOG` writer - WATCHDOG Reset Status"]
pub struct WATCHDOG_W < 'a > { w : & 'a mut W , } impl < 'a > WATCHDOG_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 4)) | ((value as u32 & 0x01) << 4) ; self . w } } # [doc = "Field `MEMERR` reader - Memory Error Reset Status"]
pub struct MEMERR_R (crate :: FieldReader < bool , bool >) ; impl MEMERR_R { pub (crate) fn new (bits : bool) -> Self { MEMERR_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for MEMERR_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `MEMERR` writer - Memory Error Reset Status"]
pub struct MEMERR_W < 'a > { w : & 'a mut W , } impl < 'a > MEMERR_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 5)) | ((value as u32 & 0x01) << 5) ; self . w } } impl R { # [doc = "Bit 0 - Power On Reset Status"]
# [inline (always)]
pub fn por (& self) -> POR_R { POR_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - External Reset Status"]
# [inline (always)]
pub fn extrst (& self) -> EXTRST_R { EXTRST_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - SYSRESETREQ Reset Status"]
# [inline (always)]
pub fn sysrstreq (& self) -> SYSRSTREQ_R { SYSRSTREQ_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - LOOKUP Reset Status"]
# [inline (always)]
pub fn lookup (& self) -> LOOKUP_R { LOOKUP_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - WATCHDOG Reset Status"]
# [inline (always)]
pub fn watchdog (& self) -> WATCHDOG_R { WATCHDOG_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - Memory Error Reset Status"]
# [inline (always)]
pub fn memerr (& self) -> MEMERR_R { MEMERR_R :: new (((self . bits >> 5) & 0x01) != 0) } } impl W { # [doc = "Bit 0 - Power On Reset Status"]
# [inline (always)]
pub fn por (& mut self) -> POR_W { POR_W { w : self } } # [doc = "Bit 1 - External Reset Status"]
# [inline (always)]
pub fn extrst (& mut self) -> EXTRST_W { EXTRST_W { w : self } } # [doc = "Bit 2 - SYSRESETREQ Reset Status"]
# [inline (always)]
pub fn sysrstreq (& mut self) -> SYSRSTREQ_W { SYSRSTREQ_W { w : self } } # [doc = "Bit 3 - LOOKUP Reset Status"]
# [inline (always)]
pub fn lookup (& mut self) -> LOOKUP_W { LOOKUP_W { w : self } } # [doc = "Bit 4 - WATCHDOG Reset Status"]
# [inline (always)]
pub fn watchdog (& mut self) -> WATCHDOG_W { WATCHDOG_W { w : self } } # [doc = "Bit 5 - Memory Error Reset Status"]
# [inline (always)]
pub fn memerr (& mut self) -> MEMERR_W { MEMERR_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "ROM Reset Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rst_cntl_rom](index.html) module"]
pub struct RST_CNTL_ROM_SPEC ; impl crate :: RegisterSpec for RST_CNTL_ROM_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rst_cntl_rom::R](R) reader structure"]
impl crate :: Readable for RST_CNTL_ROM_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rst_cntl_rom::W](W) writer structure"]
impl crate :: Writable for RST_CNTL_ROM_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RST_CNTL_ROM to value 0x1f"]
impl crate :: Resettable for RST_CNTL_ROM_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x1f } } } # [doc = "RST_CNTL_RAM register accessor: an alias for `Reg<RST_CNTL_RAM_SPEC>`"]
pub type RST_CNTL_RAM = crate :: Reg < rst_cntl_ram :: RST_CNTL_RAM_SPEC > ; # [doc = "RAM Reset Control"]
pub mod rst_cntl_ram { # [doc = "Register `RST_CNTL_RAM` reader"]
pub struct R (crate :: R < RST_CNTL_RAM_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RST_CNTL_RAM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RST_CNTL_RAM_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RST_CNTL_RAM_SPEC >) -> Self { R (reader) } } # [doc = "Register `RST_CNTL_RAM` writer"]
pub struct W (crate :: W < RST_CNTL_RAM_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RST_CNTL_RAM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RST_CNTL_RAM_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RST_CNTL_RAM_SPEC >) -> Self { W (writer) } } # [doc = "Field `POR` reader - Power On Reset Status"]
pub struct POR_R (crate :: FieldReader < bool , bool >) ; impl POR_R { pub (crate) fn new (bits : bool) -> Self { POR_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for POR_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `POR` writer - Power On Reset Status"]
pub struct POR_W < 'a > { w : & 'a mut W , } impl < 'a > POR_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `EXTRST` reader - External Reset Status"]
pub struct EXTRST_R (crate :: FieldReader < bool , bool >) ; impl EXTRST_R { pub (crate) fn new (bits : bool) -> Self { EXTRST_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for EXTRST_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `EXTRST` writer - External Reset Status"]
pub struct EXTRST_W < 'a > { w : & 'a mut W , } impl < 'a > EXTRST_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `SYSRSTREQ` reader - SYSRESETREQ Reset Status"]
pub struct SYSRSTREQ_R (crate :: FieldReader < bool , bool >) ; impl SYSRSTREQ_R { pub (crate) fn new (bits : bool) -> Self { SYSRSTREQ_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for SYSRSTREQ_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `SYSRSTREQ` writer - SYSRESETREQ Reset Status"]
pub struct SYSRSTREQ_W < 'a > { w : & 'a mut W , } impl < 'a > SYSRSTREQ_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `LOOKUP` reader - LOOKUP Reset Status"]
pub struct LOOKUP_R (crate :: FieldReader < bool , bool >) ; impl LOOKUP_R { pub (crate) fn new (bits : bool) -> Self { LOOKUP_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for LOOKUP_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `LOOKUP` writer - LOOKUP Reset Status"]
pub struct LOOKUP_W < 'a > { w : & 'a mut W , } impl < 'a > LOOKUP_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } # [doc = "Field `WATCHDOG` reader - WATCHDOG Reset Status"]
pub struct WATCHDOG_R (crate :: FieldReader < bool , bool >) ; impl WATCHDOG_R { pub (crate) fn new (bits : bool) -> Self { WATCHDOG_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for WATCHDOG_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `WATCHDOG` writer - WATCHDOG Reset Status"]
pub struct WATCHDOG_W < 'a > { w : & 'a mut W , } impl < 'a > WATCHDOG_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 4)) | ((value as u32 & 0x01) << 4) ; self . w } } # [doc = "Field `MEMERR` reader - Memory Error Reset Status"]
pub struct MEMERR_R (crate :: FieldReader < bool , bool >) ; impl MEMERR_R { pub (crate) fn new (bits : bool) -> Self { MEMERR_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for MEMERR_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `MEMERR` writer - Memory Error Reset Status"]
pub struct MEMERR_W < 'a > { w : & 'a mut W , } impl < 'a > MEMERR_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 5)) | ((value as u32 & 0x01) << 5) ; self . w } } impl R { # [doc = "Bit 0 - Power On Reset Status"]
# [inline (always)]
pub fn por (& self) -> POR_R { POR_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - External Reset Status"]
# [inline (always)]
pub fn extrst (& self) -> EXTRST_R { EXTRST_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - SYSRESETREQ Reset Status"]
# [inline (always)]
pub fn sysrstreq (& self) -> SYSRSTREQ_R { SYSRSTREQ_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - LOOKUP Reset Status"]
# [inline (always)]
pub fn lookup (& self) -> LOOKUP_R { LOOKUP_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - WATCHDOG Reset Status"]
# [inline (always)]
pub fn watchdog (& self) -> WATCHDOG_R { WATCHDOG_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - Memory Error Reset Status"]
# [inline (always)]
pub fn memerr (& self) -> MEMERR_R { MEMERR_R :: new (((self . bits >> 5) & 0x01) != 0) } } impl W { # [doc = "Bit 0 - Power On Reset Status"]
# [inline (always)]
pub fn por (& mut self) -> POR_W { POR_W { w : self } } # [doc = "Bit 1 - External Reset Status"]
# [inline (always)]
pub fn extrst (& mut self) -> EXTRST_W { EXTRST_W { w : self } } # [doc = "Bit 2 - SYSRESETREQ Reset Status"]
# [inline (always)]
pub fn sysrstreq (& mut self) -> SYSRSTREQ_W { SYSRSTREQ_W { w : self } } # [doc = "Bit 3 - LOOKUP Reset Status"]
# [inline (always)]
pub fn lookup (& mut self) -> LOOKUP_W { LOOKUP_W { w : self } } # [doc = "Bit 4 - WATCHDOG Reset Status"]
# [inline (always)]
pub fn watchdog (& mut self) -> WATCHDOG_W { WATCHDOG_W { w : self } } # [doc = "Bit 5 - Memory Error Reset Status"]
# [inline (always)]
pub fn memerr (& mut self) -> MEMERR_W { MEMERR_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "RAM Reset Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rst_cntl_ram](index.html) module"]
pub struct RST_CNTL_RAM_SPEC ; impl crate :: RegisterSpec for RST_CNTL_RAM_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rst_cntl_ram::R](R) reader structure"]
impl crate :: Readable for RST_CNTL_RAM_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rst_cntl_ram::W](W) writer structure"]
impl crate :: Writable for RST_CNTL_RAM_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RST_CNTL_RAM to value 0x1f"]
impl crate :: Resettable for RST_CNTL_RAM_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x1f } } } # [doc = "ROM_PROT register accessor: an alias for `Reg<ROM_PROT_SPEC>`"]
pub type ROM_PROT = crate :: Reg < rom_prot :: ROM_PROT_SPEC > ; # [doc = "ROM Protection Configuration"]
pub mod rom_prot { # [doc = "Register `ROM_PROT` reader"]
pub struct R (crate :: R < ROM_PROT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ROM_PROT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ROM_PROT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ROM_PROT_SPEC >) -> Self { R (reader) } } # [doc = "Register `ROM_PROT` writer"]
pub struct W (crate :: W < ROM_PROT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ROM_PROT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ROM_PROT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ROM_PROT_SPEC >) -> Self { W (writer) } } # [doc = "Field `WREN` reader - ROM Write Enable Bit"]
pub struct WREN_R (crate :: FieldReader < bool , bool >) ; impl WREN_R { pub (crate) fn new (bits : bool) -> Self { WREN_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for WREN_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `WREN` writer - ROM Write Enable Bit"]
pub struct WREN_W < 'a > { w : & 'a mut W , } impl < 'a > WREN_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } impl R { # [doc = "Bit 0 - ROM Write Enable Bit"]
# [inline (always)]
pub fn wren (& self) -> WREN_R { WREN_R :: new ((self . bits & 0x01) != 0) } } impl W { # [doc = "Bit 0 - ROM Write Enable Bit"]
# [inline (always)]
pub fn wren (& mut self) -> WREN_W { WREN_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "ROM Protection Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rom_prot](index.html) module"]
pub struct ROM_PROT_SPEC ; impl crate :: RegisterSpec for ROM_PROT_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rom_prot::R](R) reader structure"]
impl crate :: Readable for ROM_PROT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rom_prot::W](W) writer structure"]
impl crate :: Writable for ROM_PROT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ROM_PROT to value 0x01"]
impl crate :: Resettable for ROM_PROT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x01 } } } # [doc = "ROM_SCRUB register accessor: an alias for `Reg<ROM_SCRUB_SPEC>`"]
pub type ROM_SCRUB = crate :: Reg < rom_scrub :: ROM_SCRUB_SPEC > ; # [doc = "ROM Scrub Period Configuration"]
pub mod rom_scrub { # [doc = "Register `ROM_SCRUB` reader"]
pub struct R (crate :: R < ROM_SCRUB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ROM_SCRUB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ROM_SCRUB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ROM_SCRUB_SPEC >) -> Self { R (reader) } } # [doc = "Register `ROM_SCRUB` writer"]
pub struct W (crate :: W < ROM_SCRUB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ROM_SCRUB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ROM_SCRUB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ROM_SCRUB_SPEC >) -> Self { W (writer) } } # [doc = "Field `VALUE` reader - Counter divide value"]
pub struct VALUE_R (crate :: FieldReader < u32 , u32 >) ; impl VALUE_R { pub (crate) fn new (bits : u32) -> Self { VALUE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for VALUE_R { type Target = crate :: FieldReader < u32 , u32 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `VALUE` writer - Counter divide value"]
pub struct VALUE_W < 'a > { w : & 'a mut W , } impl < 'a > VALUE_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u32) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x00ff_ffff) | (value as u32 & 0x00ff_ffff) ; self . w } } # [doc = "Field `RESET` writer - Reset Counter"]
pub struct RESET_W < 'a > { w : & 'a mut W , } impl < 'a > RESET_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 31)) | ((value as u32 & 0x01) << 31) ; self . w } } impl R { # [doc = "Bits 0:23 - Counter divide value"]
# [inline (always)]
pub fn value (& self) -> VALUE_R { VALUE_R :: new ((self . bits & 0x00ff_ffff) as u32) } } impl W { # [doc = "Bits 0:23 - Counter divide value"]
# [inline (always)]
pub fn value (& mut self) -> VALUE_W { VALUE_W { w : self } } # [doc = "Bit 31 - Reset Counter"]
# [inline (always)]
pub fn reset (& mut self) -> RESET_W { RESET_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "ROM Scrub Period Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rom_scrub](index.html) module"]
pub struct ROM_SCRUB_SPEC ; impl crate :: RegisterSpec for ROM_SCRUB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rom_scrub::R](R) reader structure"]
impl crate :: Readable for ROM_SCRUB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rom_scrub::W](W) writer structure"]
impl crate :: Writable for ROM_SCRUB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ROM_SCRUB to value 0"]
impl crate :: Resettable for ROM_SCRUB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RAM_SCRUB register accessor: an alias for `Reg<RAM_SCRUB_SPEC>`"]
pub type RAM_SCRUB = crate :: Reg < ram_scrub :: RAM_SCRUB_SPEC > ; # [doc = "RAM Scrub Period Configuration"]
pub mod ram_scrub { # [doc = "Register `RAM_SCRUB` reader"]
pub struct R (crate :: R < RAM_SCRUB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RAM_SCRUB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RAM_SCRUB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RAM_SCRUB_SPEC >) -> Self { R (reader) } } # [doc = "Register `RAM_SCRUB` writer"]
pub struct W (crate :: W < RAM_SCRUB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RAM_SCRUB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RAM_SCRUB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RAM_SCRUB_SPEC >) -> Self { W (writer) } } # [doc = "Field `VALUE` reader - Counter divide value"]
pub struct VALUE_R (crate :: FieldReader < u32 , u32 >) ; impl VALUE_R { pub (crate) fn new (bits : u32) -> Self { VALUE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for VALUE_R { type Target = crate :: FieldReader < u32 , u32 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `VALUE` writer - Counter divide value"]
pub struct VALUE_W < 'a > { w : & 'a mut W , } impl < 'a > VALUE_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u32) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x00ff_ffff) | (value as u32 & 0x00ff_ffff) ; self . w } } # [doc = "Field `RESET` writer - Reset Counter"]
pub struct RESET_W < 'a > { w : & 'a mut W , } impl < 'a > RESET_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 31)) | ((value as u32 & 0x01) << 31) ; self . w } } impl R { # [doc = "Bits 0:23 - Counter divide value"]
# [inline (always)]
pub fn value (& self) -> VALUE_R { VALUE_R :: new ((self . bits & 0x00ff_ffff) as u32) } } impl W { # [doc = "Bits 0:23 - Counter divide value"]
# [inline (always)]
pub fn value (& mut self) -> VALUE_W { VALUE_W { w : self } } # [doc = "Bit 31 - Reset Counter"]
# [inline (always)]
pub fn reset (& mut self) -> RESET_W { RESET_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "RAM Scrub Period Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ram_scrub](index.html) module"]
pub struct RAM_SCRUB_SPEC ; impl crate :: RegisterSpec for RAM_SCRUB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ram_scrub::R](R) reader structure"]
impl crate :: Readable for RAM_SCRUB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ram_scrub::W](W) writer structure"]
impl crate :: Writable for RAM_SCRUB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RAM_SCRUB to value 0"]
impl crate :: Resettable for RAM_SCRUB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ROM_TRAP_ADDR register accessor: an alias for `Reg<ROM_TRAP_ADDR_SPEC>`"]
pub type ROM_TRAP_ADDR = crate :: Reg < rom_trap_addr :: ROM_TRAP_ADDR_SPEC > ; # [doc = "ROM Trap Address"]
pub mod rom_trap_addr { # [doc = "Register `ROM_TRAP_ADDR` reader"]
pub struct R (crate :: R < ROM_TRAP_ADDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ROM_TRAP_ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ROM_TRAP_ADDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ROM_TRAP_ADDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `ROM_TRAP_ADDR` writer"]
pub struct W (crate :: W < ROM_TRAP_ADDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ROM_TRAP_ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ROM_TRAP_ADDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ROM_TRAP_ADDR_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADDR` reader - Trap Address Match Bits"]
pub struct ADDR_R (crate :: FieldReader < u16 , u16 >) ; impl ADDR_R { pub (crate) fn new (bits : u16) -> Self { ADDR_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ADDR_R { type Target = crate :: FieldReader < u16 , u16 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ADDR` writer - Trap Address Match Bits"]
pub struct ADDR_W < 'a > { w : & 'a mut W , } impl < 'a > ADDR_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u16) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x3fff << 2)) | ((value as u32 & 0x3fff) << 2) ; self . w } } # [doc = "Field `ENABLE` reader - Trap Enable Bit"]
pub struct ENABLE_R (crate :: FieldReader < bool , bool >) ; impl ENABLE_R { pub (crate) fn new (bits : bool) -> Self { ENABLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ENABLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ENABLE` writer - Trap Enable Bit"]
pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 31)) | ((value as u32 & 0x01) << 31) ; self . w } } impl R { # [doc = "Bits 2:15 - Trap Address Match Bits"]
# [inline (always)]
pub fn addr (& self) -> ADDR_R { ADDR_R :: new (((self . bits >> 2) & 0x3fff) as u16) } # [doc = "Bit 31 - Trap Enable Bit"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 31) & 0x01) != 0) } } impl W { # [doc = "Bits 2:15 - Trap Address Match Bits"]
# [inline (always)]
pub fn addr (& mut self) -> ADDR_W { ADDR_W { w : self } } # [doc = "Bit 31 - Trap Enable Bit"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "ROM Trap Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rom_trap_addr](index.html) module"]
pub struct ROM_TRAP_ADDR_SPEC ; impl crate :: RegisterSpec for ROM_TRAP_ADDR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rom_trap_addr::R](R) reader structure"]
impl crate :: Readable for ROM_TRAP_ADDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rom_trap_addr::W](W) writer structure"]
impl crate :: Writable for ROM_TRAP_ADDR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ROM_TRAP_ADDR to value 0"]
impl crate :: Resettable for ROM_TRAP_ADDR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ROM_TRAP_SYND register accessor: an alias for `Reg<ROM_TRAP_SYND_SPEC>`"]
pub type ROM_TRAP_SYND = crate :: Reg < rom_trap_synd :: ROM_TRAP_SYND_SPEC > ; # [doc = "ROM Trap Syndrome"]
pub mod rom_trap_synd { # [doc = "Register `ROM_TRAP_SYND` reader"]
pub struct R (crate :: R < ROM_TRAP_SYND_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ROM_TRAP_SYND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ROM_TRAP_SYND_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ROM_TRAP_SYND_SPEC >) -> Self { R (reader) } } # [doc = "Register `ROM_TRAP_SYND` writer"]
pub struct W (crate :: W < ROM_TRAP_SYND_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ROM_TRAP_SYND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ROM_TRAP_SYND_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ROM_TRAP_SYND_SPEC >) -> Self { W (writer) } } # [doc = "Field `SYND` reader - Trap Syndrom Bits"]
pub struct SYND_R (crate :: FieldReader < u32 , u32 >) ; impl SYND_R { pub (crate) fn new (bits : u32) -> Self { SYND_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for SYND_R { type Target = crate :: FieldReader < u32 , u32 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `SYND` writer - Trap Syndrom Bits"]
pub struct SYND_W < 'a > { w : & 'a mut W , } impl < 'a > SYND_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u32) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x000f_ffff) | (value as u32 & 0x000f_ffff) ; self . w } } impl R { # [doc = "Bits 0:19 - Trap Syndrom Bits"]
# [inline (always)]
pub fn synd (& self) -> SYND_R { SYND_R :: new ((self . bits & 0x000f_ffff) as u32) } } impl W { # [doc = "Bits 0:19 - Trap Syndrom Bits"]
# [inline (always)]
pub fn synd (& mut self) -> SYND_W { SYND_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "ROM Trap Syndrome\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rom_trap_synd](index.html) module"]
pub struct ROM_TRAP_SYND_SPEC ; impl crate :: RegisterSpec for ROM_TRAP_SYND_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rom_trap_synd::R](R) reader structure"]
impl crate :: Readable for ROM_TRAP_SYND_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rom_trap_synd::W](W) writer structure"]
impl crate :: Writable for ROM_TRAP_SYND_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ROM_TRAP_SYND to value 0"]
impl crate :: Resettable for ROM_TRAP_SYND_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RAM_TRAP_ADDR register accessor: an alias for `Reg<RAM_TRAP_ADDR_SPEC>`"]
pub type RAM_TRAP_ADDR = crate :: Reg < ram_trap_addr :: RAM_TRAP_ADDR_SPEC > ; # [doc = "RAM Trap Address"]
pub mod ram_trap_addr { # [doc = "Register `RAM_TRAP_ADDR` reader"]
pub struct R (crate :: R < RAM_TRAP_ADDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RAM_TRAP_ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RAM_TRAP_ADDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RAM_TRAP_ADDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `RAM_TRAP_ADDR` writer"]
pub struct W (crate :: W < RAM_TRAP_ADDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RAM_TRAP_ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RAM_TRAP_ADDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RAM_TRAP_ADDR_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADDR` reader - Trap Address Match Bits"]
pub struct ADDR_R (crate :: FieldReader < u16 , u16 >) ; impl ADDR_R { pub (crate) fn new (bits : u16) -> Self { ADDR_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ADDR_R { type Target = crate :: FieldReader < u16 , u16 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ADDR` writer - Trap Address Match Bits"]
pub struct ADDR_W < 'a > { w : & 'a mut W , } impl < 'a > ADDR_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u16) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x3fff << 2)) | ((value as u32 & 0x3fff) << 2) ; self . w } } # [doc = "Field `ENABLE` reader - Trap Enable Bit"]
pub struct ENABLE_R (crate :: FieldReader < bool , bool >) ; impl ENABLE_R { pub (crate) fn new (bits : bool) -> Self { ENABLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ENABLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ENABLE` writer - Trap Enable Bit"]
pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 31)) | ((value as u32 & 0x01) << 31) ; self . w } } impl R { # [doc = "Bits 2:15 - Trap Address Match Bits"]
# [inline (always)]
pub fn addr (& self) -> ADDR_R { ADDR_R :: new (((self . bits >> 2) & 0x3fff) as u16) } # [doc = "Bit 31 - Trap Enable Bit"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 31) & 0x01) != 0) } } impl W { # [doc = "Bits 2:15 - Trap Address Match Bits"]
# [inline (always)]
pub fn addr (& mut self) -> ADDR_W { ADDR_W { w : self } } # [doc = "Bit 31 - Trap Enable Bit"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "RAM Trap Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ram_trap_addr](index.html) module"]
pub struct RAM_TRAP_ADDR_SPEC ; impl crate :: RegisterSpec for RAM_TRAP_ADDR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ram_trap_addr::R](R) reader structure"]
impl crate :: Readable for RAM_TRAP_ADDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ram_trap_addr::W](W) writer structure"]
impl crate :: Writable for RAM_TRAP_ADDR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RAM_TRAP_ADDR to value 0"]
impl crate :: Resettable for RAM_TRAP_ADDR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RAM_TRAP_SYND register accessor: an alias for `Reg<RAM_TRAP_SYND_SPEC>`"]
pub type RAM_TRAP_SYND = crate :: Reg < ram_trap_synd :: RAM_TRAP_SYND_SPEC > ; # [doc = "RAM Trap Syndrome"]
pub mod ram_trap_synd { # [doc = "Register `RAM_TRAP_SYND` reader"]
pub struct R (crate :: R < RAM_TRAP_SYND_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RAM_TRAP_SYND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RAM_TRAP_SYND_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RAM_TRAP_SYND_SPEC >) -> Self { R (reader) } } # [doc = "Register `RAM_TRAP_SYND` writer"]
pub struct W (crate :: W < RAM_TRAP_SYND_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RAM_TRAP_SYND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RAM_TRAP_SYND_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RAM_TRAP_SYND_SPEC >) -> Self { W (writer) } } # [doc = "Field `SYND` reader - Trap Syndrom Bits"]
pub struct SYND_R (crate :: FieldReader < u32 , u32 >) ; impl SYND_R { pub (crate) fn new (bits : u32) -> Self { SYND_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for SYND_R { type Target = crate :: FieldReader < u32 , u32 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `SYND` writer - Trap Syndrom Bits"]
pub struct SYND_W < 'a > { w : & 'a mut W , } impl < 'a > SYND_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u32) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x000f_ffff) | (value as u32 & 0x000f_ffff) ; self . w } } impl R { # [doc = "Bits 0:19 - Trap Syndrom Bits"]
# [inline (always)]
pub fn synd (& self) -> SYND_R { SYND_R :: new ((self . bits & 0x000f_ffff) as u32) } } impl W { # [doc = "Bits 0:19 - Trap Syndrom Bits"]
# [inline (always)]
pub fn synd (& mut self) -> SYND_W { SYND_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "RAM Trap Syndrome\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ram_trap_synd](index.html) module"]
pub struct RAM_TRAP_SYND_SPEC ; impl crate :: RegisterSpec for RAM_TRAP_SYND_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ram_trap_synd::R](R) reader structure"]
impl crate :: Readable for RAM_TRAP_SYND_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ram_trap_synd::W](W) writer structure"]
impl crate :: Writable for RAM_TRAP_SYND_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RAM_TRAP_SYND to value 0"]
impl crate :: Resettable for RAM_TRAP_SYND_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_ENB register accessor: an alias for `Reg<IRQ_ENB_SPEC>`"]
pub type IRQ_ENB = crate :: Reg < irq_enb :: IRQ_ENB_SPEC > ; # [doc = "Enable EDAC Error Interrupt Register"]
pub mod irq_enb { # [doc = "Register `IRQ_ENB` reader"]
pub struct R (crate :: R < IRQ_ENB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_ENB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_ENB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_ENB_SPEC >) -> Self { R (reader) } } # [doc = "Register `IRQ_ENB` writer"]
pub struct W (crate :: W < IRQ_ENB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IRQ_ENB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IRQ_ENB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IRQ_ENB_SPEC >) -> Self { W (writer) } } # [doc = "Field `RAMSBE` reader - RAM Single Bit Interrupt"]
pub struct RAMSBE_R (crate :: FieldReader < bool , bool >) ; impl RAMSBE_R { pub (crate) fn new (bits : bool) -> Self { RAMSBE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RAMSBE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RAMSBE` writer - RAM Single Bit Interrupt"]
pub struct RAMSBE_W < 'a > { w : & 'a mut W , } impl < 'a > RAMSBE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `RAMMBE` reader - RAM Multi Bit Interrupt"]
pub struct RAMMBE_R (crate :: FieldReader < bool , bool >) ; impl RAMMBE_R { pub (crate) fn new (bits : bool) -> Self { RAMMBE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RAMMBE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RAMMBE` writer - RAM Multi Bit Interrupt"]
pub struct RAMMBE_W < 'a > { w : & 'a mut W , } impl < 'a > RAMMBE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `ROMSBE` reader - ROM Single Bit Interrupt"]
pub struct ROMSBE_R (crate :: FieldReader < bool , bool >) ; impl ROMSBE_R { pub (crate) fn new (bits : bool) -> Self { ROMSBE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ROMSBE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ROMSBE` writer - ROM Single Bit Interrupt"]
pub struct ROMSBE_W < 'a > { w : & 'a mut W , } impl < 'a > ROMSBE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `ROMMBE` reader - ROM Multi Bit Interrupt"]
pub struct ROMMBE_R (crate :: FieldReader < bool , bool >) ; impl ROMMBE_R { pub (crate) fn new (bits : bool) -> Self { ROMMBE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ROMMBE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ROMMBE` writer - ROM Multi Bit Interrupt"]
pub struct ROMMBE_W < 'a > { w : & 'a mut W , } impl < 'a > ROMMBE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } impl R { # [doc = "Bit 0 - RAM Single Bit Interrupt"]
# [inline (always)]
pub fn ramsbe (& self) -> RAMSBE_R { RAMSBE_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - RAM Multi Bit Interrupt"]
# [inline (always)]
pub fn rammbe (& self) -> RAMMBE_R { RAMMBE_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - ROM Single Bit Interrupt"]
# [inline (always)]
pub fn romsbe (& self) -> ROMSBE_R { ROMSBE_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - ROM Multi Bit Interrupt"]
# [inline (always)]
pub fn rommbe (& self) -> ROMMBE_R { ROMMBE_R :: new (((self . bits >> 3) & 0x01) != 0) } } impl W { # [doc = "Bit 0 - RAM Single Bit Interrupt"]
# [inline (always)]
pub fn ramsbe (& mut self) -> RAMSBE_W { RAMSBE_W { w : self } } # [doc = "Bit 1 - RAM Multi Bit Interrupt"]
# [inline (always)]
pub fn rammbe (& mut self) -> RAMMBE_W { RAMMBE_W { w : self } } # [doc = "Bit 2 - ROM Single Bit Interrupt"]
# [inline (always)]
pub fn romsbe (& mut self) -> ROMSBE_W { ROMSBE_W { w : self } } # [doc = "Bit 3 - ROM Multi Bit Interrupt"]
# [inline (always)]
pub fn rommbe (& mut self) -> ROMMBE_W { ROMMBE_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Enable EDAC Error Interrupt Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_enb](index.html) module"]
pub struct IRQ_ENB_SPEC ; impl crate :: RegisterSpec for IRQ_ENB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_enb::R](R) reader structure"]
impl crate :: Readable for IRQ_ENB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [irq_enb::W](W) writer structure"]
impl crate :: Writable for IRQ_ENB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets IRQ_ENB to value 0"]
impl crate :: Resettable for IRQ_ENB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_RAW register accessor: an alias for `Reg<IRQ_RAW_SPEC>`"]
pub type IRQ_RAW = crate :: Reg < irq_raw :: IRQ_RAW_SPEC > ; # [doc = "Raw EDAC Error Interrupt Status"]
pub mod irq_raw { # [doc = "Register `IRQ_RAW` reader"]
pub struct R (crate :: R < IRQ_RAW_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_RAW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_RAW_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_RAW_SPEC >) -> Self { R (reader) } } # [doc = "Field `RAMSBE` reader - RAM Single Bit Interrupt"]
pub struct RAMSBE_R (crate :: FieldReader < bool , bool >) ; impl RAMSBE_R { pub (crate) fn new (bits : bool) -> Self { RAMSBE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RAMSBE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RAMMBE` reader - RAM Multi Bit Interrupt"]
pub struct RAMMBE_R (crate :: FieldReader < bool , bool >) ; impl RAMMBE_R { pub (crate) fn new (bits : bool) -> Self { RAMMBE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RAMMBE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ROMSBE` reader - ROM Single Bit Interrupt"]
pub struct ROMSBE_R (crate :: FieldReader < bool , bool >) ; impl ROMSBE_R { pub (crate) fn new (bits : bool) -> Self { ROMSBE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ROMSBE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ROMMBE` reader - ROM Multi Bit Interrupt"]
pub struct ROMMBE_R (crate :: FieldReader < bool , bool >) ; impl ROMMBE_R { pub (crate) fn new (bits : bool) -> Self { ROMMBE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ROMMBE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - RAM Single Bit Interrupt"]
# [inline (always)]
pub fn ramsbe (& self) -> RAMSBE_R { RAMSBE_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - RAM Multi Bit Interrupt"]
# [inline (always)]
pub fn rammbe (& self) -> RAMMBE_R { RAMMBE_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - ROM Single Bit Interrupt"]
# [inline (always)]
pub fn romsbe (& self) -> ROMSBE_R { ROMSBE_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - ROM Multi Bit Interrupt"]
# [inline (always)]
pub fn rommbe (& self) -> ROMMBE_R { ROMMBE_R :: new (((self . bits >> 3) & 0x01) != 0) } } # [doc = "Raw EDAC Error Interrupt Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_raw](index.html) module"]
pub struct IRQ_RAW_SPEC ; impl crate :: RegisterSpec for IRQ_RAW_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_raw::R](R) reader structure"]
impl crate :: Readable for IRQ_RAW_SPEC { type Reader = R ; } # [doc = "`reset()` method sets IRQ_RAW to value 0"]
impl crate :: Resettable for IRQ_RAW_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_END register accessor: an alias for `Reg<IRQ_END_SPEC>`"]
pub type IRQ_END = crate :: Reg < irq_end :: IRQ_END_SPEC > ; # [doc = "Enabled EDAC Error Interrupt Status"]
pub mod irq_end { # [doc = "Register `IRQ_END` reader"]
pub struct R (crate :: R < IRQ_END_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_END_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_END_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_END_SPEC >) -> Self { R (reader) } } # [doc = "Field `RAMSBE` reader - RAM Single Bit Interrupt"]
pub struct RAMSBE_R (crate :: FieldReader < bool , bool >) ; impl RAMSBE_R { pub (crate) fn new (bits : bool) -> Self { RAMSBE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RAMSBE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RAMMBE` reader - RAM Multi Bit Interrupt"]
pub struct RAMMBE_R (crate :: FieldReader < bool , bool >) ; impl RAMMBE_R { pub (crate) fn new (bits : bool) -> Self { RAMMBE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RAMMBE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ROMSBE` reader - ROM Single Bit Interrupt"]
pub struct ROMSBE_R (crate :: FieldReader < bool , bool >) ; impl ROMSBE_R { pub (crate) fn new (bits : bool) -> Self { ROMSBE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ROMSBE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ROMMBE` reader - ROM Multi Bit Interrupt"]
pub struct ROMMBE_R (crate :: FieldReader < bool , bool >) ; impl ROMMBE_R { pub (crate) fn new (bits : bool) -> Self { ROMMBE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ROMMBE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - RAM Single Bit Interrupt"]
# [inline (always)]
pub fn ramsbe (& self) -> RAMSBE_R { RAMSBE_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - RAM Multi Bit Interrupt"]
# [inline (always)]
pub fn rammbe (& self) -> RAMMBE_R { RAMMBE_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - ROM Single Bit Interrupt"]
# [inline (always)]
pub fn romsbe (& self) -> ROMSBE_R { ROMSBE_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - ROM Multi Bit Interrupt"]
# [inline (always)]
pub fn rommbe (& self) -> ROMMBE_R { ROMMBE_R :: new (((self . bits >> 3) & 0x01) != 0) } } # [doc = "Enabled EDAC Error Interrupt Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_end](index.html) module"]
pub struct IRQ_END_SPEC ; impl crate :: RegisterSpec for IRQ_END_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_end::R](R) reader structure"]
impl crate :: Readable for IRQ_END_SPEC { type Reader = R ; } # [doc = "`reset()` method sets IRQ_END to value 0"]
impl crate :: Resettable for IRQ_END_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_CLR register accessor: an alias for `Reg<IRQ_CLR_SPEC>`"]
pub type IRQ_CLR = crate :: Reg < irq_clr :: IRQ_CLR_SPEC > ; # [doc = "Clear EDAC Error Interrupt Status"]
pub mod irq_clr { # [doc = "Register `IRQ_CLR` writer"]
pub struct W (crate :: W < IRQ_CLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IRQ_CLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IRQ_CLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IRQ_CLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `RAMSBE` writer - RAM Single Bit Interrupt"]
pub struct RAMSBE_W < 'a > { w : & 'a mut W , } impl < 'a > RAMSBE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `RAMMBE` writer - RAM Multi Bit Interrupt"]
pub struct RAMMBE_W < 'a > { w : & 'a mut W , } impl < 'a > RAMMBE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `ROMSBE` writer - ROM Single Bit Interrupt"]
pub struct ROMSBE_W < 'a > { w : & 'a mut W , } impl < 'a > ROMSBE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `ROMMBE` writer - ROM Multi Bit Interrupt"]
pub struct ROMMBE_W < 'a > { w : & 'a mut W , } impl < 'a > ROMMBE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } impl W { # [doc = "Bit 0 - RAM Single Bit Interrupt"]
# [inline (always)]
pub fn ramsbe (& mut self) -> RAMSBE_W { RAMSBE_W { w : self } } # [doc = "Bit 1 - RAM Multi Bit Interrupt"]
# [inline (always)]
pub fn rammbe (& mut self) -> RAMMBE_W { RAMMBE_W { w : self } } # [doc = "Bit 2 - ROM Single Bit Interrupt"]
# [inline (always)]
pub fn romsbe (& mut self) -> ROMSBE_W { ROMSBE_W { w : self } } # [doc = "Bit 3 - ROM Multi Bit Interrupt"]
# [inline (always)]
pub fn rommbe (& mut self) -> ROMMBE_W { ROMMBE_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clear EDAC Error Interrupt Status\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_clr](index.html) module"]
pub struct IRQ_CLR_SPEC ; impl crate :: RegisterSpec for IRQ_CLR_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [irq_clr::W](W) writer structure"]
impl crate :: Writable for IRQ_CLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets IRQ_CLR to value 0"]
impl crate :: Resettable for IRQ_CLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RAM_SBE register accessor: an alias for `Reg<RAM_SBE_SPEC>`"]
pub type RAM_SBE = crate :: Reg < ram_sbe :: RAM_SBE_SPEC > ; # [doc = "Count of RAM EDAC Single Bit Errors"]
pub mod ram_sbe { # [doc = "Register `RAM_SBE` reader"]
pub struct R (crate :: R < RAM_SBE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RAM_SBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RAM_SBE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RAM_SBE_SPEC >) -> Self { R (reader) } } # [doc = "Register `RAM_SBE` writer"]
pub struct W (crate :: W < RAM_SBE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RAM_SBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RAM_SBE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RAM_SBE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Count of RAM EDAC Single Bit Errors\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ram_sbe](index.html) module"]
pub struct RAM_SBE_SPEC ; impl crate :: RegisterSpec for RAM_SBE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ram_sbe::R](R) reader structure"]
impl crate :: Readable for RAM_SBE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ram_sbe::W](W) writer structure"]
impl crate :: Writable for RAM_SBE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RAM_SBE to value 0"]
impl crate :: Resettable for RAM_SBE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RAM_MBE register accessor: an alias for `Reg<RAM_MBE_SPEC>`"]
pub type RAM_MBE = crate :: Reg < ram_mbe :: RAM_MBE_SPEC > ; # [doc = "Count of RAM EDAC Multi Bit Errors"]
pub mod ram_mbe { # [doc = "Register `RAM_MBE` reader"]
pub struct R (crate :: R < RAM_MBE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RAM_MBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RAM_MBE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RAM_MBE_SPEC >) -> Self { R (reader) } } # [doc = "Register `RAM_MBE` writer"]
pub struct W (crate :: W < RAM_MBE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RAM_MBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RAM_MBE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RAM_MBE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Count of RAM EDAC Multi Bit Errors\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ram_mbe](index.html) module"]
pub struct RAM_MBE_SPEC ; impl crate :: RegisterSpec for RAM_MBE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ram_mbe::R](R) reader structure"]
impl crate :: Readable for RAM_MBE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ram_mbe::W](W) writer structure"]
impl crate :: Writable for RAM_MBE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RAM_MBE to value 0"]
impl crate :: Resettable for RAM_MBE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ROM_SBE register accessor: an alias for `Reg<ROM_SBE_SPEC>`"]
pub type ROM_SBE = crate :: Reg < rom_sbe :: ROM_SBE_SPEC > ; # [doc = "Count of ROM EDAC Single Bit Errors"]
pub mod rom_sbe { # [doc = "Register `ROM_SBE` reader"]
pub struct R (crate :: R < ROM_SBE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ROM_SBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ROM_SBE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ROM_SBE_SPEC >) -> Self { R (reader) } } # [doc = "Register `ROM_SBE` writer"]
pub struct W (crate :: W < ROM_SBE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ROM_SBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ROM_SBE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ROM_SBE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Count of ROM EDAC Single Bit Errors\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rom_sbe](index.html) module"]
pub struct ROM_SBE_SPEC ; impl crate :: RegisterSpec for ROM_SBE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rom_sbe::R](R) reader structure"]
impl crate :: Readable for ROM_SBE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rom_sbe::W](W) writer structure"]
impl crate :: Writable for ROM_SBE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ROM_SBE to value 0"]
impl crate :: Resettable for ROM_SBE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ROM_MBE register accessor: an alias for `Reg<ROM_MBE_SPEC>`"]
pub type ROM_MBE = crate :: Reg < rom_mbe :: ROM_MBE_SPEC > ; # [doc = "Count of ROM EDAC Multi Bit Errors"]
pub mod rom_mbe { # [doc = "Register `ROM_MBE` reader"]
pub struct R (crate :: R < ROM_MBE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ROM_MBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ROM_MBE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ROM_MBE_SPEC >) -> Self { R (reader) } } # [doc = "Register `ROM_MBE` writer"]
pub struct W (crate :: W < ROM_MBE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ROM_MBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ROM_MBE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ROM_MBE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Count of ROM EDAC Multi Bit Errors\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rom_mbe](index.html) module"]
pub struct ROM_MBE_SPEC ; impl crate :: RegisterSpec for ROM_MBE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rom_mbe::R](R) reader structure"]
impl crate :: Readable for ROM_MBE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rom_mbe::W](W) writer structure"]
impl crate :: Writable for ROM_MBE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ROM_MBE to value 0"]
impl crate :: Resettable for ROM_MBE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IOCONFIG_CLKDIV0 register accessor: an alias for `Reg<IOCONFIG_CLKDIV0_SPEC>`"]
pub type IOCONFIG_CLKDIV0 = crate :: Reg < ioconfig_clkdiv0 :: IOCONFIG_CLKDIV0_SPEC > ; # [doc = "IO Configuration Clock Divider Register"]
pub mod ioconfig_clkdiv0 { # [doc = "Register `IOCONFIG_CLKDIV0` reader"]
pub struct R (crate :: R < IOCONFIG_CLKDIV0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IOCONFIG_CLKDIV0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IOCONFIG_CLKDIV0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IOCONFIG_CLKDIV0_SPEC >) -> Self { R (reader) } } # [doc = "IO Configuration Clock Divider Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ioconfig_clkdiv0](index.html) module"]
pub struct IOCONFIG_CLKDIV0_SPEC ; impl crate :: RegisterSpec for IOCONFIG_CLKDIV0_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ioconfig_clkdiv0::R](R) reader structure"]
impl crate :: Readable for IOCONFIG_CLKDIV0_SPEC { type Reader = R ; } # [doc = "`reset()` method sets IOCONFIG_CLKDIV0 to value 0"]
impl crate :: Resettable for IOCONFIG_CLKDIV0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IOCONFIG_CLKDIV register accessor: an alias for `Reg<IOCONFIG_CLKDIV_SPEC>`"]
pub type IOCONFIG_CLKDIV = crate :: Reg < ioconfig_clkdiv :: IOCONFIG_CLKDIV_SPEC > ; # [doc = "IO Configuration Clock Divider Register"]
pub mod ioconfig_clkdiv { # [doc = "Register `IOCONFIG_CLKDIV%s` reader"]
pub struct R (crate :: R < IOCONFIG_CLKDIV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IOCONFIG_CLKDIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IOCONFIG_CLKDIV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IOCONFIG_CLKDIV_SPEC >) -> Self { R (reader) } } # [doc = "Register `IOCONFIG_CLKDIV%s` writer"]
pub struct W (crate :: W < IOCONFIG_CLKDIV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IOCONFIG_CLKDIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IOCONFIG_CLKDIV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IOCONFIG_CLKDIV_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "IO Configuration Clock Divider Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ioconfig_clkdiv](index.html) module"]
pub struct IOCONFIG_CLKDIV_SPEC ; impl crate :: RegisterSpec for IOCONFIG_CLKDIV_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ioconfig_clkdiv::R](R) reader structure"]
impl crate :: Readable for IOCONFIG_CLKDIV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ioconfig_clkdiv::W](W) writer structure"]
impl crate :: Writable for IOCONFIG_CLKDIV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets IOCONFIG_CLKDIV%s to value 0"]
impl crate :: Resettable for IOCONFIG_CLKDIV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ROM_RETRIES register accessor: an alias for `Reg<ROM_RETRIES_SPEC>`"]
pub type ROM_RETRIES = crate :: Reg < rom_retries :: ROM_RETRIES_SPEC > ; # [doc = "ROM BOOT Retry count"]
pub mod rom_retries { # [doc = "Register `ROM_RETRIES` reader"]
pub struct R (crate :: R < ROM_RETRIES_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ROM_RETRIES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ROM_RETRIES_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ROM_RETRIES_SPEC >) -> Self { R (reader) } } # [doc = "ROM BOOT Retry count\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rom_retries](index.html) module"]
pub struct ROM_RETRIES_SPEC ; impl crate :: RegisterSpec for ROM_RETRIES_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rom_retries::R](R) reader structure"]
impl crate :: Readable for ROM_RETRIES_SPEC { type Reader = R ; } # [doc = "`reset()` method sets ROM_RETRIES to value 0"]
impl crate :: Resettable for ROM_RETRIES_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "REFRESH_CONFIG register accessor: an alias for `Reg<REFRESH_CONFIG_SPEC>`"]
pub type REFRESH_CONFIG = crate :: Reg < refresh_config :: REFRESH_CONFIG_SPEC > ; # [doc = "Register Refresh Control"]
pub mod refresh_config { # [doc = "Register `REFRESH_CONFIG` reader"]
pub struct R (crate :: R < REFRESH_CONFIG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < REFRESH_CONFIG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < REFRESH_CONFIG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < REFRESH_CONFIG_SPEC >) -> Self { R (reader) } } # [doc = "Register `REFRESH_CONFIG` writer"]
pub struct W (crate :: W < REFRESH_CONFIG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < REFRESH_CONFIG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < REFRESH_CONFIG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < REFRESH_CONFIG_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Register Refresh Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [refresh_config](index.html) module"]
pub struct REFRESH_CONFIG_SPEC ; impl crate :: RegisterSpec for REFRESH_CONFIG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [refresh_config::R](R) reader structure"]
impl crate :: Readable for REFRESH_CONFIG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [refresh_config::W](W) writer structure"]
impl crate :: Writable for REFRESH_CONFIG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets REFRESH_CONFIG to value 0"]
impl crate :: Resettable for REFRESH_CONFIG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TIM_RESET register accessor: an alias for `Reg<TIM_RESET_SPEC>`"]
pub type TIM_RESET = crate :: Reg < tim_reset :: TIM_RESET_SPEC > ; # [doc = "TIM Reset Control"]
pub mod tim_reset { # [doc = "Register `TIM_RESET` reader"]
pub struct R (crate :: R < TIM_RESET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIM_RESET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIM_RESET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIM_RESET_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIM_RESET` writer"]
pub struct W (crate :: W < TIM_RESET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIM_RESET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIM_RESET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIM_RESET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "TIM Reset Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tim_reset](index.html) module"]
pub struct TIM_RESET_SPEC ; impl crate :: RegisterSpec for TIM_RESET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [tim_reset::R](R) reader structure"]
impl crate :: Readable for TIM_RESET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tim_reset::W](W) writer structure"]
impl crate :: Writable for TIM_RESET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TIM_RESET to value 0xffff_ffff"]
impl crate :: Resettable for TIM_RESET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xffff_ffff } } } # [doc = "TIM_CLK_ENABLE register accessor: an alias for `Reg<TIM_CLK_ENABLE_SPEC>`"]
pub type TIM_CLK_ENABLE = crate :: Reg < tim_clk_enable :: TIM_CLK_ENABLE_SPEC > ; # [doc = "TIM Enable Control"]
pub mod tim_clk_enable { # [doc = "Register `TIM_CLK_ENABLE` reader"]
pub struct R (crate :: R < TIM_CLK_ENABLE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIM_CLK_ENABLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIM_CLK_ENABLE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIM_CLK_ENABLE_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIM_CLK_ENABLE` writer"]
pub struct W (crate :: W < TIM_CLK_ENABLE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIM_CLK_ENABLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIM_CLK_ENABLE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIM_CLK_ENABLE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "TIM Enable Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tim_clk_enable](index.html) module"]
pub struct TIM_CLK_ENABLE_SPEC ; impl crate :: RegisterSpec for TIM_CLK_ENABLE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [tim_clk_enable::R](R) reader structure"]
impl crate :: Readable for TIM_CLK_ENABLE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tim_clk_enable::W](W) writer structure"]
impl crate :: Writable for TIM_CLK_ENABLE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TIM_CLK_ENABLE to value 0"]
impl crate :: Resettable for TIM_CLK_ENABLE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PERIPHERAL_RESET register accessor: an alias for `Reg<PERIPHERAL_RESET_SPEC>`"]
pub type PERIPHERAL_RESET = crate :: Reg < peripheral_reset :: PERIPHERAL_RESET_SPEC > ; # [doc = "Peripheral Reset Control"]
pub mod peripheral_reset { # [doc = "Register `PERIPHERAL_RESET` reader"]
pub struct R (crate :: R < PERIPHERAL_RESET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERIPHERAL_RESET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERIPHERAL_RESET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERIPHERAL_RESET_SPEC >) -> Self { R (reader) } } # [doc = "Register `PERIPHERAL_RESET` writer"]
pub struct W (crate :: W < PERIPHERAL_RESET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PERIPHERAL_RESET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PERIPHERAL_RESET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PERIPHERAL_RESET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Peripheral Reset Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [peripheral_reset](index.html) module"]
pub struct PERIPHERAL_RESET_SPEC ; impl crate :: RegisterSpec for PERIPHERAL_RESET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [peripheral_reset::R](R) reader structure"]
impl crate :: Readable for PERIPHERAL_RESET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [peripheral_reset::W](W) writer structure"]
impl crate :: Writable for PERIPHERAL_RESET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PERIPHERAL_RESET to value 0xffff_ffff"]
impl crate :: Resettable for PERIPHERAL_RESET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xffff_ffff } } } # [doc = "PERIPHERAL_CLK_ENABLE register accessor: an alias for `Reg<PERIPHERAL_CLK_ENABLE_SPEC>`"]
pub type PERIPHERAL_CLK_ENABLE = crate :: Reg < peripheral_clk_enable :: PERIPHERAL_CLK_ENABLE_SPEC > ; # [doc = "Peripheral Enable Control"]
pub mod peripheral_clk_enable { # [doc = "Register `PERIPHERAL_CLK_ENABLE` reader"]
pub struct R (crate :: R < PERIPHERAL_CLK_ENABLE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERIPHERAL_CLK_ENABLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERIPHERAL_CLK_ENABLE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERIPHERAL_CLK_ENABLE_SPEC >) -> Self { R (reader) } } # [doc = "Register `PERIPHERAL_CLK_ENABLE` writer"]
pub struct W (crate :: W < PERIPHERAL_CLK_ENABLE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PERIPHERAL_CLK_ENABLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PERIPHERAL_CLK_ENABLE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PERIPHERAL_CLK_ENABLE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Peripheral Enable Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [peripheral_clk_enable](index.html) module"]
pub struct PERIPHERAL_CLK_ENABLE_SPEC ; impl crate :: RegisterSpec for PERIPHERAL_CLK_ENABLE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [peripheral_clk_enable::R](R) reader structure"]
impl crate :: Readable for PERIPHERAL_CLK_ENABLE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [peripheral_clk_enable::W](W) writer structure"]
impl crate :: Writable for PERIPHERAL_CLK_ENABLE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PERIPHERAL_CLK_ENABLE to value 0"]
impl crate :: Resettable for PERIPHERAL_CLK_ENABLE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "LOCKUP_RESET register accessor: an alias for `Reg<LOCKUP_RESET_SPEC>`"]
pub type LOCKUP_RESET = crate :: Reg < lockup_reset :: LOCKUP_RESET_SPEC > ; # [doc = "Lockup Reset Configuration"]
pub mod lockup_reset { # [doc = "Register `LOCKUP_RESET` reader"]
pub struct R (crate :: R < LOCKUP_RESET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOCKUP_RESET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOCKUP_RESET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOCKUP_RESET_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOCKUP_RESET` writer"]
pub struct W (crate :: W < LOCKUP_RESET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOCKUP_RESET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOCKUP_RESET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOCKUP_RESET_SPEC >) -> Self { W (writer) } } # [doc = "Field `LREN` reader - Lockup Reset Enable Bit"]
pub struct LREN_R (crate :: FieldReader < bool , bool >) ; impl LREN_R { pub (crate) fn new (bits : bool) -> Self { LREN_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for LREN_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `LREN` writer - Lockup Reset Enable Bit"]
pub struct LREN_W < 'a > { w : & 'a mut W , } impl < 'a > LREN_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } impl R { # [doc = "Bit 0 - Lockup Reset Enable Bit"]
# [inline (always)]
pub fn lren (& self) -> LREN_R { LREN_R :: new ((self . bits & 0x01) != 0) } } impl W { # [doc = "Bit 0 - Lockup Reset Enable Bit"]
# [inline (always)]
pub fn lren (& mut self) -> LREN_W { LREN_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Lockup Reset Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lockup_reset](index.html) module"]
pub struct LOCKUP_RESET_SPEC ; impl crate :: RegisterSpec for LOCKUP_RESET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [lockup_reset::R](R) reader structure"]
impl crate :: Readable for LOCKUP_RESET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lockup_reset::W](W) writer structure"]
impl crate :: Writable for LOCKUP_RESET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets LOCKUP_RESET to value 0x01"]
impl crate :: Resettable for LOCKUP_RESET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x01 } } } # [doc = "EF_CONFIG register accessor: an alias for `Reg<EF_CONFIG_SPEC>`"]
pub type EF_CONFIG = crate :: Reg < ef_config :: EF_CONFIG_SPEC > ; # [doc = "EFuse Config Register"]
pub mod ef_config { # [doc = "Register `EF_CONFIG` reader"]
pub struct R (crate :: R < EF_CONFIG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EF_CONFIG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EF_CONFIG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EF_CONFIG_SPEC >) -> Self { R (reader) } } # [doc = "EFuse Config Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ef_config](index.html) module"]
pub struct EF_CONFIG_SPEC ; impl crate :: RegisterSpec for EF_CONFIG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ef_config::R](R) reader structure"]
impl crate :: Readable for EF_CONFIG_SPEC { type Reader = R ; } # [doc = "`reset()` method sets EF_CONFIG to value 0"]
impl crate :: Resettable for EF_CONFIG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EF_ID register accessor: an alias for `Reg<EF_ID_SPEC>`"]
pub type EF_ID = crate :: Reg < ef_id :: EF_ID_SPEC > ; # [doc = "EFuse ID Register"]
pub mod ef_id { # [doc = "Register `EF_ID` reader"]
pub struct R (crate :: R < EF_ID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EF_ID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EF_ID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EF_ID_SPEC >) -> Self { R (reader) } } # [doc = "EFuse ID Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ef_id](index.html) module"]
pub struct EF_ID_SPEC ; impl crate :: RegisterSpec for EF_ID_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ef_id::R](R) reader structure"]
impl crate :: Readable for EF_ID_SPEC { type Reader = R ; } # [doc = "`reset()` method sets EF_ID to value 0"]
impl crate :: Resettable for EF_ID_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PROCID register accessor: an alias for `Reg<PROCID_SPEC>`"]
pub type PROCID = crate :: Reg < procid :: PROCID_SPEC > ; # [doc = "Processor ID Register"]
pub mod procid { # [doc = "Register `PROCID` reader"]
pub struct R (crate :: R < PROCID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PROCID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PROCID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PROCID_SPEC >) -> Self { R (reader) } } # [doc = "Processor ID Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [procid](index.html) module"]
pub struct PROCID_SPEC ; impl crate :: RegisterSpec for PROCID_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [procid::R](R) reader structure"]
impl crate :: Readable for PROCID_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PROCID to value 0x0400_17e3"]
impl crate :: Resettable for PROCID_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x0400_17e3 } } } # [doc = "PERID register accessor: an alias for `Reg<PERID_SPEC>`"]
pub type PERID = crate :: Reg < perid :: PERID_SPEC > ; # [doc = "Peripheral ID Register"]
pub mod perid { # [doc = "Register `PERID` reader"]
pub struct R (crate :: R < PERID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERID_SPEC >) -> Self { R (reader) } } # [doc = "Peripheral ID Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perid](index.html) module"]
pub struct PERID_SPEC ; impl crate :: RegisterSpec for PERID_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [perid::R](R) reader structure"]
impl crate :: Readable for PERID_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PERID to value 0x0080_07e1"]
impl crate :: Resettable for PERID_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x0080_07e1 } } } } # [doc = "Interrupt Selector Peripheral"]
pub struct IRQSEL { _marker : PhantomData < * const () > } unsafe impl Send for IRQSEL { } impl IRQSEL { # [doc = r"Pointer to the register block"]
pub const PTR : * const irqsel :: RegisterBlock = 0x4000_1000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const irqsel :: RegisterBlock { Self :: PTR } } impl Deref for IRQSEL { type Target = irqsel :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for IRQSEL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("IRQSEL") . finish () } } # [doc = "Interrupt Selector Peripheral"]
pub mod irqsel { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { _reserved0 : [u8 ; 0x01c0]
, # [doc = "0x1c0 - Internal Memory RAM SBE Interrupt Redirect Selection"]
pub int_ram_sbe : crate :: Reg < int_ram_sbe :: INT_RAM_SBE_SPEC > , # [doc = "0x1c4 - Internal Memory RAM MBE Interrupt Redirect Selection"]
pub int_ram_mbe : crate :: Reg < int_ram_mbe :: INT_RAM_MBE_SPEC > , # [doc = "0x1c8 - Internal Memory ROM SBE Interrupt Redirect Selection"]
pub int_rom_sbe : crate :: Reg < int_rom_sbe :: INT_ROM_SBE_SPEC > , # [doc = "0x1cc - Internal Memory ROM MBE Interrupt Redirect Selection"]
pub int_rom_mbe : crate :: Reg < int_rom_mbe :: INT_ROM_MBE_SPEC > , # [doc = "0x1d0 - Processor TXEV Interrupt Redirect Selection"]
pub txev : crate :: Reg < txev :: TXEV_SPEC > , _reserved5 : [u8 ; 0x0714]
, # [doc = "0x8e8 - EDBGRQ Status Register"]
pub edbgrq : crate :: Reg < edbgrq :: EDBGRQ_SPEC > , # [doc = "0x8ec - MERESET Status Register"]
pub mereset : crate :: Reg < mereset :: MERESET_SPEC > , # [doc = "0x8f0 - WATCHDOG Status Register"]
pub watchdog : crate :: Reg < watchdog :: WATCHDOG_SPEC > , # [doc = "0x8f4 - RXEV Status Register"]
pub rxev : crate :: Reg < rxev :: RXEV_SPEC > , # [doc = "0x8f8 - NMI Status Register"]
pub nmi : crate :: Reg < nmi :: NMI_SPEC > , _reserved10 : [u8 ; 0x0700]
, # [doc = "0xffc - Peripheral ID Register"]
pub perid : crate :: Reg < perid :: PERID_SPEC > , } # [doc = "INT_RAM_SBE register accessor: an alias for `Reg<INT_RAM_SBE_SPEC>`"]
pub type INT_RAM_SBE = crate :: Reg < int_ram_sbe :: INT_RAM_SBE_SPEC > ; # [doc = "Internal Memory RAM SBE Interrupt Redirect Selection"]
pub mod int_ram_sbe { # [doc = "Register `INT_RAM_SBE` reader"]
pub struct R (crate :: R < INT_RAM_SBE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT_RAM_SBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT_RAM_SBE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT_RAM_SBE_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT_RAM_SBE` writer"]
pub struct W (crate :: W < INT_RAM_SBE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT_RAM_SBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT_RAM_SBE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT_RAM_SBE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Internal Memory RAM SBE Interrupt Redirect Selection\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int_ram_sbe](index.html) module"]
pub struct INT_RAM_SBE_SPEC ; impl crate :: RegisterSpec for INT_RAM_SBE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [int_ram_sbe::R](R) reader structure"]
impl crate :: Readable for INT_RAM_SBE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int_ram_sbe::W](W) writer structure"]
impl crate :: Writable for INT_RAM_SBE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INT_RAM_SBE to value 0xffff_ffff"]
impl crate :: Resettable for INT_RAM_SBE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xffff_ffff } } } # [doc = "INT_RAM_MBE register accessor: an alias for `Reg<INT_RAM_MBE_SPEC>`"]
pub type INT_RAM_MBE = crate :: Reg < int_ram_mbe :: INT_RAM_MBE_SPEC > ; # [doc = "Internal Memory RAM MBE Interrupt Redirect Selection"]
pub mod int_ram_mbe { # [doc = "Register `INT_RAM_MBE` reader"]
pub struct R (crate :: R < INT_RAM_MBE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT_RAM_MBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT_RAM_MBE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT_RAM_MBE_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT_RAM_MBE` writer"]
pub struct W (crate :: W < INT_RAM_MBE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT_RAM_MBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT_RAM_MBE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT_RAM_MBE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Internal Memory RAM MBE Interrupt Redirect Selection\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int_ram_mbe](index.html) module"]
pub struct INT_RAM_MBE_SPEC ; impl crate :: RegisterSpec for INT_RAM_MBE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [int_ram_mbe::R](R) reader structure"]
impl crate :: Readable for INT_RAM_MBE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int_ram_mbe::W](W) writer structure"]
impl crate :: Writable for INT_RAM_MBE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INT_RAM_MBE to value 0xffff_ffff"]
impl crate :: Resettable for INT_RAM_MBE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xffff_ffff } } } # [doc = "INT_ROM_SBE register accessor: an alias for `Reg<INT_ROM_SBE_SPEC>`"]
pub type INT_ROM_SBE = crate :: Reg < int_rom_sbe :: INT_ROM_SBE_SPEC > ; # [doc = "Internal Memory ROM SBE Interrupt Redirect Selection"]
pub mod int_rom_sbe { # [doc = "Register `INT_ROM_SBE` reader"]
pub struct R (crate :: R < INT_ROM_SBE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT_ROM_SBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT_ROM_SBE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT_ROM_SBE_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT_ROM_SBE` writer"]
pub struct W (crate :: W < INT_ROM_SBE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT_ROM_SBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT_ROM_SBE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT_ROM_SBE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Internal Memory ROM SBE Interrupt Redirect Selection\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int_rom_sbe](index.html) module"]
pub struct INT_ROM_SBE_SPEC ; impl crate :: RegisterSpec for INT_ROM_SBE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [int_rom_sbe::R](R) reader structure"]
impl crate :: Readable for INT_ROM_SBE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int_rom_sbe::W](W) writer structure"]
impl crate :: Writable for INT_ROM_SBE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INT_ROM_SBE to value 0xffff_ffff"]
impl crate :: Resettable for INT_ROM_SBE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xffff_ffff } } } # [doc = "INT_ROM_MBE register accessor: an alias for `Reg<INT_ROM_MBE_SPEC>`"]
pub type INT_ROM_MBE = crate :: Reg < int_rom_mbe :: INT_ROM_MBE_SPEC > ; # [doc = "Internal Memory ROM MBE Interrupt Redirect Selection"]
pub mod int_rom_mbe { # [doc = "Register `INT_ROM_MBE` reader"]
pub struct R (crate :: R < INT_ROM_MBE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT_ROM_MBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT_ROM_MBE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT_ROM_MBE_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT_ROM_MBE` writer"]
pub struct W (crate :: W < INT_ROM_MBE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT_ROM_MBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT_ROM_MBE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT_ROM_MBE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Internal Memory ROM MBE Interrupt Redirect Selection\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int_rom_mbe](index.html) module"]
pub struct INT_ROM_MBE_SPEC ; impl crate :: RegisterSpec for INT_ROM_MBE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [int_rom_mbe::R](R) reader structure"]
impl crate :: Readable for INT_ROM_MBE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int_rom_mbe::W](W) writer structure"]
impl crate :: Writable for INT_ROM_MBE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INT_ROM_MBE to value 0xffff_ffff"]
impl crate :: Resettable for INT_ROM_MBE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xffff_ffff } } } # [doc = "TXEV register accessor: an alias for `Reg<TXEV_SPEC>`"]
pub type TXEV = crate :: Reg < txev :: TXEV_SPEC > ; # [doc = "Processor TXEV Interrupt Redirect Selection"]
pub mod txev { # [doc = "Register `TXEV` reader"]
pub struct R (crate :: R < TXEV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXEV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXEV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXEV_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXEV` writer"]
pub struct W (crate :: W < TXEV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXEV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXEV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXEV_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Processor TXEV Interrupt Redirect Selection\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txev](index.html) module"]
pub struct TXEV_SPEC ; impl crate :: RegisterSpec for TXEV_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [txev::R](R) reader structure"]
impl crate :: Readable for TXEV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txev::W](W) writer structure"]
impl crate :: Writable for TXEV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TXEV to value 0xffff_ffff"]
impl crate :: Resettable for TXEV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xffff_ffff } } } # [doc = "NMI register accessor: an alias for `Reg<NMI_SPEC>`"]
pub type NMI = crate :: Reg < nmi :: NMI_SPEC > ; # [doc = "NMI Status Register"]
pub mod nmi { # [doc = "Register `NMI` reader"]
pub struct R (crate :: R < NMI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < NMI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < NMI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < NMI_SPEC >) -> Self { R (reader) } } # [doc = "Field `ACTIVE` reader - Active"]
pub struct ACTIVE_R (crate :: FieldReader < bool , bool >) ; impl ACTIVE_R { pub (crate) fn new (bits : bool) -> Self { ACTIVE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ACTIVE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - Active"]
# [inline (always)]
pub fn active (& self) -> ACTIVE_R { ACTIVE_R :: new ((self . bits & 0x01) != 0) } } # [doc = "NMI Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [nmi](index.html) module"]
pub struct NMI_SPEC ; impl crate :: RegisterSpec for NMI_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [nmi::R](R) reader structure"]
impl crate :: Readable for NMI_SPEC { type Reader = R ; } # [doc = "`reset()` method sets NMI to value 0"]
impl crate :: Resettable for NMI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RXEV register accessor: an alias for `Reg<RXEV_SPEC>`"]
pub type RXEV = crate :: Reg < rxev :: RXEV_SPEC > ; # [doc = "RXEV Status Register"]
pub mod rxev { # [doc = "Register `RXEV` reader"]
pub struct R (crate :: R < RXEV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXEV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXEV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXEV_SPEC >) -> Self { R (reader) } } # [doc = "Field `ACTIVE` reader - Active"]
pub struct ACTIVE_R (crate :: FieldReader < bool , bool >) ; impl ACTIVE_R { pub (crate) fn new (bits : bool) -> Self { ACTIVE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ACTIVE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - Active"]
# [inline (always)]
pub fn active (& self) -> ACTIVE_R { ACTIVE_R :: new ((self . bits & 0x01) != 0) } } # [doc = "RXEV Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxev](index.html) module"]
pub struct RXEV_SPEC ; impl crate :: RegisterSpec for RXEV_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rxev::R](R) reader structure"]
impl crate :: Readable for RXEV_SPEC { type Reader = R ; } # [doc = "`reset()` method sets RXEV to value 0"]
impl crate :: Resettable for RXEV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "WATCHDOG register accessor: an alias for `Reg<WATCHDOG_SPEC>`"]
pub type WATCHDOG = crate :: Reg < watchdog :: WATCHDOG_SPEC > ; # [doc = "WATCHDOG Status Register"]
pub mod watchdog { # [doc = "Register `WATCHDOG` reader"]
pub struct R (crate :: R < WATCHDOG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WATCHDOG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WATCHDOG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WATCHDOG_SPEC >) -> Self { R (reader) } } # [doc = "Field `ACTIVE` reader - Active"]
pub struct ACTIVE_R (crate :: FieldReader < bool , bool >) ; impl ACTIVE_R { pub (crate) fn new (bits : bool) -> Self { ACTIVE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ACTIVE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - Active"]
# [inline (always)]
pub fn active (& self) -> ACTIVE_R { ACTIVE_R :: new ((self . bits & 0x01) != 0) } } # [doc = "WATCHDOG Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [watchdog](index.html) module"]
pub struct WATCHDOG_SPEC ; impl crate :: RegisterSpec for WATCHDOG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [watchdog::R](R) reader structure"]
impl crate :: Readable for WATCHDOG_SPEC { type Reader = R ; } # [doc = "`reset()` method sets WATCHDOG to value 0"]
impl crate :: Resettable for WATCHDOG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "MERESET register accessor: an alias for `Reg<MERESET_SPEC>`"]
pub type MERESET = crate :: Reg < mereset :: MERESET_SPEC > ; # [doc = "MERESET Status Register"]
pub mod mereset { # [doc = "Register `MERESET` reader"]
pub struct R (crate :: R < MERESET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MERESET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MERESET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MERESET_SPEC >) -> Self { R (reader) } } # [doc = "Field `ACTIVE` reader - Active"]
pub struct ACTIVE_R (crate :: FieldReader < bool , bool >) ; impl ACTIVE_R { pub (crate) fn new (bits : bool) -> Self { ACTIVE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ACTIVE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - Active"]
# [inline (always)]
pub fn active (& self) -> ACTIVE_R { ACTIVE_R :: new ((self . bits & 0x01) != 0) } } # [doc = "MERESET Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mereset](index.html) module"]
pub struct MERESET_SPEC ; impl crate :: RegisterSpec for MERESET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [mereset::R](R) reader structure"]
impl crate :: Readable for MERESET_SPEC { type Reader = R ; } # [doc = "`reset()` method sets MERESET to value 0"]
impl crate :: Resettable for MERESET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EDBGRQ register accessor: an alias for `Reg<EDBGRQ_SPEC>`"]
pub type EDBGRQ = crate :: Reg < edbgrq :: EDBGRQ_SPEC > ; # [doc = "EDBGRQ Status Register"]
pub mod edbgrq { # [doc = "Register `EDBGRQ` reader"]
pub struct R (crate :: R < EDBGRQ_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EDBGRQ_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EDBGRQ_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EDBGRQ_SPEC >) -> Self { R (reader) } } # [doc = "Field `ACTIVE` reader - Active"]
pub struct ACTIVE_R (crate :: FieldReader < bool , bool >) ; impl ACTIVE_R { pub (crate) fn new (bits : bool) -> Self { ACTIVE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ACTIVE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - Active"]
# [inline (always)]
pub fn active (& self) -> ACTIVE_R { ACTIVE_R :: new ((self . bits & 0x01) != 0) } } # [doc = "EDBGRQ Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [edbgrq](index.html) module"]
pub struct EDBGRQ_SPEC ; impl crate :: RegisterSpec for EDBGRQ_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [edbgrq::R](R) reader structure"]
impl crate :: Readable for EDBGRQ_SPEC { type Reader = R ; } # [doc = "`reset()` method sets EDBGRQ to value 0"]
impl crate :: Resettable for EDBGRQ_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PERID register accessor: an alias for `Reg<PERID_SPEC>`"]
pub type PERID = crate :: Reg < perid :: PERID_SPEC > ; # [doc = "Peripheral ID Register"]
pub mod perid { # [doc = "Register `PERID` reader"]
pub struct R (crate :: R < PERID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERID_SPEC >) -> Self { R (reader) } } # [doc = "Peripheral ID Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perid](index.html) module"]
pub struct PERID_SPEC ; impl crate :: RegisterSpec for PERID_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [perid::R](R) reader structure"]
impl crate :: Readable for PERID_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PERID to value 0x0080_07e1"]
impl crate :: Resettable for PERID_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x0080_07e1 } } } } # [doc = "IO Pin Configuration Peripheral"]
pub struct IOCONFIG { _marker : PhantomData < * const () > } unsafe impl Send for IOCONFIG { } impl IOCONFIG { # [doc = r"Pointer to the register block"]
pub const PTR : * const ioconfig :: RegisterBlock = 0x4000_2000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ioconfig :: RegisterBlock { Self :: PTR } } impl Deref for IOCONFIG { type Target = ioconfig :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for IOCONFIG { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("IOCONFIG") . finish () } } # [doc = "IO Pin Configuration Peripheral"]
pub mod ioconfig { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00..0x80 - PORTA Pin Configuration Register"]
pub porta : [crate :: Reg < porta :: PORTA_SPEC > ; 32]
, # [doc = "0x80..0x100 - PORTB Pin Configuration Register"]
pub portb : [crate :: Reg < portb :: PORTB_SPEC > ; 32]
, _reserved2 : [u8 ; 0x0efc]
, # [doc = "0xffc - Peripheral ID Register"]
pub perid : crate :: Reg < perid :: PERID_SPEC > , } # [doc = "PORTA register accessor: an alias for `Reg<PORTA_SPEC>`"]
pub type PORTA = crate :: Reg < porta :: PORTA_SPEC > ; # [doc = "PORTA Pin Configuration Register"]
pub mod porta { # [doc = "Register `PORTA[%s]` reader"]
pub struct R (crate :: R < PORTA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTA_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTA[%s]` writer"]
pub struct W (crate :: W < PORTA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTA_SPEC >) -> Self { W (writer) } } # [doc = "Input Filter Selectoin\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum FLTTYPE_A { # [doc = "0: Synchronize to system clock"]
SYNC = 0 , # [doc = "1: Direct input, no synchronization"]
DIRECT = 1 , # [doc = "2: Require 2 samples to have the same value"]
FILTER1 = 2 , # [doc = "3: Require 3 samples to have the same value"]
FILTER2 = 3 , # [doc = "4: Require 4 samples to have the same value"]
FILTER3 = 4 , # [doc = "5: Require 5 samples to have the same value"]
FILTER4 = 5 , } impl From < FLTTYPE_A > for u8 { # [inline (always)]
fn from (variant : FLTTYPE_A) -> Self { variant as _ } } # [doc = "Field `FLTTYPE` reader - Input Filter Selectoin"]
pub struct FLTTYPE_R (crate :: FieldReader < u8 , FLTTYPE_A >) ; impl FLTTYPE_R { pub (crate) fn new (bits : u8) -> Self { FLTTYPE_R (crate :: FieldReader :: new (bits)) } # [doc = r"Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < FLTTYPE_A > { match self . bits { 0 => Some (FLTTYPE_A :: SYNC) , 1 => Some (FLTTYPE_A :: DIRECT) , 2 => Some (FLTTYPE_A :: FILTER1) , 3 => Some (FLTTYPE_A :: FILTER2) , 4 => Some (FLTTYPE_A :: FILTER3) , 5 => Some (FLTTYPE_A :: FILTER4) , _ => None , } } # [doc = "Checks if the value of the field is `SYNC`"]
# [inline (always)]
pub fn is_sync (& self) -> bool { * * self == FLTTYPE_A :: SYNC } # [doc = "Checks if the value of the field is `DIRECT`"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * * self == FLTTYPE_A :: DIRECT } # [doc = "Checks if the value of the field is `FILTER1`"]
# [inline (always)]
pub fn is_filter1 (& self) -> bool { * * self == FLTTYPE_A :: FILTER1 } # [doc = "Checks if the value of the field is `FILTER2`"]
# [inline (always)]
pub fn is_filter2 (& self) -> bool { * * self == FLTTYPE_A :: FILTER2 } # [doc = "Checks if the value of the field is `FILTER3`"]
# [inline (always)]
pub fn is_filter3 (& self) -> bool { * * self == FLTTYPE_A :: FILTER3 } # [doc = "Checks if the value of the field is `FILTER4`"]
# [inline (always)]
pub fn is_filter4 (& self) -> bool { * * self == FLTTYPE_A :: FILTER4 } } impl core :: ops :: Deref for FLTTYPE_R { type Target = crate :: FieldReader < u8 , FLTTYPE_A > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `FLTTYPE` writer - Input Filter Selectoin"]
pub struct FLTTYPE_W < 'a > { w : & 'a mut W , } impl < 'a > FLTTYPE_W < 'a > { # [doc = r"Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FLTTYPE_A) -> & 'a mut W { unsafe { self . bits (variant . into ()) } } # [doc = "Synchronize to system clock"]
# [inline (always)]
pub fn sync (self) -> & 'a mut W { self . variant (FLTTYPE_A :: SYNC) } # [doc = "Direct input, no synchronization"]
# [inline (always)]
pub fn direct (self) -> & 'a mut W { self . variant (FLTTYPE_A :: DIRECT) } # [doc = "Require 2 samples to have the same value"]
# [inline (always)]
pub fn filter1 (self) -> & 'a mut W { self . variant (FLTTYPE_A :: FILTER1) } # [doc = "Require 3 samples to have the same value"]
# [inline (always)]
pub fn filter2 (self) -> & 'a mut W { self . variant (FLTTYPE_A :: FILTER2) } # [doc = "Require 4 samples to have the same value"]
# [inline (always)]
pub fn filter3 (self) -> & 'a mut W { self . variant (FLTTYPE_A :: FILTER3) } # [doc = "Require 5 samples to have the same value"]
# [inline (always)]
pub fn filter4 (self) -> & 'a mut W { self . variant (FLTTYPE_A :: FILTER4) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x07) | (value as u32 & 0x07) ; self . w } } # [doc = "Field `FLTCLK` reader - Input Filter Clock Selection"]
pub struct FLTCLK_R (crate :: FieldReader < u8 , u8 >) ; impl FLTCLK_R { pub (crate) fn new (bits : u8) -> Self { FLTCLK_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for FLTCLK_R { type Target = crate :: FieldReader < u8 , u8 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `FLTCLK` writer - Input Filter Clock Selection"]
pub struct FLTCLK_W < 'a > { w : & 'a mut W , } impl < 'a > FLTCLK_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x07 << 3)) | ((value as u32 & 0x07) << 3) ; self . w } } # [doc = "Field `INVINP` reader - Input Invert Selection"]
pub struct INVINP_R (crate :: FieldReader < bool , bool >) ; impl INVINP_R { pub (crate) fn new (bits : bool) -> Self { INVINP_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for INVINP_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `INVINP` writer - Input Invert Selection"]
pub struct INVINP_W < 'a > { w : & 'a mut W , } impl < 'a > INVINP_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | ((value as u32 & 0x01) << 6) ; self . w } } # [doc = "Field `IEWO` reader - Input Enable While Output enabled"]
pub struct IEWO_R (crate :: FieldReader < bool , bool >) ; impl IEWO_R { pub (crate) fn new (bits : bool) -> Self { IEWO_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IEWO_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IEWO` writer - Input Enable While Output enabled"]
pub struct IEWO_W < 'a > { w : & 'a mut W , } impl < 'a > IEWO_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | ((value as u32 & 0x01) << 7) ; self . w } } # [doc = "Field `OPENDRN` reader - Output Open Drain Mode"]
pub struct OPENDRN_R (crate :: FieldReader < bool , bool >) ; impl OPENDRN_R { pub (crate) fn new (bits : bool) -> Self { OPENDRN_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for OPENDRN_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `OPENDRN` writer - Output Open Drain Mode"]
pub struct OPENDRN_W < 'a > { w : & 'a mut W , } impl < 'a > OPENDRN_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 8)) | ((value as u32 & 0x01) << 8) ; self . w } } # [doc = "Field `INVOUT` reader - Output Invert Selection"]
pub struct INVOUT_R (crate :: FieldReader < bool , bool >) ; impl INVOUT_R { pub (crate) fn new (bits : bool) -> Self { INVOUT_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for INVOUT_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `INVOUT` writer - Output Invert Selection"]
pub struct INVOUT_W < 'a > { w : & 'a mut W , } impl < 'a > INVOUT_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 9)) | ((value as u32 & 0x01) << 9) ; self . w } } # [doc = "Field `PLEVEL` reader - Internal Pull up/down level"]
pub struct PLEVEL_R (crate :: FieldReader < bool , bool >) ; impl PLEVEL_R { pub (crate) fn new (bits : bool) -> Self { PLEVEL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for PLEVEL_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `PLEVEL` writer - Internal Pull up/down level"]
pub struct PLEVEL_W < 'a > { w : & 'a mut W , } impl < 'a > PLEVEL_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 10)) | ((value as u32 & 0x01) << 10) ; self . w } } # [doc = "Field `PEN` reader - Enable Internal Pull up/down"]
pub struct PEN_R (crate :: FieldReader < bool , bool >) ; impl PEN_R { pub (crate) fn new (bits : bool) -> Self { PEN_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for PEN_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `PEN` writer - Enable Internal Pull up/down"]
pub struct PEN_W < 'a > { w : & 'a mut W , } impl < 'a > PEN_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 11)) | ((value as u32 & 0x01) << 11) ; self . w } } # [doc = "Field `PWOA` reader - Enable Pull when output active"]
pub struct PWOA_R (crate :: FieldReader < bool , bool >) ; impl PWOA_R { pub (crate) fn new (bits : bool) -> Self { PWOA_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for PWOA_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `PWOA` writer - Enable Pull when output active"]
pub struct PWOA_W < 'a > { w : & 'a mut W , } impl < 'a > PWOA_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 12)) | ((value as u32 & 0x01) << 12) ; self . w } } # [doc = "Field `FUNSEL` reader - Pin Function Selection"]
pub struct FUNSEL_R (crate :: FieldReader < u8 , u8 >) ; impl FUNSEL_R { pub (crate) fn new (bits : u8) -> Self { FUNSEL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for FUNSEL_R { type Target = crate :: FieldReader < u8 , u8 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `FUNSEL` writer - Pin Function Selection"]
pub struct FUNSEL_W < 'a > { w : & 'a mut W , } impl < 'a > FUNSEL_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x07 << 13)) | ((value as u32 & 0x07) << 13) ; self . w } } # [doc = "Field `IODIS` reader - IO Pin Disable"]
pub struct IODIS_R (crate :: FieldReader < bool , bool >) ; impl IODIS_R { pub (crate) fn new (bits : bool) -> Self { IODIS_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IODIS_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IODIS` writer - IO Pin Disable"]
pub struct IODIS_W < 'a > { w : & 'a mut W , } impl < 'a > IODIS_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 16)) | ((value as u32 & 0x01) << 16) ; self . w } } impl R { # [doc = "Bits 0:2 - Input Filter Selectoin"]
# [inline (always)]
pub fn flttype (& self) -> FLTTYPE_R { FLTTYPE_R :: new ((self . bits & 0x07) as u8) } # [doc = "Bits 3:5 - Input Filter Clock Selection"]
# [inline (always)]
pub fn fltclk (& self) -> FLTCLK_R { FLTCLK_R :: new (((self . bits >> 3) & 0x07) as u8) } # [doc = "Bit 6 - Input Invert Selection"]
# [inline (always)]
pub fn invinp (& self) -> INVINP_R { INVINP_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - Input Enable While Output enabled"]
# [inline (always)]
pub fn iewo (& self) -> IEWO_R { IEWO_R :: new (((self . bits >> 7) & 0x01) != 0) } # [doc = "Bit 8 - Output Open Drain Mode"]
# [inline (always)]
pub fn opendrn (& self) -> OPENDRN_R { OPENDRN_R :: new (((self . bits >> 8) & 0x01) != 0) } # [doc = "Bit 9 - Output Invert Selection"]
# [inline (always)]
pub fn invout (& self) -> INVOUT_R { INVOUT_R :: new (((self . bits >> 9) & 0x01) != 0) } # [doc = "Bit 10 - Internal Pull up/down level"]
# [inline (always)]
pub fn plevel (& self) -> PLEVEL_R { PLEVEL_R :: new (((self . bits >> 10) & 0x01) != 0) } # [doc = "Bit 11 - Enable Internal Pull up/down"]
# [inline (always)]
pub fn pen (& self) -> PEN_R { PEN_R :: new (((self . bits >> 11) & 0x01) != 0) } # [doc = "Bit 12 - Enable Pull when output active"]
# [inline (always)]
pub fn pwoa (& self) -> PWOA_R { PWOA_R :: new (((self . bits >> 12) & 0x01) != 0) } # [doc = "Bits 13:15 - Pin Function Selection"]
# [inline (always)]
pub fn funsel (& self) -> FUNSEL_R { FUNSEL_R :: new (((self . bits >> 13) & 0x07) as u8) } # [doc = "Bit 16 - IO Pin Disable"]
# [inline (always)]
pub fn iodis (& self) -> IODIS_R { IODIS_R :: new (((self . bits >> 16) & 0x01) != 0) } } impl W { # [doc = "Bits 0:2 - Input Filter Selectoin"]
# [inline (always)]
pub fn flttype (& mut self) -> FLTTYPE_W { FLTTYPE_W { w : self } } # [doc = "Bits 3:5 - Input Filter Clock Selection"]
# [inline (always)]
pub fn fltclk (& mut self) -> FLTCLK_W { FLTCLK_W { w : self } } # [doc = "Bit 6 - Input Invert Selection"]
# [inline (always)]
pub fn invinp (& mut self) -> INVINP_W { INVINP_W { w : self } } # [doc = "Bit 7 - Input Enable While Output enabled"]
# [inline (always)]
pub fn iewo (& mut self) -> IEWO_W { IEWO_W { w : self } } # [doc = "Bit 8 - Output Open Drain Mode"]
# [inline (always)]
pub fn opendrn (& mut self) -> OPENDRN_W { OPENDRN_W { w : self } } # [doc = "Bit 9 - Output Invert Selection"]
# [inline (always)]
pub fn invout (& mut self) -> INVOUT_W { INVOUT_W { w : self } } # [doc = "Bit 10 - Internal Pull up/down level"]
# [inline (always)]
pub fn plevel (& mut self) -> PLEVEL_W { PLEVEL_W { w : self } } # [doc = "Bit 11 - Enable Internal Pull up/down"]
# [inline (always)]
pub fn pen (& mut self) -> PEN_W { PEN_W { w : self } } # [doc = "Bit 12 - Enable Pull when output active"]
# [inline (always)]
pub fn pwoa (& mut self) -> PWOA_W { PWOA_W { w : self } } # [doc = "Bits 13:15 - Pin Function Selection"]
# [inline (always)]
pub fn funsel (& mut self) -> FUNSEL_W { FUNSEL_W { w : self } } # [doc = "Bit 16 - IO Pin Disable"]
# [inline (always)]
pub fn iodis (& mut self) -> IODIS_W { IODIS_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "PORTA Pin Configuration Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [porta](index.html) module"]
pub struct PORTA_SPEC ; impl crate :: RegisterSpec for PORTA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [porta::R](R) reader structure"]
impl crate :: Readable for PORTA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [porta::W](W) writer structure"]
impl crate :: Writable for PORTA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PORTA[%s]
to value 0"]
impl crate :: Resettable for PORTA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PORTB register accessor: an alias for `Reg<PORTB_SPEC>`"]
pub type PORTB = crate :: Reg < portb :: PORTB_SPEC > ; # [doc = "PORTB Pin Configuration Register"]
pub mod portb { # [doc = "Register `PORTB[%s]` reader"]
pub struct R (crate :: R < PORTB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTB_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTB[%s]` writer"]
pub struct W (crate :: W < PORTB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTB_SPEC >) -> Self { W (writer) } } # [doc = "Input Filter Selectoin\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum FLTTYPE_A { # [doc = "0: Synchronize to system clock"]
SYNC = 0 , # [doc = "1: Direct input, no synchronization"]
DIRECT = 1 , # [doc = "2: Require 2 samples to have the same value"]
FILTER1 = 2 , # [doc = "3: Require 3 samples to have the same value"]
FILTER2 = 3 , # [doc = "4: Require 4 samples to have the same value"]
FILTER3 = 4 , # [doc = "5: Require 5 samples to have the same value"]
FILTER4 = 5 , } impl From < FLTTYPE_A > for u8 { # [inline (always)]
fn from (variant : FLTTYPE_A) -> Self { variant as _ } } # [doc = "Field `FLTTYPE` reader - Input Filter Selectoin"]
pub struct FLTTYPE_R (crate :: FieldReader < u8 , FLTTYPE_A >) ; impl FLTTYPE_R { pub (crate) fn new (bits : u8) -> Self { FLTTYPE_R (crate :: FieldReader :: new (bits)) } # [doc = r"Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < FLTTYPE_A > { match self . bits { 0 => Some (FLTTYPE_A :: SYNC) , 1 => Some (FLTTYPE_A :: DIRECT) , 2 => Some (FLTTYPE_A :: FILTER1) , 3 => Some (FLTTYPE_A :: FILTER2) , 4 => Some (FLTTYPE_A :: FILTER3) , 5 => Some (FLTTYPE_A :: FILTER4) , _ => None , } } # [doc = "Checks if the value of the field is `SYNC`"]
# [inline (always)]
pub fn is_sync (& self) -> bool { * * self == FLTTYPE_A :: SYNC } # [doc = "Checks if the value of the field is `DIRECT`"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * * self == FLTTYPE_A :: DIRECT } # [doc = "Checks if the value of the field is `FILTER1`"]
# [inline (always)]
pub fn is_filter1 (& self) -> bool { * * self == FLTTYPE_A :: FILTER1 } # [doc = "Checks if the value of the field is `FILTER2`"]
# [inline (always)]
pub fn is_filter2 (& self) -> bool { * * self == FLTTYPE_A :: FILTER2 } # [doc = "Checks if the value of the field is `FILTER3`"]
# [inline (always)]
pub fn is_filter3 (& self) -> bool { * * self == FLTTYPE_A :: FILTER3 } # [doc = "Checks if the value of the field is `FILTER4`"]
# [inline (always)]
pub fn is_filter4 (& self) -> bool { * * self == FLTTYPE_A :: FILTER4 } } impl core :: ops :: Deref for FLTTYPE_R { type Target = crate :: FieldReader < u8 , FLTTYPE_A > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `FLTTYPE` writer - Input Filter Selectoin"]
pub struct FLTTYPE_W < 'a > { w : & 'a mut W , } impl < 'a > FLTTYPE_W < 'a > { # [doc = r"Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FLTTYPE_A) -> & 'a mut W { unsafe { self . bits (variant . into ()) } } # [doc = "Synchronize to system clock"]
# [inline (always)]
pub fn sync (self) -> & 'a mut W { self . variant (FLTTYPE_A :: SYNC) } # [doc = "Direct input, no synchronization"]
# [inline (always)]
pub fn direct (self) -> & 'a mut W { self . variant (FLTTYPE_A :: DIRECT) } # [doc = "Require 2 samples to have the same value"]
# [inline (always)]
pub fn filter1 (self) -> & 'a mut W { self . variant (FLTTYPE_A :: FILTER1) } # [doc = "Require 3 samples to have the same value"]
# [inline (always)]
pub fn filter2 (self) -> & 'a mut W { self . variant (FLTTYPE_A :: FILTER2) } # [doc = "Require 4 samples to have the same value"]
# [inline (always)]
pub fn filter3 (self) -> & 'a mut W { self . variant (FLTTYPE_A :: FILTER3) } # [doc = "Require 5 samples to have the same value"]
# [inline (always)]
pub fn filter4 (self) -> & 'a mut W { self . variant (FLTTYPE_A :: FILTER4) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x07) | (value as u32 & 0x07) ; self . w } } # [doc = "Field `FLTCLK` reader - Input Filter Clock Selection"]
pub struct FLTCLK_R (crate :: FieldReader < u8 , u8 >) ; impl FLTCLK_R { pub (crate) fn new (bits : u8) -> Self { FLTCLK_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for FLTCLK_R { type Target = crate :: FieldReader < u8 , u8 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `FLTCLK` writer - Input Filter Clock Selection"]
pub struct FLTCLK_W < 'a > { w : & 'a mut W , } impl < 'a > FLTCLK_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x07 << 3)) | ((value as u32 & 0x07) << 3) ; self . w } } # [doc = "Field `INVINP` reader - Input Invert Selection"]
pub struct INVINP_R (crate :: FieldReader < bool , bool >) ; impl INVINP_R { pub (crate) fn new (bits : bool) -> Self { INVINP_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for INVINP_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `INVINP` writer - Input Invert Selection"]
pub struct INVINP_W < 'a > { w : & 'a mut W , } impl < 'a > INVINP_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | ((value as u32 & 0x01) << 6) ; self . w } } # [doc = "Field `IEWO` reader - Input Enable While Output enabled"]
pub struct IEWO_R (crate :: FieldReader < bool , bool >) ; impl IEWO_R { pub (crate) fn new (bits : bool) -> Self { IEWO_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IEWO_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IEWO` writer - Input Enable While Output enabled"]
pub struct IEWO_W < 'a > { w : & 'a mut W , } impl < 'a > IEWO_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | ((value as u32 & 0x01) << 7) ; self . w } } # [doc = "Field `OPENDRN` reader - Output Open Drain Mode"]
pub struct OPENDRN_R (crate :: FieldReader < bool , bool >) ; impl OPENDRN_R { pub (crate) fn new (bits : bool) -> Self { OPENDRN_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for OPENDRN_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `OPENDRN` writer - Output Open Drain Mode"]
pub struct OPENDRN_W < 'a > { w : & 'a mut W , } impl < 'a > OPENDRN_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 8)) | ((value as u32 & 0x01) << 8) ; self . w } } # [doc = "Field `INVOUT` reader - Output Invert Selection"]
pub struct INVOUT_R (crate :: FieldReader < bool , bool >) ; impl INVOUT_R { pub (crate) fn new (bits : bool) -> Self { INVOUT_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for INVOUT_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `INVOUT` writer - Output Invert Selection"]
pub struct INVOUT_W < 'a > { w : & 'a mut W , } impl < 'a > INVOUT_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 9)) | ((value as u32 & 0x01) << 9) ; self . w } } # [doc = "Field `PLEVEL` reader - Internal Pull up/down level"]
pub struct PLEVEL_R (crate :: FieldReader < bool , bool >) ; impl PLEVEL_R { pub (crate) fn new (bits : bool) -> Self { PLEVEL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for PLEVEL_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `PLEVEL` writer - Internal Pull up/down level"]
pub struct PLEVEL_W < 'a > { w : & 'a mut W , } impl < 'a > PLEVEL_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 10)) | ((value as u32 & 0x01) << 10) ; self . w } } # [doc = "Field `PEN` reader - Enable Internal Pull up/down"]
pub struct PEN_R (crate :: FieldReader < bool , bool >) ; impl PEN_R { pub (crate) fn new (bits : bool) -> Self { PEN_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for PEN_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `PEN` writer - Enable Internal Pull up/down"]
pub struct PEN_W < 'a > { w : & 'a mut W , } impl < 'a > PEN_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 11)) | ((value as u32 & 0x01) << 11) ; self . w } } # [doc = "Field `PWOA` reader - Enable Pull when output active"]
pub struct PWOA_R (crate :: FieldReader < bool , bool >) ; impl PWOA_R { pub (crate) fn new (bits : bool) -> Self { PWOA_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for PWOA_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `PWOA` writer - Enable Pull when output active"]
pub struct PWOA_W < 'a > { w : & 'a mut W , } impl < 'a > PWOA_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 12)) | ((value as u32 & 0x01) << 12) ; self . w } } # [doc = "Field `FUNSEL` reader - Pin Function Selection"]
pub struct FUNSEL_R (crate :: FieldReader < u8 , u8 >) ; impl FUNSEL_R { pub (crate) fn new (bits : u8) -> Self { FUNSEL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for FUNSEL_R { type Target = crate :: FieldReader < u8 , u8 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `FUNSEL` writer - Pin Function Selection"]
pub struct FUNSEL_W < 'a > { w : & 'a mut W , } impl < 'a > FUNSEL_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x07 << 13)) | ((value as u32 & 0x07) << 13) ; self . w } } # [doc = "Field `IODIS` reader - IO Pin Disable"]
pub struct IODIS_R (crate :: FieldReader < bool , bool >) ; impl IODIS_R { pub (crate) fn new (bits : bool) -> Self { IODIS_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IODIS_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IODIS` writer - IO Pin Disable"]
pub struct IODIS_W < 'a > { w : & 'a mut W , } impl < 'a > IODIS_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 16)) | ((value as u32 & 0x01) << 16) ; self . w } } impl R { # [doc = "Bits 0:2 - Input Filter Selectoin"]
# [inline (always)]
pub fn flttype (& self) -> FLTTYPE_R { FLTTYPE_R :: new ((self . bits & 0x07) as u8) } # [doc = "Bits 3:5 - Input Filter Clock Selection"]
# [inline (always)]
pub fn fltclk (& self) -> FLTCLK_R { FLTCLK_R :: new (((self . bits >> 3) & 0x07) as u8) } # [doc = "Bit 6 - Input Invert Selection"]
# [inline (always)]
pub fn invinp (& self) -> INVINP_R { INVINP_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - Input Enable While Output enabled"]
# [inline (always)]
pub fn iewo (& self) -> IEWO_R { IEWO_R :: new (((self . bits >> 7) & 0x01) != 0) } # [doc = "Bit 8 - Output Open Drain Mode"]
# [inline (always)]
pub fn opendrn (& self) -> OPENDRN_R { OPENDRN_R :: new (((self . bits >> 8) & 0x01) != 0) } # [doc = "Bit 9 - Output Invert Selection"]
# [inline (always)]
pub fn invout (& self) -> INVOUT_R { INVOUT_R :: new (((self . bits >> 9) & 0x01) != 0) } # [doc = "Bit 10 - Internal Pull up/down level"]
# [inline (always)]
pub fn plevel (& self) -> PLEVEL_R { PLEVEL_R :: new (((self . bits >> 10) & 0x01) != 0) } # [doc = "Bit 11 - Enable Internal Pull up/down"]
# [inline (always)]
pub fn pen (& self) -> PEN_R { PEN_R :: new (((self . bits >> 11) & 0x01) != 0) } # [doc = "Bit 12 - Enable Pull when output active"]
# [inline (always)]
pub fn pwoa (& self) -> PWOA_R { PWOA_R :: new (((self . bits >> 12) & 0x01) != 0) } # [doc = "Bits 13:15 - Pin Function Selection"]
# [inline (always)]
pub fn funsel (& self) -> FUNSEL_R { FUNSEL_R :: new (((self . bits >> 13) & 0x07) as u8) } # [doc = "Bit 16 - IO Pin Disable"]
# [inline (always)]
pub fn iodis (& self) -> IODIS_R { IODIS_R :: new (((self . bits >> 16) & 0x01) != 0) } } impl W { # [doc = "Bits 0:2 - Input Filter Selectoin"]
# [inline (always)]
pub fn flttype (& mut self) -> FLTTYPE_W { FLTTYPE_W { w : self } } # [doc = "Bits 3:5 - Input Filter Clock Selection"]
# [inline (always)]
pub fn fltclk (& mut self) -> FLTCLK_W { FLTCLK_W { w : self } } # [doc = "Bit 6 - Input Invert Selection"]
# [inline (always)]
pub fn invinp (& mut self) -> INVINP_W { INVINP_W { w : self } } # [doc = "Bit 7 - Input Enable While Output enabled"]
# [inline (always)]
pub fn iewo (& mut self) -> IEWO_W { IEWO_W { w : self } } # [doc = "Bit 8 - Output Open Drain Mode"]
# [inline (always)]
pub fn opendrn (& mut self) -> OPENDRN_W { OPENDRN_W { w : self } } # [doc = "Bit 9 - Output Invert Selection"]
# [inline (always)]
pub fn invout (& mut self) -> INVOUT_W { INVOUT_W { w : self } } # [doc = "Bit 10 - Internal Pull up/down level"]
# [inline (always)]
pub fn plevel (& mut self) -> PLEVEL_W { PLEVEL_W { w : self } } # [doc = "Bit 11 - Enable Internal Pull up/down"]
# [inline (always)]
pub fn pen (& mut self) -> PEN_W { PEN_W { w : self } } # [doc = "Bit 12 - Enable Pull when output active"]
# [inline (always)]
pub fn pwoa (& mut self) -> PWOA_W { PWOA_W { w : self } } # [doc = "Bits 13:15 - Pin Function Selection"]
# [inline (always)]
pub fn funsel (& mut self) -> FUNSEL_W { FUNSEL_W { w : self } } # [doc = "Bit 16 - IO Pin Disable"]
# [inline (always)]
pub fn iodis (& mut self) -> IODIS_W { IODIS_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "PORTB Pin Configuration Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [portb](index.html) module"]
pub struct PORTB_SPEC ; impl crate :: RegisterSpec for PORTB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [portb::R](R) reader structure"]
impl crate :: Readable for PORTB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [portb::W](W) writer structure"]
impl crate :: Writable for PORTB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PORTB[%s]
to value 0x0800"]
impl crate :: Resettable for PORTB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x0800 } } } # [doc = "PERID register accessor: an alias for `Reg<PERID_SPEC>`"]
pub type PERID = crate :: Reg < perid :: PERID_SPEC > ; # [doc = "Peripheral ID Register"]
pub mod perid { # [doc = "Register `PERID` reader"]
pub struct R (crate :: R < PERID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERID_SPEC >) -> Self { R (reader) } } # [doc = "Peripheral ID Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perid](index.html) module"]
pub struct PERID_SPEC ; impl crate :: RegisterSpec for PERID_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [perid::R](R) reader structure"]
impl crate :: Readable for PERID_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PERID to value 0x0082_07e1"]
impl crate :: Resettable for PERID_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x0082_07e1 } } } } # [doc = "Utility Peripheral"]
pub struct UTILITY { _marker : PhantomData < * const () > } unsafe impl Send for UTILITY { } impl UTILITY { # [doc = r"Pointer to the register block"]
pub const PTR : * const utility :: RegisterBlock = 0x4000_3000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const utility :: RegisterBlock { Self :: PTR } } impl Deref for UTILITY { type Target = utility :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for UTILITY { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("UTILITY") . finish () } } # [doc = "Utility Peripheral"]
pub mod utility { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Synd Data 0 Register"]
pub synd_data0 : crate :: Reg < synd_data0 :: SYND_DATA0_SPEC > , # [doc = "0x04 - Synd Data 1 Register"]
pub synd_data1 : crate :: Reg < synd_data1 :: SYND_DATA1_SPEC > , # [doc = "0x08 - Synd Parity Register"]
pub synd_synd : crate :: Reg < synd_synd :: SYND_SYND_SPEC > , # [doc = "0x0c - Synd 32 bit Encoded Syndrome"]
pub synd_enc_32 : crate :: Reg < synd_enc_32 :: SYND_ENC_32_SPEC > , # [doc = "0x10 - Synd 32 bit Corrected Data"]
pub synd_check_32_data : crate :: Reg < synd_check_32_data :: SYND_CHECK_32_DATA_SPEC > , # [doc = "0x14 - Synd 32 bit Corrected Syndrome and Status"]
pub synd_check_32_synd : crate :: Reg < synd_check_32_synd :: SYND_CHECK_32_SYND_SPEC > , # [doc = "0x18 - Synd 64 bit Encoded Syndrome"]
pub synd_enc_64 : crate :: Reg < synd_enc_64 :: SYND_ENC_64_SPEC > , # [doc = "0x1c - Synd 64 bit Corrected Data 0"]
pub synd_check_64_data0 : crate :: Reg < synd_check_64_data0 :: SYND_CHECK_64_DATA0_SPEC > , # [doc = "0x20 - Synd 64 bit Corrected Data 1"]
pub synd_check_64_data1 : crate :: Reg < synd_check_64_data1 :: SYND_CHECK_64_DATA1_SPEC > , # [doc = "0x24 - Synd 64 bit Corrected Parity and Status"]
pub synd_check_64_synd : crate :: Reg < synd_check_64_synd :: SYND_CHECK_64_SYND_SPEC > , # [doc = "0x28 - Synd 32/52 bit Encoded Syndrome"]
pub synd_enc_32_52 : crate :: Reg < synd_enc_32_52 :: SYND_ENC_32_52_SPEC > , # [doc = "0x2c - Synd 32/52 bit Corrected Data"]
pub synd_check_32_52_data : crate :: Reg < synd_check_32_52_data :: SYND_CHECK_32_52_DATA_SPEC > , # [doc = "0x30 - Synd 32/52 bit Corrected Syndrome and Status"]
pub synd_check_32_52_synd : crate :: Reg < synd_check_32_52_synd :: SYND_CHECK_32_52_SYND_SPEC > , _reserved13 : [u8 ; 0x0fc8]
, # [doc = "0xffc - Peripheral ID Register"]
pub perid : crate :: Reg < perid :: PERID_SPEC > , } # [doc = "SYND_DATA0 register accessor: an alias for `Reg<SYND_DATA0_SPEC>`"]
pub type SYND_DATA0 = crate :: Reg < synd_data0 :: SYND_DATA0_SPEC > ; # [doc = "Synd Data 0 Register"]
pub mod synd_data0 { # [doc = "Register `SYND_DATA0` reader"]
pub struct R (crate :: R < SYND_DATA0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYND_DATA0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYND_DATA0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYND_DATA0_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYND_DATA0` writer"]
pub struct W (crate :: W < SYND_DATA0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYND_DATA0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYND_DATA0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYND_DATA0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Synd Data 0 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [synd_data0](index.html) module"]
pub struct SYND_DATA0_SPEC ; impl crate :: RegisterSpec for SYND_DATA0_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [synd_data0::R](R) reader structure"]
impl crate :: Readable for SYND_DATA0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [synd_data0::W](W) writer structure"]
impl crate :: Writable for SYND_DATA0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SYND_DATA0 to value 0"]
impl crate :: Resettable for SYND_DATA0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYND_DATA1 register accessor: an alias for `Reg<SYND_DATA1_SPEC>`"]
pub type SYND_DATA1 = crate :: Reg < synd_data1 :: SYND_DATA1_SPEC > ; # [doc = "Synd Data 1 Register"]
pub mod synd_data1 { # [doc = "Register `SYND_DATA1` reader"]
pub struct R (crate :: R < SYND_DATA1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYND_DATA1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYND_DATA1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYND_DATA1_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYND_DATA1` writer"]
pub struct W (crate :: W < SYND_DATA1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYND_DATA1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYND_DATA1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYND_DATA1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Synd Data 1 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [synd_data1](index.html) module"]
pub struct SYND_DATA1_SPEC ; impl crate :: RegisterSpec for SYND_DATA1_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [synd_data1::R](R) reader structure"]
impl crate :: Readable for SYND_DATA1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [synd_data1::W](W) writer structure"]
impl crate :: Writable for SYND_DATA1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SYND_DATA1 to value 0"]
impl crate :: Resettable for SYND_DATA1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYND_SYND register accessor: an alias for `Reg<SYND_SYND_SPEC>`"]
pub type SYND_SYND = crate :: Reg < synd_synd :: SYND_SYND_SPEC > ; # [doc = "Synd Parity Register"]
pub mod synd_synd { # [doc = "Register `SYND_SYND` reader"]
pub struct R (crate :: R < SYND_SYND_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYND_SYND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYND_SYND_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYND_SYND_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYND_SYND` writer"]
pub struct W (crate :: W < SYND_SYND_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYND_SYND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYND_SYND_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYND_SYND_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Synd Parity Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [synd_synd](index.html) module"]
pub struct SYND_SYND_SPEC ; impl crate :: RegisterSpec for SYND_SYND_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [synd_synd::R](R) reader structure"]
impl crate :: Readable for SYND_SYND_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [synd_synd::W](W) writer structure"]
impl crate :: Writable for SYND_SYND_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SYND_SYND to value 0"]
impl crate :: Resettable for SYND_SYND_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYND_ENC_32 register accessor: an alias for `Reg<SYND_ENC_32_SPEC>`"]
pub type SYND_ENC_32 = crate :: Reg < synd_enc_32 :: SYND_ENC_32_SPEC > ; # [doc = "Synd 32 bit Encoded Syndrome"]
pub mod synd_enc_32 { # [doc = "Register `SYND_ENC_32` reader"]
pub struct R (crate :: R < SYND_ENC_32_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYND_ENC_32_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYND_ENC_32_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYND_ENC_32_SPEC >) -> Self { R (reader) } } # [doc = "Synd 32 bit Encoded Syndrome\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [synd_enc_32](index.html) module"]
pub struct SYND_ENC_32_SPEC ; impl crate :: RegisterSpec for SYND_ENC_32_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [synd_enc_32::R](R) reader structure"]
impl crate :: Readable for SYND_ENC_32_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYND_ENC_32 to value 0"]
impl crate :: Resettable for SYND_ENC_32_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYND_CHECK_32_DATA register accessor: an alias for `Reg<SYND_CHECK_32_DATA_SPEC>`"]
pub type SYND_CHECK_32_DATA = crate :: Reg < synd_check_32_data :: SYND_CHECK_32_DATA_SPEC > ; # [doc = "Synd 32 bit Corrected Data"]
pub mod synd_check_32_data { # [doc = "Register `SYND_CHECK_32_DATA` reader"]
pub struct R (crate :: R < SYND_CHECK_32_DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYND_CHECK_32_DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYND_CHECK_32_DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYND_CHECK_32_DATA_SPEC >) -> Self { R (reader) } } # [doc = "Synd 32 bit Corrected Data\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [synd_check_32_data](index.html) module"]
pub struct SYND_CHECK_32_DATA_SPEC ; impl crate :: RegisterSpec for SYND_CHECK_32_DATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [synd_check_32_data::R](R) reader structure"]
impl crate :: Readable for SYND_CHECK_32_DATA_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYND_CHECK_32_DATA to value 0"]
impl crate :: Resettable for SYND_CHECK_32_DATA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYND_CHECK_32_SYND register accessor: an alias for `Reg<SYND_CHECK_32_SYND_SPEC>`"]
pub type SYND_CHECK_32_SYND = crate :: Reg < synd_check_32_synd :: SYND_CHECK_32_SYND_SPEC > ; # [doc = "Synd 32 bit Corrected Syndrome and Status"]
pub mod synd_check_32_synd { # [doc = "Register `SYND_CHECK_32_SYND` reader"]
pub struct R (crate :: R < SYND_CHECK_32_SYND_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYND_CHECK_32_SYND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYND_CHECK_32_SYND_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYND_CHECK_32_SYND_SPEC >) -> Self { R (reader) } } # [doc = "Synd 32 bit Corrected Syndrome and Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [synd_check_32_synd](index.html) module"]
pub struct SYND_CHECK_32_SYND_SPEC ; impl crate :: RegisterSpec for SYND_CHECK_32_SYND_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [synd_check_32_synd::R](R) reader structure"]
impl crate :: Readable for SYND_CHECK_32_SYND_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYND_CHECK_32_SYND to value 0"]
impl crate :: Resettable for SYND_CHECK_32_SYND_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYND_ENC_64 register accessor: an alias for `Reg<SYND_ENC_64_SPEC>`"]
pub type SYND_ENC_64 = crate :: Reg < synd_enc_64 :: SYND_ENC_64_SPEC > ; # [doc = "Synd 64 bit Encoded Syndrome"]
pub mod synd_enc_64 { # [doc = "Register `SYND_ENC_64` reader"]
pub struct R (crate :: R < SYND_ENC_64_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYND_ENC_64_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYND_ENC_64_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYND_ENC_64_SPEC >) -> Self { R (reader) } } # [doc = "Synd 64 bit Encoded Syndrome\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [synd_enc_64](index.html) module"]
pub struct SYND_ENC_64_SPEC ; impl crate :: RegisterSpec for SYND_ENC_64_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [synd_enc_64::R](R) reader structure"]
impl crate :: Readable for SYND_ENC_64_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYND_ENC_64 to value 0"]
impl crate :: Resettable for SYND_ENC_64_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYND_CHECK_64_DATA0 register accessor: an alias for `Reg<SYND_CHECK_64_DATA0_SPEC>`"]
pub type SYND_CHECK_64_DATA0 = crate :: Reg < synd_check_64_data0 :: SYND_CHECK_64_DATA0_SPEC > ; # [doc = "Synd 64 bit Corrected Data 0"]
pub mod synd_check_64_data0 { # [doc = "Register `SYND_CHECK_64_DATA0` reader"]
pub struct R (crate :: R < SYND_CHECK_64_DATA0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYND_CHECK_64_DATA0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYND_CHECK_64_DATA0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYND_CHECK_64_DATA0_SPEC >) -> Self { R (reader) } } # [doc = "Synd 64 bit Corrected Data 0\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [synd_check_64_data0](index.html) module"]
pub struct SYND_CHECK_64_DATA0_SPEC ; impl crate :: RegisterSpec for SYND_CHECK_64_DATA0_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [synd_check_64_data0::R](R) reader structure"]
impl crate :: Readable for SYND_CHECK_64_DATA0_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYND_CHECK_64_DATA0 to value 0"]
impl crate :: Resettable for SYND_CHECK_64_DATA0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYND_CHECK_64_DATA1 register accessor: an alias for `Reg<SYND_CHECK_64_DATA1_SPEC>`"]
pub type SYND_CHECK_64_DATA1 = crate :: Reg < synd_check_64_data1 :: SYND_CHECK_64_DATA1_SPEC > ; # [doc = "Synd 64 bit Corrected Data 1"]
pub mod synd_check_64_data1 { # [doc = "Register `SYND_CHECK_64_DATA1` reader"]
pub struct R (crate :: R < SYND_CHECK_64_DATA1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYND_CHECK_64_DATA1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYND_CHECK_64_DATA1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYND_CHECK_64_DATA1_SPEC >) -> Self { R (reader) } } # [doc = "Synd 64 bit Corrected Data 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [synd_check_64_data1](index.html) module"]
pub struct SYND_CHECK_64_DATA1_SPEC ; impl crate :: RegisterSpec for SYND_CHECK_64_DATA1_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [synd_check_64_data1::R](R) reader structure"]
impl crate :: Readable for SYND_CHECK_64_DATA1_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYND_CHECK_64_DATA1 to value 0"]
impl crate :: Resettable for SYND_CHECK_64_DATA1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYND_CHECK_64_SYND register accessor: an alias for `Reg<SYND_CHECK_64_SYND_SPEC>`"]
pub type SYND_CHECK_64_SYND = crate :: Reg < synd_check_64_synd :: SYND_CHECK_64_SYND_SPEC > ; # [doc = "Synd 64 bit Corrected Parity and Status"]
pub mod synd_check_64_synd { # [doc = "Register `SYND_CHECK_64_SYND` reader"]
pub struct R (crate :: R < SYND_CHECK_64_SYND_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYND_CHECK_64_SYND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYND_CHECK_64_SYND_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYND_CHECK_64_SYND_SPEC >) -> Self { R (reader) } } # [doc = "Synd 64 bit Corrected Parity and Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [synd_check_64_synd](index.html) module"]
pub struct SYND_CHECK_64_SYND_SPEC ; impl crate :: RegisterSpec for SYND_CHECK_64_SYND_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [synd_check_64_synd::R](R) reader structure"]
impl crate :: Readable for SYND_CHECK_64_SYND_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYND_CHECK_64_SYND to value 0"]
impl crate :: Resettable for SYND_CHECK_64_SYND_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYND_ENC_32_52 register accessor: an alias for `Reg<SYND_ENC_32_52_SPEC>`"]
pub type SYND_ENC_32_52 = crate :: Reg < synd_enc_32_52 :: SYND_ENC_32_52_SPEC > ; # [doc = "Synd 32/52 bit Encoded Syndrome"]
pub mod synd_enc_32_52 { # [doc = "Register `SYND_ENC_32_52` reader"]
pub struct R (crate :: R < SYND_ENC_32_52_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYND_ENC_32_52_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYND_ENC_32_52_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYND_ENC_32_52_SPEC >) -> Self { R (reader) } } # [doc = "Synd 32/52 bit Encoded Syndrome\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [synd_enc_32_52](index.html) module"]
pub struct SYND_ENC_32_52_SPEC ; impl crate :: RegisterSpec for SYND_ENC_32_52_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [synd_enc_32_52::R](R) reader structure"]
impl crate :: Readable for SYND_ENC_32_52_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYND_ENC_32_52 to value 0"]
impl crate :: Resettable for SYND_ENC_32_52_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYND_CHECK_32_52_DATA register accessor: an alias for `Reg<SYND_CHECK_32_52_DATA_SPEC>`"]
pub type SYND_CHECK_32_52_DATA = crate :: Reg < synd_check_32_52_data :: SYND_CHECK_32_52_DATA_SPEC > ; # [doc = "Synd 32/52 bit Corrected Data"]
pub mod synd_check_32_52_data { # [doc = "Register `SYND_CHECK_32_52_DATA` reader"]
pub struct R (crate :: R < SYND_CHECK_32_52_DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYND_CHECK_32_52_DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYND_CHECK_32_52_DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYND_CHECK_32_52_DATA_SPEC >) -> Self { R (reader) } } # [doc = "Synd 32/52 bit Corrected Data\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [synd_check_32_52_data](index.html) module"]
pub struct SYND_CHECK_32_52_DATA_SPEC ; impl crate :: RegisterSpec for SYND_CHECK_32_52_DATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [synd_check_32_52_data::R](R) reader structure"]
impl crate :: Readable for SYND_CHECK_32_52_DATA_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYND_CHECK_32_52_DATA to value 0"]
impl crate :: Resettable for SYND_CHECK_32_52_DATA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYND_CHECK_32_52_SYND register accessor: an alias for `Reg<SYND_CHECK_32_52_SYND_SPEC>`"]
pub type SYND_CHECK_32_52_SYND = crate :: Reg < synd_check_32_52_synd :: SYND_CHECK_32_52_SYND_SPEC > ; # [doc = "Synd 32/52 bit Corrected Syndrome and Status"]
pub mod synd_check_32_52_synd { # [doc = "Register `SYND_CHECK_32_52_SYND` reader"]
pub struct R (crate :: R < SYND_CHECK_32_52_SYND_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYND_CHECK_32_52_SYND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYND_CHECK_32_52_SYND_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYND_CHECK_32_52_SYND_SPEC >) -> Self { R (reader) } } # [doc = "Synd 32/52 bit Corrected Syndrome and Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [synd_check_32_52_synd](index.html) module"]
pub struct SYND_CHECK_32_52_SYND_SPEC ; impl crate :: RegisterSpec for SYND_CHECK_32_52_SYND_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [synd_check_32_52_synd::R](R) reader structure"]
impl crate :: Readable for SYND_CHECK_32_52_SYND_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYND_CHECK_32_52_SYND to value 0"]
impl crate :: Resettable for SYND_CHECK_32_52_SYND_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PERID register accessor: an alias for `Reg<PERID_SPEC>`"]
pub type PERID = crate :: Reg < perid :: PERID_SPEC > ; # [doc = "Peripheral ID Register"]
pub mod perid { # [doc = "Register `PERID` reader"]
pub struct R (crate :: R < PERID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERID_SPEC >) -> Self { R (reader) } } # [doc = "Peripheral ID Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perid](index.html) module"]
pub struct PERID_SPEC ; impl crate :: RegisterSpec for PERID_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [perid::R](R) reader structure"]
impl crate :: Readable for PERID_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PERID to value 0x0082_07e1"]
impl crate :: Resettable for PERID_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x0082_07e1 } } } } # [doc = "GPIO Peripheral"]
pub struct PORTA { _marker : PhantomData < * const () > } unsafe impl Send for PORTA { } impl PORTA { # [doc = r"Pointer to the register block"]
pub const PTR : * const porta :: RegisterBlock = 0x5000_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const porta :: RegisterBlock { Self :: PTR } } impl Deref for PORTA { type Target = porta :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTA") . finish () } } # [doc = "GPIO Peripheral"]
pub mod porta { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { _reserved_0_datain : [u8 ; 0x04]
, _reserved_1_datainraw : [u8 ; 0x04]
, _reserved_2_dataout : [u8 ; 0x04]
, _reserved_3_dataoutraw : [u8 ; 0x04]
, _reserved_4_setout : [u8 ; 0x04]
, _reserved_5_clrout : [u8 ; 0x04]
, _reserved_6_togout : [u8 ; 0x04]
, _reserved_7_datamask : [u8 ; 0x04]
, _reserved_8_dir : [u8 ; 0x04]
, _reserved_9_pulse : [u8 ; 0x04]
, _reserved_10_pulsebase : [u8 ; 0x04]
, _reserved_11_delay : [u8 ; 0x04]
, _reserved_12_delay : [u8 ; 0x04]
, # [doc = "0x34 - Interrupt Sense Register (1:Level Sensitive, 0:Edge Sensitive)"]
pub irq_sen : crate :: Reg < irq_sen :: IRQ_SEN_SPEC > , # [doc = "0x38 - Interrupt Both Edge Register (1:Both Edges, 0:Single Edge)"]
pub irq_edge : crate :: Reg < irq_edge :: IRQ_EDGE_SPEC > , # [doc = "0x3c - Interrupt Event Register (1:HighLevel/L->H Edge, 0:LowLevel/H->L Edge)"]
pub irq_evt : crate :: Reg < irq_evt :: IRQ_EVT_SPEC > , # [doc = "0x40 - Interrupt Enable Register"]
pub irq_enb : crate :: Reg < irq_enb :: IRQ_ENB_SPEC > , # [doc = "0x44 - Raw Interrupt Status"]
pub irq_raw : crate :: Reg < irq_raw :: IRQ_RAW_SPEC > , # [doc = "0x48 - Masked Interrupt Status"]
pub irq_end : crate :: Reg < irq_end :: IRQ_END_SPEC > , # [doc = "0x4c - Edge Status Register"]
pub edge_status : crate :: Reg < edge_status :: EDGE_STATUS_SPEC > , _reserved20 : [u8 ; 0x0fac]
, # [doc = "0xffc - Peripheral ID Register"]
pub perid : crate :: Reg < perid :: PERID_SPEC > , } impl RegisterBlock { # [doc = "0x00 - Data In Register by Byte"]
# [inline (always)]
pub fn datainbyte (& self) -> & [crate :: Reg < datainbyte :: DATAINBYTE_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (0usize) as * const [crate :: Reg < datainbyte :: DATAINBYTE_SPEC > ; 4]) } } # [doc = "0x00 - Data In Register"]
# [inline (always)]
pub fn datain (& self) -> & crate :: Reg < datain :: DATAIN_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (0usize) as * const crate :: Reg < datain :: DATAIN_SPEC >) } } # [doc = "0x04 - Data In Raw Register by Byte"]
# [inline (always)]
pub fn datainrawbyte (& self) -> & [crate :: Reg < datainrawbyte :: DATAINRAWBYTE_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (4usize) as * const [crate :: Reg < datainrawbyte :: DATAINRAWBYTE_SPEC > ; 4]) } } # [doc = "0x04 - Data In Raw Register"]
# [inline (always)]
pub fn datainraw (& self) -> & crate :: Reg < datainraw :: DATAINRAW_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (4usize) as * const crate :: Reg < datainraw :: DATAINRAW_SPEC >) } } # [doc = "0x08 - Data Out Register by Byte"]
# [inline (always)]
pub fn dataoutbyte (& self) -> & [crate :: Reg < dataoutbyte :: DATAOUTBYTE_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (8usize) as * const [crate :: Reg < dataoutbyte :: DATAOUTBYTE_SPEC > ; 4]) } } # [doc = "0x08 - Data Out Register"]
# [inline (always)]
pub fn dataout (& self) -> & crate :: Reg < dataout :: DATAOUT_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (8usize) as * const crate :: Reg < dataout :: DATAOUT_SPEC >) } } # [doc = "0x0c - Data Out Register by Byte"]
# [inline (always)]
pub fn dataoutrawbyte (& self) -> & [crate :: Reg < dataoutrawbyte :: DATAOUTRAWBYTE_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (12usize) as * const [crate :: Reg < dataoutrawbyte :: DATAOUTRAWBYTE_SPEC > ; 4]) } } # [doc = "0x0c - Data Out Register"]
# [inline (always)]
pub fn dataoutraw (& self) -> & crate :: Reg < dataoutraw :: DATAOUTRAW_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (12usize) as * const crate :: Reg < dataoutraw :: DATAOUTRAW_SPEC >) } } # [doc = "0x10 - Set Out Register by Byte"]
# [inline (always)]
pub fn setoutbyte (& self) -> & [crate :: Reg < setoutbyte :: SETOUTBYTE_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (16usize) as * const [crate :: Reg < setoutbyte :: SETOUTBYTE_SPEC > ; 4]) } } # [doc = "0x10 - Set Out Register"]
# [inline (always)]
pub fn setout (& self) -> & crate :: Reg < setout :: SETOUT_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (16usize) as * const crate :: Reg < setout :: SETOUT_SPEC >) } } # [doc = "0x14 - Clear Out Register by Byte"]
# [inline (always)]
pub fn clroutbyte (& self) -> & [crate :: Reg < clroutbyte :: CLROUTBYTE_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (20usize) as * const [crate :: Reg < clroutbyte :: CLROUTBYTE_SPEC > ; 4]) } } # [doc = "0x14 - Clear Out Register"]
# [inline (always)]
pub fn clrout (& self) -> & crate :: Reg < clrout :: CLROUT_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (20usize) as * const crate :: Reg < clrout :: CLROUT_SPEC >) } } # [doc = "0x18 - Toggle Out Register by Byte"]
# [inline (always)]
pub fn togoutbyte (& self) -> & [crate :: Reg < togoutbyte :: TOGOUTBYTE_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (24usize) as * const [crate :: Reg < togoutbyte :: TOGOUTBYTE_SPEC > ; 4]) } } # [doc = "0x18 - Toggle Out Register"]
# [inline (always)]
pub fn togout (& self) -> & crate :: Reg < togout :: TOGOUT_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (24usize) as * const crate :: Reg < togout :: TOGOUT_SPEC >) } } # [doc = "0x1c - Data Out Register by Byte"]
# [inline (always)]
pub fn datamaskbyte (& self) -> & [crate :: Reg < datamaskbyte :: DATAMASKBYTE_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (28usize) as * const [crate :: Reg < datamaskbyte :: DATAMASKBYTE_SPEC > ; 4]) } } # [doc = "0x1c - Data mask Register"]
# [inline (always)]
pub fn datamask (& self) -> & crate :: Reg < datamask :: DATAMASK_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (28usize) as * const crate :: Reg < datamask :: DATAMASK_SPEC >) } } # [doc = "0x20 - Direction Register by Byte"]
# [inline (always)]
pub fn dirbyte (& self) -> & [crate :: Reg < dirbyte :: DIRBYTE_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (32usize) as * const [crate :: Reg < dirbyte :: DIRBYTE_SPEC > ; 4]) } } # [doc = "0x20 - Direction Register (1:Output, 0:Input)"]
# [inline (always)]
pub fn dir (& self) -> & crate :: Reg < dir :: DIR_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (32usize) as * const crate :: Reg < dir :: DIR_SPEC >) } } # [doc = "0x24 - Pulse Mode Register by Byte"]
# [inline (always)]
pub fn pulsebyte (& self) -> & [crate :: Reg < pulsebyte :: PULSEBYTE_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (36usize) as * const [crate :: Reg < pulsebyte :: PULSEBYTE_SPEC > ; 4]) } } # [doc = "0x24 - Pulse Mode Register"]
# [inline (always)]
pub fn pulse (& self) -> & crate :: Reg < pulse :: PULSE_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (36usize) as * const crate :: Reg < pulse :: PULSE_SPEC >) } } # [doc = "0x28 - Pulse Base Mode Register by Byte"]
# [inline (always)]
pub fn pulsebasebyte (& self) -> & [crate :: Reg < pulsebasebyte :: PULSEBASEBYTE_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (40usize) as * const [crate :: Reg < pulsebasebyte :: PULSEBASEBYTE_SPEC > ; 4]) } } # [doc = "0x28 - Pulse Base Value Register"]
# [inline (always)]
pub fn pulsebase (& self) -> & crate :: Reg < pulsebase :: PULSEBASE_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (40usize) as * const crate :: Reg < pulsebase :: PULSEBASE_SPEC >) } } # [doc = "0x2c - Delay1 Register by Byte"]
# [inline (always)]
pub fn delay1byte (& self) -> & [crate :: Reg < delay1byte :: DELAY1BYTE_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (44usize) as * const [crate :: Reg < delay1byte :: DELAY1BYTE_SPEC > ; 4]) } } # [doc = "0x2c - Delay1 Register"]
# [inline (always)]
pub fn delay1 (& self) -> & crate :: Reg < delay1 :: DELAY1_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (44usize) as * const crate :: Reg < delay1 :: DELAY1_SPEC >) } } # [doc = "0x30 - Delay2 Register by Byte"]
# [inline (always)]
pub fn delay2byte (& self) -> & [crate :: Reg < delay2byte :: DELAY2BYTE_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (48usize) as * const [crate :: Reg < delay2byte :: DELAY2BYTE_SPEC > ; 4]) } } # [doc = "0x30 - Delay2 Register"]
# [inline (always)]
pub fn delay2 (& self) -> & crate :: Reg < delay2 :: DELAY2_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (48usize) as * const crate :: Reg < delay2 :: DELAY2_SPEC >) } } } # [doc = "DATAIN register accessor: an alias for `Reg<DATAIN_SPEC>`"]
pub type DATAIN = crate :: Reg < datain :: DATAIN_SPEC > ; # [doc = "Data In Register"]
pub mod datain { # [doc = "Register `DATAIN` reader"]
pub struct R (crate :: R < DATAIN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATAIN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATAIN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATAIN_SPEC >) -> Self { R (reader) } } # [doc = "Data In Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [datain](index.html) module"]
pub struct DATAIN_SPEC ; impl crate :: RegisterSpec for DATAIN_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [datain::R](R) reader structure"]
impl crate :: Readable for DATAIN_SPEC { type Reader = R ; } # [doc = "`reset()` method sets DATAIN to value 0"]
impl crate :: Resettable for DATAIN_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATAINBYTE register accessor: an alias for `Reg<DATAINBYTE_SPEC>`"]
pub type DATAINBYTE = crate :: Reg < datainbyte :: DATAINBYTE_SPEC > ; # [doc = "Data In Register by Byte"]
pub mod datainbyte { # [doc = "Register `DATAINBYTE[%s]` reader"]
pub struct R (crate :: R < DATAINBYTE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATAINBYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATAINBYTE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATAINBYTE_SPEC >) -> Self { R (reader) } } # [doc = "Data In Register by Byte\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [datainbyte](index.html) module"]
pub struct DATAINBYTE_SPEC ; impl crate :: RegisterSpec for DATAINBYTE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [datainbyte::R](R) reader structure"]
impl crate :: Readable for DATAINBYTE_SPEC { type Reader = R ; } # [doc = "`reset()` method sets DATAINBYTE[%s]
to value 0"]
impl crate :: Resettable for DATAINBYTE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATAINRAW register accessor: an alias for `Reg<DATAINRAW_SPEC>`"]
pub type DATAINRAW = crate :: Reg < datainraw :: DATAINRAW_SPEC > ; # [doc = "Data In Raw Register"]
pub mod datainraw { # [doc = "Register `DATAINRAW` reader"]
pub struct R (crate :: R < DATAINRAW_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATAINRAW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATAINRAW_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATAINRAW_SPEC >) -> Self { R (reader) } } # [doc = "Data In Raw Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [datainraw](index.html) module"]
pub struct DATAINRAW_SPEC ; impl crate :: RegisterSpec for DATAINRAW_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [datainraw::R](R) reader structure"]
impl crate :: Readable for DATAINRAW_SPEC { type Reader = R ; } # [doc = "`reset()` method sets DATAINRAW to value 0"]
impl crate :: Resettable for DATAINRAW_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATAINRAWBYTE register accessor: an alias for `Reg<DATAINRAWBYTE_SPEC>`"]
pub type DATAINRAWBYTE = crate :: Reg < datainrawbyte :: DATAINRAWBYTE_SPEC > ; # [doc = "Data In Raw Register by Byte"]
pub mod datainrawbyte { # [doc = "Register `DATAINRAWBYTE[%s]` reader"]
pub struct R (crate :: R < DATAINRAWBYTE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATAINRAWBYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATAINRAWBYTE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATAINRAWBYTE_SPEC >) -> Self { R (reader) } } # [doc = "Data In Raw Register by Byte\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [datainrawbyte](index.html) module"]
pub struct DATAINRAWBYTE_SPEC ; impl crate :: RegisterSpec for DATAINRAWBYTE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [datainrawbyte::R](R) reader structure"]
impl crate :: Readable for DATAINRAWBYTE_SPEC { type Reader = R ; } # [doc = "`reset()` method sets DATAINRAWBYTE[%s]
to value 0"]
impl crate :: Resettable for DATAINRAWBYTE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATAOUT register accessor: an alias for `Reg<DATAOUT_SPEC>`"]
pub type DATAOUT = crate :: Reg < dataout :: DATAOUT_SPEC > ; # [doc = "Data Out Register"]
pub mod dataout { # [doc = "Register `DATAOUT` writer"]
pub struct W (crate :: W < DATAOUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATAOUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATAOUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATAOUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Out Register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dataout](index.html) module"]
pub struct DATAOUT_SPEC ; impl crate :: RegisterSpec for DATAOUT_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [dataout::W](W) writer structure"]
impl crate :: Writable for DATAOUT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DATAOUT to value 0"]
impl crate :: Resettable for DATAOUT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATAOUTBYTE register accessor: an alias for `Reg<DATAOUTBYTE_SPEC>`"]
pub type DATAOUTBYTE = crate :: Reg < dataoutbyte :: DATAOUTBYTE_SPEC > ; # [doc = "Data Out Register by Byte"]
pub mod dataoutbyte { # [doc = "Register `DATAOUTBYTE[%s]` writer"]
pub struct W (crate :: W < DATAOUTBYTE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATAOUTBYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATAOUTBYTE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATAOUTBYTE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Out Register by Byte\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dataoutbyte](index.html) module"]
pub struct DATAOUTBYTE_SPEC ; impl crate :: RegisterSpec for DATAOUTBYTE_SPEC { type Ux = u8 ; } # [doc = "`write(|w| ..)` method takes [dataoutbyte::W](W) writer structure"]
impl crate :: Writable for DATAOUTBYTE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DATAOUTBYTE[%s]
to value 0"]
impl crate :: Resettable for DATAOUTBYTE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATAOUTRAW register accessor: an alias for `Reg<DATAOUTRAW_SPEC>`"]
pub type DATAOUTRAW = crate :: Reg < dataoutraw :: DATAOUTRAW_SPEC > ; # [doc = "Data Out Register"]
pub mod dataoutraw { # [doc = "Register `DATAOUTRAW` writer"]
pub struct W (crate :: W < DATAOUTRAW_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATAOUTRAW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATAOUTRAW_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATAOUTRAW_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Out Register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dataoutraw](index.html) module"]
pub struct DATAOUTRAW_SPEC ; impl crate :: RegisterSpec for DATAOUTRAW_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [dataoutraw::W](W) writer structure"]
impl crate :: Writable for DATAOUTRAW_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DATAOUTRAW to value 0"]
impl crate :: Resettable for DATAOUTRAW_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATAOUTRAWBYTE register accessor: an alias for `Reg<DATAOUTRAWBYTE_SPEC>`"]
pub type DATAOUTRAWBYTE = crate :: Reg < dataoutrawbyte :: DATAOUTRAWBYTE_SPEC > ; # [doc = "Data Out Register by Byte"]
pub mod dataoutrawbyte { # [doc = "Register `DATAOUTRAWBYTE[%s]` writer"]
pub struct W (crate :: W < DATAOUTRAWBYTE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATAOUTRAWBYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATAOUTRAWBYTE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATAOUTRAWBYTE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Out Register by Byte\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dataoutrawbyte](index.html) module"]
pub struct DATAOUTRAWBYTE_SPEC ; impl crate :: RegisterSpec for DATAOUTRAWBYTE_SPEC { type Ux = u8 ; } # [doc = "`write(|w| ..)` method takes [dataoutrawbyte::W](W) writer structure"]
impl crate :: Writable for DATAOUTRAWBYTE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DATAOUTRAWBYTE[%s]
to value 0"]
impl crate :: Resettable for DATAOUTRAWBYTE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SETOUT register accessor: an alias for `Reg<SETOUT_SPEC>`"]
pub type SETOUT = crate :: Reg < setout :: SETOUT_SPEC > ; # [doc = "Set Out Register"]
pub mod setout { # [doc = "Register `SETOUT` writer"]
pub struct W (crate :: W < SETOUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SETOUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SETOUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SETOUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Set Out Register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [setout](index.html) module"]
pub struct SETOUT_SPEC ; impl crate :: RegisterSpec for SETOUT_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [setout::W](W) writer structure"]
impl crate :: Writable for SETOUT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SETOUT to value 0"]
impl crate :: Resettable for SETOUT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SETOUTBYTE register accessor: an alias for `Reg<SETOUTBYTE_SPEC>`"]
pub type SETOUTBYTE = crate :: Reg < setoutbyte :: SETOUTBYTE_SPEC > ; # [doc = "Set Out Register by Byte"]
pub mod setoutbyte { # [doc = "Register `SETOUTBYTE[%s]` writer"]
pub struct W (crate :: W < SETOUTBYTE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SETOUTBYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SETOUTBYTE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SETOUTBYTE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Set Out Register by Byte\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [setoutbyte](index.html) module"]
pub struct SETOUTBYTE_SPEC ; impl crate :: RegisterSpec for SETOUTBYTE_SPEC { type Ux = u8 ; } # [doc = "`write(|w| ..)` method takes [setoutbyte::W](W) writer structure"]
impl crate :: Writable for SETOUTBYTE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SETOUTBYTE[%s]
to value 0"]
impl crate :: Resettable for SETOUTBYTE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CLROUT register accessor: an alias for `Reg<CLROUT_SPEC>`"]
pub type CLROUT = crate :: Reg < clrout :: CLROUT_SPEC > ; # [doc = "Clear Out Register"]
pub mod clrout { # [doc = "Register `CLROUT` writer"]
pub struct W (crate :: W < CLROUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CLROUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CLROUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CLROUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clear Out Register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clrout](index.html) module"]
pub struct CLROUT_SPEC ; impl crate :: RegisterSpec for CLROUT_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [clrout::W](W) writer structure"]
impl crate :: Writable for CLROUT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CLROUT to value 0"]
impl crate :: Resettable for CLROUT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CLROUTBYTE register accessor: an alias for `Reg<CLROUTBYTE_SPEC>`"]
pub type CLROUTBYTE = crate :: Reg < clroutbyte :: CLROUTBYTE_SPEC > ; # [doc = "Clear Out Register by Byte"]
pub mod clroutbyte { # [doc = "Register `CLROUTBYTE[%s]` writer"]
pub struct W (crate :: W < CLROUTBYTE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CLROUTBYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CLROUTBYTE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CLROUTBYTE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clear Out Register by Byte\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clroutbyte](index.html) module"]
pub struct CLROUTBYTE_SPEC ; impl crate :: RegisterSpec for CLROUTBYTE_SPEC { type Ux = u8 ; } # [doc = "`write(|w| ..)` method takes [clroutbyte::W](W) writer structure"]
impl crate :: Writable for CLROUTBYTE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CLROUTBYTE[%s]
to value 0"]
impl crate :: Resettable for CLROUTBYTE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TOGOUT register accessor: an alias for `Reg<TOGOUT_SPEC>`"]
pub type TOGOUT = crate :: Reg < togout :: TOGOUT_SPEC > ; # [doc = "Toggle Out Register"]
pub mod togout { # [doc = "Register `TOGOUT` writer"]
pub struct W (crate :: W < TOGOUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TOGOUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TOGOUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TOGOUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Toggle Out Register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [togout](index.html) module"]
pub struct TOGOUT_SPEC ; impl crate :: RegisterSpec for TOGOUT_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [togout::W](W) writer structure"]
impl crate :: Writable for TOGOUT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TOGOUT to value 0"]
impl crate :: Resettable for TOGOUT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TOGOUTBYTE register accessor: an alias for `Reg<TOGOUTBYTE_SPEC>`"]
pub type TOGOUTBYTE = crate :: Reg < togoutbyte :: TOGOUTBYTE_SPEC > ; # [doc = "Toggle Out Register by Byte"]
pub mod togoutbyte { # [doc = "Register `TOGOUTBYTE[%s]` writer"]
pub struct W (crate :: W < TOGOUTBYTE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TOGOUTBYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TOGOUTBYTE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TOGOUTBYTE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Toggle Out Register by Byte\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [togoutbyte](index.html) module"]
pub struct TOGOUTBYTE_SPEC ; impl crate :: RegisterSpec for TOGOUTBYTE_SPEC { type Ux = u8 ; } # [doc = "`write(|w| ..)` method takes [togoutbyte::W](W) writer structure"]
impl crate :: Writable for TOGOUTBYTE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TOGOUTBYTE[%s]
to value 0"]
impl crate :: Resettable for TOGOUTBYTE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATAMASK register accessor: an alias for `Reg<DATAMASK_SPEC>`"]
pub type DATAMASK = crate :: Reg < datamask :: DATAMASK_SPEC > ; # [doc = "Data mask Register"]
pub mod datamask { # [doc = "Register `DATAMASK` reader"]
pub struct R (crate :: R < DATAMASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATAMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATAMASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATAMASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATAMASK` writer"]
pub struct W (crate :: W < DATAMASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATAMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATAMASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATAMASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [datamask](index.html) module"]
pub struct DATAMASK_SPEC ; impl crate :: RegisterSpec for DATAMASK_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [datamask::R](R) reader structure"]
impl crate :: Readable for DATAMASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [datamask::W](W) writer structure"]
impl crate :: Writable for DATAMASK_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DATAMASK to value 0"]
impl crate :: Resettable for DATAMASK_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATAMASKBYTE register accessor: an alias for `Reg<DATAMASKBYTE_SPEC>`"]
pub type DATAMASKBYTE = crate :: Reg < datamaskbyte :: DATAMASKBYTE_SPEC > ; # [doc = "Data Out Register by Byte"]
pub mod datamaskbyte { # [doc = "Register `DATAMASKBYTE[%s]` reader"]
pub struct R (crate :: R < DATAMASKBYTE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATAMASKBYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATAMASKBYTE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATAMASKBYTE_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATAMASKBYTE[%s]` writer"]
pub struct W (crate :: W < DATAMASKBYTE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATAMASKBYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATAMASKBYTE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATAMASKBYTE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Out Register by Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [datamaskbyte](index.html) module"]
pub struct DATAMASKBYTE_SPEC ; impl crate :: RegisterSpec for DATAMASKBYTE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [datamaskbyte::R](R) reader structure"]
impl crate :: Readable for DATAMASKBYTE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [datamaskbyte::W](W) writer structure"]
impl crate :: Writable for DATAMASKBYTE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DATAMASKBYTE[%s]
to value 0"]
impl crate :: Resettable for DATAMASKBYTE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DIR register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Direction Register (1:Output, 0:Input)"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Direction Register (1:Output, 0:Input)\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DIRBYTE register accessor: an alias for `Reg<DIRBYTE_SPEC>`"]
pub type DIRBYTE = crate :: Reg < dirbyte :: DIRBYTE_SPEC > ; # [doc = "Direction Register by Byte"]
pub mod dirbyte { # [doc = "Register `DIRBYTE[%s]` reader"]
pub struct R (crate :: R < DIRBYTE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRBYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRBYTE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRBYTE_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRBYTE[%s]` writer"]
pub struct W (crate :: W < DIRBYTE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRBYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRBYTE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRBYTE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Direction Register by Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirbyte](index.html) module"]
pub struct DIRBYTE_SPEC ; impl crate :: RegisterSpec for DIRBYTE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirbyte::R](R) reader structure"]
impl crate :: Readable for DIRBYTE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirbyte::W](W) writer structure"]
impl crate :: Writable for DIRBYTE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DIRBYTE[%s]
to value 0"]
impl crate :: Resettable for DIRBYTE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PULSE register accessor: an alias for `Reg<PULSE_SPEC>`"]
pub type PULSE = crate :: Reg < pulse :: PULSE_SPEC > ; # [doc = "Pulse Mode Register"]
pub mod pulse { # [doc = "Register `PULSE` reader"]
pub struct R (crate :: R < PULSE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PULSE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PULSE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PULSE_SPEC >) -> Self { R (reader) } } # [doc = "Register `PULSE` writer"]
pub struct W (crate :: W < PULSE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PULSE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PULSE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PULSE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pulse Mode Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pulse](index.html) module"]
pub struct PULSE_SPEC ; impl crate :: RegisterSpec for PULSE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pulse::R](R) reader structure"]
impl crate :: Readable for PULSE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pulse::W](W) writer structure"]
impl crate :: Writable for PULSE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PULSE to value 0"]
impl crate :: Resettable for PULSE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PULSEBYTE register accessor: an alias for `Reg<PULSEBYTE_SPEC>`"]
pub type PULSEBYTE = crate :: Reg < pulsebyte :: PULSEBYTE_SPEC > ; # [doc = "Pulse Mode Register by Byte"]
pub mod pulsebyte { # [doc = "Register `PULSEBYTE[%s]` reader"]
pub struct R (crate :: R < PULSEBYTE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PULSEBYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PULSEBYTE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PULSEBYTE_SPEC >) -> Self { R (reader) } } # [doc = "Register `PULSEBYTE[%s]` writer"]
pub struct W (crate :: W < PULSEBYTE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PULSEBYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PULSEBYTE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PULSEBYTE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pulse Mode Register by Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pulsebyte](index.html) module"]
pub struct PULSEBYTE_SPEC ; impl crate :: RegisterSpec for PULSEBYTE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pulsebyte::R](R) reader structure"]
impl crate :: Readable for PULSEBYTE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pulsebyte::W](W) writer structure"]
impl crate :: Writable for PULSEBYTE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PULSEBYTE[%s]
to value 0"]
impl crate :: Resettable for PULSEBYTE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PULSEBASE register accessor: an alias for `Reg<PULSEBASE_SPEC>`"]
pub type PULSEBASE = crate :: Reg < pulsebase :: PULSEBASE_SPEC > ; # [doc = "Pulse Base Value Register"]
pub mod pulsebase { # [doc = "Register `PULSEBASE` reader"]
pub struct R (crate :: R < PULSEBASE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PULSEBASE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PULSEBASE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PULSEBASE_SPEC >) -> Self { R (reader) } } # [doc = "Register `PULSEBASE` writer"]
pub struct W (crate :: W < PULSEBASE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PULSEBASE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PULSEBASE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PULSEBASE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pulse Base Value Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pulsebase](index.html) module"]
pub struct PULSEBASE_SPEC ; impl crate :: RegisterSpec for PULSEBASE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pulsebase::R](R) reader structure"]
impl crate :: Readable for PULSEBASE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pulsebase::W](W) writer structure"]
impl crate :: Writable for PULSEBASE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PULSEBASE to value 0"]
impl crate :: Resettable for PULSEBASE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PULSEBASEBYTE register accessor: an alias for `Reg<PULSEBASEBYTE_SPEC>`"]
pub type PULSEBASEBYTE = crate :: Reg < pulsebasebyte :: PULSEBASEBYTE_SPEC > ; # [doc = "Pulse Base Mode Register by Byte"]
pub mod pulsebasebyte { # [doc = "Register `PULSEBASEBYTE[%s]` reader"]
pub struct R (crate :: R < PULSEBASEBYTE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PULSEBASEBYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PULSEBASEBYTE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PULSEBASEBYTE_SPEC >) -> Self { R (reader) } } # [doc = "Register `PULSEBASEBYTE[%s]` writer"]
pub struct W (crate :: W < PULSEBASEBYTE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PULSEBASEBYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PULSEBASEBYTE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PULSEBASEBYTE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pulse Base Mode Register by Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pulsebasebyte](index.html) module"]
pub struct PULSEBASEBYTE_SPEC ; impl crate :: RegisterSpec for PULSEBASEBYTE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pulsebasebyte::R](R) reader structure"]
impl crate :: Readable for PULSEBASEBYTE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pulsebasebyte::W](W) writer structure"]
impl crate :: Writable for PULSEBASEBYTE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PULSEBASEBYTE[%s]
to value 0"]
impl crate :: Resettable for PULSEBASEBYTE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DELAY1 register accessor: an alias for `Reg<DELAY1_SPEC>`"]
pub type DELAY1 = crate :: Reg < delay1 :: DELAY1_SPEC > ; # [doc = "Delay1 Register"]
pub mod delay1 { # [doc = "Register `DELAY1` reader"]
pub struct R (crate :: R < DELAY1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DELAY1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DELAY1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DELAY1_SPEC >) -> Self { R (reader) } } # [doc = "Register `DELAY1` writer"]
pub struct W (crate :: W < DELAY1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DELAY1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DELAY1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DELAY1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Delay1 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [delay1](index.html) module"]
pub struct DELAY1_SPEC ; impl crate :: RegisterSpec for DELAY1_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [delay1::R](R) reader structure"]
impl crate :: Readable for DELAY1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [delay1::W](W) writer structure"]
impl crate :: Writable for DELAY1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DELAY1 to value 0"]
impl crate :: Resettable for DELAY1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DELAY1BYTE register accessor: an alias for `Reg<DELAY1BYTE_SPEC>`"]
pub type DELAY1BYTE = crate :: Reg < delay1byte :: DELAY1BYTE_SPEC > ; # [doc = "Delay1 Register by Byte"]
pub mod delay1byte { # [doc = "Register `DELAY1BYTE[%s]` reader"]
pub struct R (crate :: R < DELAY1BYTE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DELAY1BYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DELAY1BYTE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DELAY1BYTE_SPEC >) -> Self { R (reader) } } # [doc = "Register `DELAY1BYTE[%s]` writer"]
pub struct W (crate :: W < DELAY1BYTE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DELAY1BYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DELAY1BYTE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DELAY1BYTE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Delay1 Register by Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [delay1byte](index.html) module"]
pub struct DELAY1BYTE_SPEC ; impl crate :: RegisterSpec for DELAY1BYTE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [delay1byte::R](R) reader structure"]
impl crate :: Readable for DELAY1BYTE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [delay1byte::W](W) writer structure"]
impl crate :: Writable for DELAY1BYTE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DELAY1BYTE[%s]
to value 0"]
impl crate :: Resettable for DELAY1BYTE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DELAY2 register accessor: an alias for `Reg<DELAY2_SPEC>`"]
pub type DELAY2 = crate :: Reg < delay2 :: DELAY2_SPEC > ; # [doc = "Delay2 Register"]
pub mod delay2 { # [doc = "Register `DELAY2` reader"]
pub struct R (crate :: R < DELAY2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DELAY2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DELAY2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DELAY2_SPEC >) -> Self { R (reader) } } # [doc = "Register `DELAY2` writer"]
pub struct W (crate :: W < DELAY2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DELAY2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DELAY2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DELAY2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Delay2 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [delay2](index.html) module"]
pub struct DELAY2_SPEC ; impl crate :: RegisterSpec for DELAY2_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [delay2::R](R) reader structure"]
impl crate :: Readable for DELAY2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [delay2::W](W) writer structure"]
impl crate :: Writable for DELAY2_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DELAY2 to value 0"]
impl crate :: Resettable for DELAY2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DELAY2BYTE register accessor: an alias for `Reg<DELAY2BYTE_SPEC>`"]
pub type DELAY2BYTE = crate :: Reg < delay2byte :: DELAY2BYTE_SPEC > ; # [doc = "Delay2 Register by Byte"]
pub mod delay2byte { # [doc = "Register `DELAY2BYTE[%s]` reader"]
pub struct R (crate :: R < DELAY2BYTE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DELAY2BYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DELAY2BYTE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DELAY2BYTE_SPEC >) -> Self { R (reader) } } # [doc = "Register `DELAY2BYTE[%s]` writer"]
pub struct W (crate :: W < DELAY2BYTE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DELAY2BYTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DELAY2BYTE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DELAY2BYTE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Delay2 Register by Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [delay2byte](index.html) module"]
pub struct DELAY2BYTE_SPEC ; impl crate :: RegisterSpec for DELAY2BYTE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [delay2byte::R](R) reader structure"]
impl crate :: Readable for DELAY2BYTE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [delay2byte::W](W) writer structure"]
impl crate :: Writable for DELAY2BYTE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DELAY2BYTE[%s]
to value 0"]
impl crate :: Resettable for DELAY2BYTE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_SEN register accessor: an alias for `Reg<IRQ_SEN_SPEC>`"]
pub type IRQ_SEN = crate :: Reg < irq_sen :: IRQ_SEN_SPEC > ; # [doc = "Interrupt Sense Register (1:Level Sensitive, 0:Edge Sensitive)"]
pub mod irq_sen { # [doc = "Register `IRQ_SEN` reader"]
pub struct R (crate :: R < IRQ_SEN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_SEN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_SEN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_SEN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IRQ_SEN` writer"]
pub struct W (crate :: W < IRQ_SEN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IRQ_SEN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IRQ_SEN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IRQ_SEN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Sense Register (1:Level Sensitive, 0:Edge Sensitive)\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_sen](index.html) module"]
pub struct IRQ_SEN_SPEC ; impl crate :: RegisterSpec for IRQ_SEN_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_sen::R](R) reader structure"]
impl crate :: Readable for IRQ_SEN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [irq_sen::W](W) writer structure"]
impl crate :: Writable for IRQ_SEN_SPEC { type Writer = W ; } # [doc = "`reset()` method sets IRQ_SEN to value 0"]
impl crate :: Resettable for IRQ_SEN_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_EDGE register accessor: an alias for `Reg<IRQ_EDGE_SPEC>`"]
pub type IRQ_EDGE = crate :: Reg < irq_edge :: IRQ_EDGE_SPEC > ; # [doc = "Interrupt Both Edge Register (1:Both Edges, 0:Single Edge)"]
pub mod irq_edge { # [doc = "Register `IRQ_EDGE` reader"]
pub struct R (crate :: R < IRQ_EDGE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_EDGE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_EDGE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_EDGE_SPEC >) -> Self { R (reader) } } # [doc = "Register `IRQ_EDGE` writer"]
pub struct W (crate :: W < IRQ_EDGE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IRQ_EDGE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IRQ_EDGE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IRQ_EDGE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Both Edge Register (1:Both Edges, 0:Single Edge)\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_edge](index.html) module"]
pub struct IRQ_EDGE_SPEC ; impl crate :: RegisterSpec for IRQ_EDGE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_edge::R](R) reader structure"]
impl crate :: Readable for IRQ_EDGE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [irq_edge::W](W) writer structure"]
impl crate :: Writable for IRQ_EDGE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets IRQ_EDGE to value 0"]
impl crate :: Resettable for IRQ_EDGE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_EVT register accessor: an alias for `Reg<IRQ_EVT_SPEC>`"]
pub type IRQ_EVT = crate :: Reg < irq_evt :: IRQ_EVT_SPEC > ; # [doc = "Interrupt Event Register (1:HighLevel/L->H Edge, 0:LowLevel/H->L Edge)"]
pub mod irq_evt { # [doc = "Register `IRQ_EVT` reader"]
pub struct R (crate :: R < IRQ_EVT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_EVT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_EVT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_EVT_SPEC >) -> Self { R (reader) } } # [doc = "Register `IRQ_EVT` writer"]
pub struct W (crate :: W < IRQ_EVT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IRQ_EVT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IRQ_EVT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IRQ_EVT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Event Register (1:HighLevel/L->H Edge, 0:LowLevel/H->L Edge)\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_evt](index.html) module"]
pub struct IRQ_EVT_SPEC ; impl crate :: RegisterSpec for IRQ_EVT_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_evt::R](R) reader structure"]
impl crate :: Readable for IRQ_EVT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [irq_evt::W](W) writer structure"]
impl crate :: Writable for IRQ_EVT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets IRQ_EVT to value 0"]
impl crate :: Resettable for IRQ_EVT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_ENB register accessor: an alias for `Reg<IRQ_ENB_SPEC>`"]
pub type IRQ_ENB = crate :: Reg < irq_enb :: IRQ_ENB_SPEC > ; # [doc = "Interrupt Enable Register"]
pub mod irq_enb { # [doc = "Register `IRQ_ENB` reader"]
pub struct R (crate :: R < IRQ_ENB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_ENB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_ENB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_ENB_SPEC >) -> Self { R (reader) } } # [doc = "Register `IRQ_ENB` writer"]
pub struct W (crate :: W < IRQ_ENB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IRQ_ENB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IRQ_ENB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IRQ_ENB_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_enb](index.html) module"]
pub struct IRQ_ENB_SPEC ; impl crate :: RegisterSpec for IRQ_ENB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_enb::R](R) reader structure"]
impl crate :: Readable for IRQ_ENB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [irq_enb::W](W) writer structure"]
impl crate :: Writable for IRQ_ENB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets IRQ_ENB to value 0"]
impl crate :: Resettable for IRQ_ENB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_RAW register accessor: an alias for `Reg<IRQ_RAW_SPEC>`"]
pub type IRQ_RAW = crate :: Reg < irq_raw :: IRQ_RAW_SPEC > ; # [doc = "Raw Interrupt Status"]
pub mod irq_raw { # [doc = "Register `IRQ_RAW` reader"]
pub struct R (crate :: R < IRQ_RAW_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_RAW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_RAW_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_RAW_SPEC >) -> Self { R (reader) } } # [doc = "Raw Interrupt Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_raw](index.html) module"]
pub struct IRQ_RAW_SPEC ; impl crate :: RegisterSpec for IRQ_RAW_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_raw::R](R) reader structure"]
impl crate :: Readable for IRQ_RAW_SPEC { type Reader = R ; } # [doc = "`reset()` method sets IRQ_RAW to value 0"]
impl crate :: Resettable for IRQ_RAW_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_END register accessor: an alias for `Reg<IRQ_END_SPEC>`"]
pub type IRQ_END = crate :: Reg < irq_end :: IRQ_END_SPEC > ; # [doc = "Masked Interrupt Status"]
pub mod irq_end { # [doc = "Register `IRQ_END` reader"]
pub struct R (crate :: R < IRQ_END_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_END_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_END_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_END_SPEC >) -> Self { R (reader) } } # [doc = "Masked Interrupt Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_end](index.html) module"]
pub struct IRQ_END_SPEC ; impl crate :: RegisterSpec for IRQ_END_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_end::R](R) reader structure"]
impl crate :: Readable for IRQ_END_SPEC { type Reader = R ; } # [doc = "`reset()` method sets IRQ_END to value 0"]
impl crate :: Resettable for IRQ_END_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EDGE_STATUS register accessor: an alias for `Reg<EDGE_STATUS_SPEC>`"]
pub type EDGE_STATUS = crate :: Reg < edge_status :: EDGE_STATUS_SPEC > ; # [doc = "Edge Status Register"]
pub mod edge_status { # [doc = "Register `EDGE_STATUS` reader"]
pub struct R (crate :: R < EDGE_STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EDGE_STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EDGE_STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EDGE_STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `EDGE_STATUS` writer"]
pub struct W (crate :: W < EDGE_STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EDGE_STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EDGE_STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EDGE_STATUS_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Edge Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [edge_status](index.html) module"]
pub struct EDGE_STATUS_SPEC ; impl crate :: RegisterSpec for EDGE_STATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [edge_status::R](R) reader structure"]
impl crate :: Readable for EDGE_STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [edge_status::W](W) writer structure"]
impl crate :: Writable for EDGE_STATUS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EDGE_STATUS to value 0"]
impl crate :: Resettable for EDGE_STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PERID register accessor: an alias for `Reg<PERID_SPEC>`"]
pub type PERID = crate :: Reg < perid :: PERID_SPEC > ; # [doc = "Peripheral ID Register"]
pub mod perid { # [doc = "Register `PERID` reader"]
pub struct R (crate :: R < PERID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERID_SPEC >) -> Self { R (reader) } } # [doc = "Peripheral ID Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perid](index.html) module"]
pub struct PERID_SPEC ; impl crate :: RegisterSpec for PERID_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [perid::R](R) reader structure"]
impl crate :: Readable for PERID_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PERID to value 0x0010_07e1"]
impl crate :: Resettable for PERID_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x0010_07e1 } } } } # [doc = "GPIO Peripheral"]
pub struct PORTB { _marker : PhantomData < * const () > } unsafe impl Send for PORTB { } impl PORTB { # [doc = r"Pointer to the register block"]
pub const PTR : * const porta :: RegisterBlock = 0x5000_1000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const porta :: RegisterBlock { Self :: PTR } } impl Deref for PORTB { type Target = porta :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTB") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM0 { _marker : PhantomData < * const () > } unsafe impl Send for TIM0 { } impl TIM0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4002_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM0 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM0") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub mod tim0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrl : crate :: Reg < ctrl :: CTRL_SPEC > , # [doc = "0x04 - The value that counter start from after reaching 0."]
pub rst_value : crate :: Reg < rst_value :: RST_VALUE_SPEC > , # [doc = "0x08 - The current value of the counter"]
pub cnt_value : crate :: Reg < cnt_value :: CNT_VALUE_SPEC > , # [doc = "0x0c - Alternate access to the Counter ENABLE bit in the CTRL Register"]
pub enable : crate :: Reg < enable :: ENABLE_SPEC > , # [doc = "0x10 - The Cascade Control Register. Controls the counter external enable signals"]
pub csd_ctrl : crate :: Reg < csd_ctrl :: CSD_CTRL_SPEC > , # [doc = "0x14 - Cascade Enable Selection"]
pub cascade0 : crate :: Reg < cascade0 :: CASCADE0_SPEC > , # [doc = "0x18 - Cascade Enable Selection"]
pub cascade1 : crate :: Reg < cascade1 :: CASCADE1_SPEC > , # [doc = "0x1c - Cascade Enable Selection"]
pub cascade2 : crate :: Reg < cascade2 :: CASCADE2_SPEC > , _reserved_8_pwm_value : [u8 ; 0x04]
, # [doc = "0x24 - The Pulse Width Modulation ValueB"]
pub pwmb_value : crate :: Reg < pwmb_value :: PWMB_VALUE_SPEC > , _reserved10 : [u8 ; 0x0fd4]
, # [doc = "0xffc - Peripheral ID Register"]
pub perid : crate :: Reg < perid :: PERID_SPEC > , } impl RegisterBlock { # [doc = "0x20 - The Pulse Width Modulation ValueA"]
# [inline (always)]
pub fn pwma_value (& self) -> & crate :: Reg < pwma_value :: PWMA_VALUE_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (32usize) as * const crate :: Reg < pwma_value :: PWMA_VALUE_SPEC >) } } # [doc = "0x20 - The Pulse Width Modulation Value"]
# [inline (always)]
pub fn pwm_value (& self) -> & crate :: Reg < pwm_value :: PWM_VALUE_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (32usize) as * const crate :: Reg < pwm_value :: PWM_VALUE_SPEC >) } } } # [doc = "CTRL register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Counter Enable"]
pub struct ENABLE_R (crate :: FieldReader < bool , bool >) ; impl ENABLE_R { pub (crate) fn new (bits : bool) -> Self { ENABLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ENABLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ENABLE` writer - Counter Enable"]
pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `ACTIVE` reader - Counter Active"]
pub struct ACTIVE_R (crate :: FieldReader < bool , bool >) ; impl ACTIVE_R { pub (crate) fn new (bits : bool) -> Self { ACTIVE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ACTIVE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `AUTO_DISABLE` reader - Auto Disables the counter (set ENABLE to 0) when the count reaches 0"]
pub struct AUTO_DISABLE_R (crate :: FieldReader < bool , bool >) ; impl AUTO_DISABLE_R { pub (crate) fn new (bits : bool) -> Self { AUTO_DISABLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for AUTO_DISABLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `AUTO_DISABLE` writer - Auto Disables the counter (set ENABLE to 0) when the count reaches 0"]
pub struct AUTO_DISABLE_W < 'a > { w : & 'a mut W , } impl < 'a > AUTO_DISABLE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `AUTO_DEACTIVATE` reader - Auto Deactivate the counter (set ACTIVE to 0) when the count reaches 0"]
pub struct AUTO_DEACTIVATE_R (crate :: FieldReader < bool , bool >) ; impl AUTO_DEACTIVATE_R { pub (crate) fn new (bits : bool) -> Self { AUTO_DEACTIVATE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for AUTO_DEACTIVATE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `AUTO_DEACTIVATE` writer - Auto Deactivate the counter (set ACTIVE to 0) when the count reaches 0"]
pub struct AUTO_DEACTIVATE_W < 'a > { w : & 'a mut W , } impl < 'a > AUTO_DEACTIVATE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } # [doc = "Field `IRQ_ENB` reader - Interrupt Enable"]
pub struct IRQ_ENB_R (crate :: FieldReader < bool , bool >) ; impl IRQ_ENB_R { pub (crate) fn new (bits : bool) -> Self { IRQ_ENB_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_ENB_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_ENB` writer - Interrupt Enable"]
pub struct IRQ_ENB_W < 'a > { w : & 'a mut W , } impl < 'a > IRQ_ENB_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 4)) | ((value as u32 & 0x01) << 4) ; self . w } } # [doc = "Counter Status Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum STATUS_SEL_A { # [doc = "0: Single cycle pulse when the counter reaches 0"]
DONE = 0 , # [doc = "1: Returns the counter ACTIVE bit"]
ACTIVE = 1 , # [doc = "2: Toggles the STATUS bit everytime the counter reaches 0. Basically a divide by 2 counter output."]
TOGGLE = 2 , # [doc = "3: Selects the Pulse Width Modulated output. It 1 when the counter value is >= the PWMA_VALUE"]
PWMA = 3 , # [doc = "4: Selects the Pulse Width Modulated output. It 1 when the counter value is < the PWMA_VALUE and value is > PWMA_VALUE"]
PWMB = 4 , # [doc = "5: Returns the counter ENABLED bit"]
ENABLED = 5 , # [doc = "6: Selects the Pulse Width Modulated output. It 1 when the counter value is <= the PWMA_VALUE and value is >= 0"]
PWMA_ACTIVE = 6 , } impl From < STATUS_SEL_A > for u8 { # [inline (always)]
fn from (variant : STATUS_SEL_A) -> Self { variant as _ } } # [doc = "Field `STATUS_SEL` reader - Counter Status Selection"]
pub struct STATUS_SEL_R (crate :: FieldReader < u8 , STATUS_SEL_A >) ; impl STATUS_SEL_R { pub (crate) fn new (bits : u8) -> Self { STATUS_SEL_R (crate :: FieldReader :: new (bits)) } # [doc = r"Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < STATUS_SEL_A > { match self . bits { 0 => Some (STATUS_SEL_A :: DONE) , 1 => Some (STATUS_SEL_A :: ACTIVE) , 2 => Some (STATUS_SEL_A :: TOGGLE) , 3 => Some (STATUS_SEL_A :: PWMA) , 4 => Some (STATUS_SEL_A :: PWMB) , 5 => Some (STATUS_SEL_A :: ENABLED) , 6 => Some (STATUS_SEL_A :: PWMA_ACTIVE) , _ => None , } } # [doc = "Checks if the value of the field is `DONE`"]
# [inline (always)]
pub fn is_done (& self) -> bool { * * self == STATUS_SEL_A :: DONE } # [doc = "Checks if the value of the field is `ACTIVE`"]
# [inline (always)]
pub fn is_active (& self) -> bool { * * self == STATUS_SEL_A :: ACTIVE } # [doc = "Checks if the value of the field is `TOGGLE`"]
# [inline (always)]
pub fn is_toggle (& self) -> bool { * * self == STATUS_SEL_A :: TOGGLE } # [doc = "Checks if the value of the field is `PWMA`"]
# [inline (always)]
pub fn is_pwma (& self) -> bool { * * self == STATUS_SEL_A :: PWMA } # [doc = "Checks if the value of the field is `PWMB`"]
# [inline (always)]
pub fn is_pwmb (& self) -> bool { * * self == STATUS_SEL_A :: PWMB } # [doc = "Checks if the value of the field is `ENABLED`"]
# [inline (always)]
pub fn is_enabled (& self) -> bool { * * self == STATUS_SEL_A :: ENABLED } # [doc = "Checks if the value of the field is `PWMA_ACTIVE`"]
# [inline (always)]
pub fn is_pwma_active (& self) -> bool { * * self == STATUS_SEL_A :: PWMA_ACTIVE } } impl core :: ops :: Deref for STATUS_SEL_R { type Target = crate :: FieldReader < u8 , STATUS_SEL_A > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `STATUS_SEL` writer - Counter Status Selection"]
pub struct STATUS_SEL_W < 'a > { w : & 'a mut W , } impl < 'a > STATUS_SEL_W < 'a > { # [doc = r"Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : STATUS_SEL_A) -> & 'a mut W { unsafe { self . bits (variant . into ()) } } # [doc = "Single cycle pulse when the counter reaches 0"]
# [inline (always)]
pub fn done (self) -> & 'a mut W { self . variant (STATUS_SEL_A :: DONE) } # [doc = "Returns the counter ACTIVE bit"]
# [inline (always)]
pub fn active (self) -> & 'a mut W { self . variant (STATUS_SEL_A :: ACTIVE) } # [doc = "Toggles the STATUS bit everytime the counter reaches 0. Basically a divide by 2 counter output."]
# [inline (always)]
pub fn toggle (self) -> & 'a mut W { self . variant (STATUS_SEL_A :: TOGGLE) } # [doc = "Selects the Pulse Width Modulated output. It 1 when the counter value is >= the PWMA_VALUE"]
# [inline (always)]
pub fn pwma (self) -> & 'a mut W { self . variant (STATUS_SEL_A :: PWMA) } # [doc = "Selects the Pulse Width Modulated output. It 1 when the counter value is < the PWMA_VALUE and value is > PWMA_VALUE"]
# [inline (always)]
pub fn pwmb (self) -> & 'a mut W { self . variant (STATUS_SEL_A :: PWMB) } # [doc = "Returns the counter ENABLED bit"]
# [inline (always)]
pub fn enabled (self) -> & 'a mut W { self . variant (STATUS_SEL_A :: ENABLED) } # [doc = "Selects the Pulse Width Modulated output. It 1 when the counter value is <= the PWMA_VALUE and value is >= 0"]
# [inline (always)]
pub fn pwma_active (self) -> & 'a mut W { self . variant (STATUS_SEL_A :: PWMA_ACTIVE) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x07 << 5)) | ((value as u32 & 0x07) << 5) ; self . w } } # [doc = "Field `STATUS_INV` reader - Invert the Output Status"]
pub struct STATUS_INV_R (crate :: FieldReader < bool , bool >) ; impl STATUS_INV_R { pub (crate) fn new (bits : bool) -> Self { STATUS_INV_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for STATUS_INV_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `STATUS_INV` writer - Invert the Output Status"]
pub struct STATUS_INV_W < 'a > { w : & 'a mut W , } impl < 'a > STATUS_INV_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 8)) | ((value as u32 & 0x01) << 8) ; self . w } } # [doc = "Field `REQ_STOP` reader - Stop Request"]
pub struct REQ_STOP_R (crate :: FieldReader < bool , bool >) ; impl REQ_STOP_R { pub (crate) fn new (bits : bool) -> Self { REQ_STOP_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for REQ_STOP_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `REQ_STOP` writer - Stop Request"]
pub struct REQ_STOP_W < 'a > { w : & 'a mut W , } impl < 'a > REQ_STOP_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 9)) | ((value as u32 & 0x01) << 9) ; self . w } } impl R { # [doc = "Bit 0 - Counter Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - Counter Active"]
# [inline (always)]
pub fn active (& self) -> ACTIVE_R { ACTIVE_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - Auto Disables the counter (set ENABLE to 0) when the count reaches 0"]
# [inline (always)]
pub fn auto_disable (& self) -> AUTO_DISABLE_R { AUTO_DISABLE_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - Auto Deactivate the counter (set ACTIVE to 0) when the count reaches 0"]
# [inline (always)]
pub fn auto_deactivate (& self) -> AUTO_DEACTIVATE_R { AUTO_DEACTIVATE_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - Interrupt Enable"]
# [inline (always)]
pub fn irq_enb (& self) -> IRQ_ENB_R { IRQ_ENB_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bits 5:7 - Counter Status Selection"]
# [inline (always)]
pub fn status_sel (& self) -> STATUS_SEL_R { STATUS_SEL_R :: new (((self . bits >> 5) & 0x07) as u8) } # [doc = "Bit 8 - Invert the Output Status"]
# [inline (always)]
pub fn status_inv (& self) -> STATUS_INV_R { STATUS_INV_R :: new (((self . bits >> 8) & 0x01) != 0) } # [doc = "Bit 9 - Stop Request"]
# [inline (always)]
pub fn req_stop (& self) -> REQ_STOP_R { REQ_STOP_R :: new (((self . bits >> 9) & 0x01) != 0) } } impl W { # [doc = "Bit 0 - Counter Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W { w : self } } # [doc = "Bit 2 - Auto Disables the counter (set ENABLE to 0) when the count reaches 0"]
# [inline (always)]
pub fn auto_disable (& mut self) -> AUTO_DISABLE_W { AUTO_DISABLE_W { w : self } } # [doc = "Bit 3 - Auto Deactivate the counter (set ACTIVE to 0) when the count reaches 0"]
# [inline (always)]
pub fn auto_deactivate (& mut self) -> AUTO_DEACTIVATE_W { AUTO_DEACTIVATE_W { w : self } } # [doc = "Bit 4 - Interrupt Enable"]
# [inline (always)]
pub fn irq_enb (& mut self) -> IRQ_ENB_W { IRQ_ENB_W { w : self } } # [doc = "Bits 5:7 - Counter Status Selection"]
# [inline (always)]
pub fn status_sel (& mut self) -> STATUS_SEL_W { STATUS_SEL_W { w : self } } # [doc = "Bit 8 - Invert the Output Status"]
# [inline (always)]
pub fn status_inv (& mut self) -> STATUS_INV_W { STATUS_INV_W { w : self } } # [doc = "Bit 9 - Stop Request"]
# [inline (always)]
pub fn req_stop (& mut self) -> REQ_STOP_W { REQ_STOP_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RST_VALUE register accessor: an alias for `Reg<RST_VALUE_SPEC>`"]
pub type RST_VALUE = crate :: Reg < rst_value :: RST_VALUE_SPEC > ; # [doc = "The value that counter start from after reaching 0."]
pub mod rst_value { # [doc = "Register `RST_VALUE` reader"]
pub struct R (crate :: R < RST_VALUE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RST_VALUE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RST_VALUE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RST_VALUE_SPEC >) -> Self { R (reader) } } # [doc = "Register `RST_VALUE` writer"]
pub struct W (crate :: W < RST_VALUE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RST_VALUE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RST_VALUE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RST_VALUE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "The value that counter start from after reaching 0.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rst_value](index.html) module"]
pub struct RST_VALUE_SPEC ; impl crate :: RegisterSpec for RST_VALUE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rst_value::R](R) reader structure"]
impl crate :: Readable for RST_VALUE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rst_value::W](W) writer structure"]
impl crate :: Writable for RST_VALUE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RST_VALUE to value 0"]
impl crate :: Resettable for RST_VALUE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CNT_VALUE register accessor: an alias for `Reg<CNT_VALUE_SPEC>`"]
pub type CNT_VALUE = crate :: Reg < cnt_value :: CNT_VALUE_SPEC > ; # [doc = "The current value of the counter"]
pub mod cnt_value { # [doc = "Register `CNT_VALUE` reader"]
pub struct R (crate :: R < CNT_VALUE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_VALUE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_VALUE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_VALUE_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT_VALUE` writer"]
pub struct W (crate :: W < CNT_VALUE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_VALUE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_VALUE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_VALUE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "The current value of the counter\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt_value](index.html) module"]
pub struct CNT_VALUE_SPEC ; impl crate :: RegisterSpec for CNT_VALUE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cnt_value::R](R) reader structure"]
impl crate :: Readable for CNT_VALUE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt_value::W](W) writer structure"]
impl crate :: Writable for CNT_VALUE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CNT_VALUE to value 0"]
impl crate :: Resettable for CNT_VALUE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ENABLE register accessor: an alias for `Reg<ENABLE_SPEC>`"]
pub type ENABLE = crate :: Reg < enable :: ENABLE_SPEC > ; # [doc = "Alternate access to the Counter ENABLE bit in the CTRL Register"]
pub mod enable { # [doc = "Register `ENABLE` reader"]
pub struct R (crate :: R < ENABLE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ENABLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ENABLE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ENABLE_SPEC >) -> Self { R (reader) } } # [doc = "Register `ENABLE` writer"]
pub struct W (crate :: W < ENABLE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ENABLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ENABLE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ENABLE_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Counter Enable"]
pub struct ENABLE_R (crate :: FieldReader < bool , bool >) ; impl ENABLE_R { pub (crate) fn new (bits : bool) -> Self { ENABLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ENABLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ENABLE` writer - Counter Enable"]
pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } impl R { # [doc = "Bit 0 - Counter Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 0x01) != 0) } } impl W { # [doc = "Bit 0 - Counter Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Alternate access to the Counter ENABLE bit in the CTRL Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [enable](index.html) module"]
pub struct ENABLE_SPEC ; impl crate :: RegisterSpec for ENABLE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [enable::R](R) reader structure"]
impl crate :: Readable for ENABLE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [enable::W](W) writer structure"]
impl crate :: Writable for ENABLE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ENABLE to value 0"]
impl crate :: Resettable for ENABLE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CSD_CTRL register accessor: an alias for `Reg<CSD_CTRL_SPEC>`"]
pub type CSD_CTRL = crate :: Reg < csd_ctrl :: CSD_CTRL_SPEC > ; # [doc = "The Cascade Control Register. Controls the counter external enable signals"]
pub mod csd_ctrl { # [doc = "Register `CSD_CTRL` reader"]
pub struct R (crate :: R < CSD_CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CSD_CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CSD_CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CSD_CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CSD_CTRL` writer"]
pub struct W (crate :: W < CSD_CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CSD_CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CSD_CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CSD_CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CSDEN0` reader - Cascade 0 Enable"]
pub struct CSDEN0_R (crate :: FieldReader < bool , bool >) ; impl CSDEN0_R { pub (crate) fn new (bits : bool) -> Self { CSDEN0_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for CSDEN0_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `CSDEN0` writer - Cascade 0 Enable"]
pub struct CSDEN0_W < 'a > { w : & 'a mut W , } impl < 'a > CSDEN0_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `CSDINV0` reader - Cascade 0 Invert"]
pub struct CSDINV0_R (crate :: FieldReader < bool , bool >) ; impl CSDINV0_R { pub (crate) fn new (bits : bool) -> Self { CSDINV0_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for CSDINV0_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `CSDINV0` writer - Cascade 0 Invert"]
pub struct CSDINV0_W < 'a > { w : & 'a mut W , } impl < 'a > CSDINV0_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `CSDEN1` reader - Cascade 1 Enable"]
pub struct CSDEN1_R (crate :: FieldReader < bool , bool >) ; impl CSDEN1_R { pub (crate) fn new (bits : bool) -> Self { CSDEN1_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for CSDEN1_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `CSDEN1` writer - Cascade 1 Enable"]
pub struct CSDEN1_W < 'a > { w : & 'a mut W , } impl < 'a > CSDEN1_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `CSDINV1` reader - Cascade 1 Invert"]
pub struct CSDINV1_R (crate :: FieldReader < bool , bool >) ; impl CSDINV1_R { pub (crate) fn new (bits : bool) -> Self { CSDINV1_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for CSDINV1_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `CSDINV1` writer - Cascade 1 Invert"]
pub struct CSDINV1_W < 'a > { w : & 'a mut W , } impl < 'a > CSDINV1_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } # [doc = "Field `DCASOP` reader - Dual Cascade Operation (0:AND, 1:OR)"]
pub struct DCASOP_R (crate :: FieldReader < bool , bool >) ; impl DCASOP_R { pub (crate) fn new (bits : bool) -> Self { DCASOP_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for DCASOP_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `DCASOP` writer - Dual Cascade Operation (0:AND, 1:OR)"]
pub struct DCASOP_W < 'a > { w : & 'a mut W , } impl < 'a > DCASOP_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 4)) | ((value as u32 & 0x01) << 4) ; self . w } } # [doc = "Field `CSDTRG0` reader - Cascade 0 Enabled as Trigger"]
pub struct CSDTRG0_R (crate :: FieldReader < bool , bool >) ; impl CSDTRG0_R { pub (crate) fn new (bits : bool) -> Self { CSDTRG0_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for CSDTRG0_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `CSDTRG0` writer - Cascade 0 Enabled as Trigger"]
pub struct CSDTRG0_W < 'a > { w : & 'a mut W , } impl < 'a > CSDTRG0_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | ((value as u32 & 0x01) << 6) ; self . w } } # [doc = "Field `CSDTRG1` reader - Cascade 1 Enabled as Trigger"]
pub struct CSDTRG1_R (crate :: FieldReader < bool , bool >) ; impl CSDTRG1_R { pub (crate) fn new (bits : bool) -> Self { CSDTRG1_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for CSDTRG1_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `CSDTRG1` writer - Cascade 1 Enabled as Trigger"]
pub struct CSDTRG1_W < 'a > { w : & 'a mut W , } impl < 'a > CSDTRG1_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | ((value as u32 & 0x01) << 7) ; self . w } } # [doc = "Field `CSDEN2` reader - Cascade 2 Enable"]
pub struct CSDEN2_R (crate :: FieldReader < bool , bool >) ; impl CSDEN2_R { pub (crate) fn new (bits : bool) -> Self { CSDEN2_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for CSDEN2_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `CSDEN2` writer - Cascade 2 Enable"]
pub struct CSDEN2_W < 'a > { w : & 'a mut W , } impl < 'a > CSDEN2_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 8)) | ((value as u32 & 0x01) << 8) ; self . w } } # [doc = "Field `CSDINV2` reader - Cascade 2 Invert"]
pub struct CSDINV2_R (crate :: FieldReader < bool , bool >) ; impl CSDINV2_R { pub (crate) fn new (bits : bool) -> Self { CSDINV2_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for CSDINV2_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `CSDINV2` writer - Cascade 2 Invert"]
pub struct CSDINV2_W < 'a > { w : & 'a mut W , } impl < 'a > CSDINV2_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 9)) | ((value as u32 & 0x01) << 9) ; self . w } } # [doc = "Field `CSDXXX2` reader - Cascade 2 test mode"]
pub struct CSDXXX2_R (crate :: FieldReader < bool , bool >) ; impl CSDXXX2_R { pub (crate) fn new (bits : bool) -> Self { CSDXXX2_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for CSDXXX2_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `CSDXXX2` writer - Cascade 2 test mode"]
pub struct CSDXXX2_W < 'a > { w : & 'a mut W , } impl < 'a > CSDXXX2_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 11)) | ((value as u32 & 0x01) << 11) ; self . w } } impl R { # [doc = "Bit 0 - Cascade 0 Enable"]
# [inline (always)]
pub fn csden0 (& self) -> CSDEN0_R { CSDEN0_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - Cascade 0 Invert"]
# [inline (always)]
pub fn csdinv0 (& self) -> CSDINV0_R { CSDINV0_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - Cascade 1 Enable"]
# [inline (always)]
pub fn csden1 (& self) -> CSDEN1_R { CSDEN1_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - Cascade 1 Invert"]
# [inline (always)]
pub fn csdinv1 (& self) -> CSDINV1_R { CSDINV1_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - Dual Cascade Operation (0:AND, 1:OR)"]
# [inline (always)]
pub fn dcasop (& self) -> DCASOP_R { DCASOP_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 6 - Cascade 0 Enabled as Trigger"]
# [inline (always)]
pub fn csdtrg0 (& self) -> CSDTRG0_R { CSDTRG0_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - Cascade 1 Enabled as Trigger"]
# [inline (always)]
pub fn csdtrg1 (& self) -> CSDTRG1_R { CSDTRG1_R :: new (((self . bits >> 7) & 0x01) != 0) } # [doc = "Bit 8 - Cascade 2 Enable"]
# [inline (always)]
pub fn csden2 (& self) -> CSDEN2_R { CSDEN2_R :: new (((self . bits >> 8) & 0x01) != 0) } # [doc = "Bit 9 - Cascade 2 Invert"]
# [inline (always)]
pub fn csdinv2 (& self) -> CSDINV2_R { CSDINV2_R :: new (((self . bits >> 9) & 0x01) != 0) } # [doc = "Bit 11 - Cascade 2 test mode"]
# [inline (always)]
pub fn csdxxx2 (& self) -> CSDXXX2_R { CSDXXX2_R :: new (((self . bits >> 11) & 0x01) != 0) } } impl W { # [doc = "Bit 0 - Cascade 0 Enable"]
# [inline (always)]
pub fn csden0 (& mut self) -> CSDEN0_W { CSDEN0_W { w : self } } # [doc = "Bit 1 - Cascade 0 Invert"]
# [inline (always)]
pub fn csdinv0 (& mut self) -> CSDINV0_W { CSDINV0_W { w : self } } # [doc = "Bit 2 - Cascade 1 Enable"]
# [inline (always)]
pub fn csden1 (& mut self) -> CSDEN1_W { CSDEN1_W { w : self } } # [doc = "Bit 3 - Cascade 1 Invert"]
# [inline (always)]
pub fn csdinv1 (& mut self) -> CSDINV1_W { CSDINV1_W { w : self } } # [doc = "Bit 4 - Dual Cascade Operation (0:AND, 1:OR)"]
# [inline (always)]
pub fn dcasop (& mut self) -> DCASOP_W { DCASOP_W { w : self } } # [doc = "Bit 6 - Cascade 0 Enabled as Trigger"]
# [inline (always)]
pub fn csdtrg0 (& mut self) -> CSDTRG0_W { CSDTRG0_W { w : self } } # [doc = "Bit 7 - Cascade 1 Enabled as Trigger"]
# [inline (always)]
pub fn csdtrg1 (& mut self) -> CSDTRG1_W { CSDTRG1_W { w : self } } # [doc = "Bit 8 - Cascade 2 Enable"]
# [inline (always)]
pub fn csden2 (& mut self) -> CSDEN2_W { CSDEN2_W { w : self } } # [doc = "Bit 9 - Cascade 2 Invert"]
# [inline (always)]
pub fn csdinv2 (& mut self) -> CSDINV2_W { CSDINV2_W { w : self } } # [doc = "Bit 11 - Cascade 2 test mode"]
# [inline (always)]
pub fn csdxxx2 (& mut self) -> CSDXXX2_W { CSDXXX2_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "The Cascade Control Register. Controls the counter external enable signals\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csd_ctrl](index.html) module"]
pub struct CSD_CTRL_SPEC ; impl crate :: RegisterSpec for CSD_CTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [csd_ctrl::R](R) reader structure"]
impl crate :: Readable for CSD_CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [csd_ctrl::W](W) writer structure"]
impl crate :: Writable for CSD_CTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CSD_CTRL to value 0"]
impl crate :: Resettable for CSD_CTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CASCADE0 register accessor: an alias for `Reg<CASCADE0_SPEC>`"]
pub type CASCADE0 = crate :: Reg < cascade0 :: CASCADE0_SPEC > ; # [doc = "Cascade Enable Selection"]
pub mod cascade0 { # [doc = "Register `CASCADE0` reader"]
pub struct R (crate :: R < CASCADE0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CASCADE0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CASCADE0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CASCADE0_SPEC >) -> Self { R (reader) } } # [doc = "Register `CASCADE0` writer"]
pub struct W (crate :: W < CASCADE0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CASCADE0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CASCADE0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CASCADE0_SPEC >) -> Self { W (writer) } } # [doc = "Field `CASSEL` reader - Cascade Selection"]
pub struct CASSEL_R (crate :: FieldReader < u8 , u8 >) ; impl CASSEL_R { pub (crate) fn new (bits : u8) -> Self { CASSEL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for CASSEL_R { type Target = crate :: FieldReader < u8 , u8 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `CASSEL` writer - Cascade Selection"]
pub struct CASSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CASSEL_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0xff) | (value as u32 & 0xff) ; self . w } } impl R { # [doc = "Bits 0:7 - Cascade Selection"]
# [inline (always)]
pub fn cassel (& self) -> CASSEL_R { CASSEL_R :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7 - Cascade Selection"]
# [inline (always)]
pub fn cassel (& mut self) -> CASSEL_W { CASSEL_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Cascade Enable Selection\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cascade0](index.html) module"]
pub struct CASCADE0_SPEC ; impl crate :: RegisterSpec for CASCADE0_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cascade0::R](R) reader structure"]
impl crate :: Readable for CASCADE0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cascade0::W](W) writer structure"]
impl crate :: Writable for CASCADE0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CASCADE0 to value 0"]
impl crate :: Resettable for CASCADE0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CASCADE1 register accessor: an alias for `Reg<CASCADE1_SPEC>`"]
pub type CASCADE1 = crate :: Reg < cascade1 :: CASCADE1_SPEC > ; # [doc = "Cascade Enable Selection"]
pub mod cascade1 { # [doc = "Register `CASCADE1` reader"]
pub struct R (crate :: R < CASCADE1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CASCADE1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CASCADE1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CASCADE1_SPEC >) -> Self { R (reader) } } # [doc = "Register `CASCADE1` writer"]
pub struct W (crate :: W < CASCADE1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CASCADE1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CASCADE1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CASCADE1_SPEC >) -> Self { W (writer) } } # [doc = "Field `CASSEL` reader - Cascade Selection"]
pub struct CASSEL_R (crate :: FieldReader < u8 , u8 >) ; impl CASSEL_R { pub (crate) fn new (bits : u8) -> Self { CASSEL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for CASSEL_R { type Target = crate :: FieldReader < u8 , u8 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `CASSEL` writer - Cascade Selection"]
pub struct CASSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CASSEL_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0xff) | (value as u32 & 0xff) ; self . w } } impl R { # [doc = "Bits 0:7 - Cascade Selection"]
# [inline (always)]
pub fn cassel (& self) -> CASSEL_R { CASSEL_R :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7 - Cascade Selection"]
# [inline (always)]
pub fn cassel (& mut self) -> CASSEL_W { CASSEL_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Cascade Enable Selection\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cascade1](index.html) module"]
pub struct CASCADE1_SPEC ; impl crate :: RegisterSpec for CASCADE1_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cascade1::R](R) reader structure"]
impl crate :: Readable for CASCADE1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cascade1::W](W) writer structure"]
impl crate :: Writable for CASCADE1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CASCADE1 to value 0"]
impl crate :: Resettable for CASCADE1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CASCADE2 register accessor: an alias for `Reg<CASCADE2_SPEC>`"]
pub type CASCADE2 = crate :: Reg < cascade2 :: CASCADE2_SPEC > ; # [doc = "Cascade Enable Selection"]
pub mod cascade2 { # [doc = "Register `CASCADE2` reader"]
pub struct R (crate :: R < CASCADE2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CASCADE2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CASCADE2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CASCADE2_SPEC >) -> Self { R (reader) } } # [doc = "Register `CASCADE2` writer"]
pub struct W (crate :: W < CASCADE2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CASCADE2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CASCADE2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CASCADE2_SPEC >) -> Self { W (writer) } } # [doc = "Field `CASSEL` reader - Cascade Selection"]
pub struct CASSEL_R (crate :: FieldReader < u8 , u8 >) ; impl CASSEL_R { pub (crate) fn new (bits : u8) -> Self { CASSEL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for CASSEL_R { type Target = crate :: FieldReader < u8 , u8 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `CASSEL` writer - Cascade Selection"]
pub struct CASSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CASSEL_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0xff) | (value as u32 & 0xff) ; self . w } } impl R { # [doc = "Bits 0:7 - Cascade Selection"]
# [inline (always)]
pub fn cassel (& self) -> CASSEL_R { CASSEL_R :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7 - Cascade Selection"]
# [inline (always)]
pub fn cassel (& mut self) -> CASSEL_W { CASSEL_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Cascade Enable Selection\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cascade2](index.html) module"]
pub struct CASCADE2_SPEC ; impl crate :: RegisterSpec for CASCADE2_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cascade2::R](R) reader structure"]
impl crate :: Readable for CASCADE2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cascade2::W](W) writer structure"]
impl crate :: Writable for CASCADE2_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CASCADE2 to value 0"]
impl crate :: Resettable for CASCADE2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PWM_VALUE register accessor: an alias for `Reg<PWM_VALUE_SPEC>`"]
pub type PWM_VALUE = crate :: Reg < pwm_value :: PWM_VALUE_SPEC > ; # [doc = "The Pulse Width Modulation Value"]
pub mod pwm_value { # [doc = "Register `PWM_VALUE` reader"]
pub struct R (crate :: R < PWM_VALUE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PWM_VALUE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PWM_VALUE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PWM_VALUE_SPEC >) -> Self { R (reader) } } # [doc = "Register `PWM_VALUE` writer"]
pub struct W (crate :: W < PWM_VALUE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PWM_VALUE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PWM_VALUE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PWM_VALUE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "The Pulse Width Modulation Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pwm_value](index.html) module"]
pub struct PWM_VALUE_SPEC ; impl crate :: RegisterSpec for PWM_VALUE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pwm_value::R](R) reader structure"]
impl crate :: Readable for PWM_VALUE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pwm_value::W](W) writer structure"]
impl crate :: Writable for PWM_VALUE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PWM_VALUE to value 0"]
impl crate :: Resettable for PWM_VALUE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PWMA_VALUE register accessor: an alias for `Reg<PWMA_VALUE_SPEC>`"]
pub type PWMA_VALUE = crate :: Reg < pwma_value :: PWMA_VALUE_SPEC > ; # [doc = "The Pulse Width Modulation ValueA"]
pub mod pwma_value { # [doc = "Register `PWMA_VALUE` reader"]
pub struct R (crate :: R < PWMA_VALUE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PWMA_VALUE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PWMA_VALUE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PWMA_VALUE_SPEC >) -> Self { R (reader) } } # [doc = "Register `PWMA_VALUE` writer"]
pub struct W (crate :: W < PWMA_VALUE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PWMA_VALUE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PWMA_VALUE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PWMA_VALUE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "The Pulse Width Modulation ValueA\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pwma_value](index.html) module"]
pub struct PWMA_VALUE_SPEC ; impl crate :: RegisterSpec for PWMA_VALUE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pwma_value::R](R) reader structure"]
impl crate :: Readable for PWMA_VALUE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pwma_value::W](W) writer structure"]
impl crate :: Writable for PWMA_VALUE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PWMA_VALUE to value 0"]
impl crate :: Resettable for PWMA_VALUE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PWMB_VALUE register accessor: an alias for `Reg<PWMB_VALUE_SPEC>`"]
pub type PWMB_VALUE = crate :: Reg < pwmb_value :: PWMB_VALUE_SPEC > ; # [doc = "The Pulse Width Modulation ValueB"]
pub mod pwmb_value { # [doc = "Register `PWMB_VALUE` reader"]
pub struct R (crate :: R < PWMB_VALUE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PWMB_VALUE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PWMB_VALUE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PWMB_VALUE_SPEC >) -> Self { R (reader) } } # [doc = "Register `PWMB_VALUE` writer"]
pub struct W (crate :: W < PWMB_VALUE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PWMB_VALUE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PWMB_VALUE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PWMB_VALUE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "The Pulse Width Modulation ValueB\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pwmb_value](index.html) module"]
pub struct PWMB_VALUE_SPEC ; impl crate :: RegisterSpec for PWMB_VALUE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pwmb_value::R](R) reader structure"]
impl crate :: Readable for PWMB_VALUE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pwmb_value::W](W) writer structure"]
impl crate :: Writable for PWMB_VALUE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PWMB_VALUE to value 0"]
impl crate :: Resettable for PWMB_VALUE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PERID register accessor: an alias for `Reg<PERID_SPEC>`"]
pub type PERID = crate :: Reg < perid :: PERID_SPEC > ; # [doc = "Peripheral ID Register"]
pub mod perid { # [doc = "Register `PERID` reader"]
pub struct R (crate :: R < PERID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERID_SPEC >) -> Self { R (reader) } } # [doc = "Peripheral ID Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perid](index.html) module"]
pub struct PERID_SPEC ; impl crate :: RegisterSpec for PERID_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [perid::R](R) reader structure"]
impl crate :: Readable for PERID_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PERID to value 0x0011_07e1"]
impl crate :: Resettable for PERID_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x0011_07e1 } } } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM1 { _marker : PhantomData < * const () > } unsafe impl Send for TIM1 { } impl TIM1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4002_1000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM1 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM1") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM2 { _marker : PhantomData < * const () > } unsafe impl Send for TIM2 { } impl TIM2 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4002_2000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM2 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM2") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM3 { _marker : PhantomData < * const () > } unsafe impl Send for TIM3 { } impl TIM3 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4002_3000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM3 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM3") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM4 { _marker : PhantomData < * const () > } unsafe impl Send for TIM4 { } impl TIM4 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4002_4000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM4 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM4") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM5 { _marker : PhantomData < * const () > } unsafe impl Send for TIM5 { } impl TIM5 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4002_5000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM5 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM5 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM5") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM6 { _marker : PhantomData < * const () > } unsafe impl Send for TIM6 { } impl TIM6 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4002_6000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM6 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM6 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM6") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM7 { _marker : PhantomData < * const () > } unsafe impl Send for TIM7 { } impl TIM7 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4002_7000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM7 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM7 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM7") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM8 { _marker : PhantomData < * const () > } unsafe impl Send for TIM8 { } impl TIM8 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4002_8000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM8 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM8 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM8") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM9 { _marker : PhantomData < * const () > } unsafe impl Send for TIM9 { } impl TIM9 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4002_9000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM9 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM9 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM9") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM10 { _marker : PhantomData < * const () > } unsafe impl Send for TIM10 { } impl TIM10 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4002_a000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM10 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM10 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM10") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM11 { _marker : PhantomData < * const () > } unsafe impl Send for TIM11 { } impl TIM11 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4002_b000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM11 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM11 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM11") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM12 { _marker : PhantomData < * const () > } unsafe impl Send for TIM12 { } impl TIM12 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4002_c000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM12 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM12 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM12") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM13 { _marker : PhantomData < * const () > } unsafe impl Send for TIM13 { } impl TIM13 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4002_d000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM13 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM13 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM13") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM14 { _marker : PhantomData < * const () > } unsafe impl Send for TIM14 { } impl TIM14 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4002_e000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM14 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM14 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM14") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM15 { _marker : PhantomData < * const () > } unsafe impl Send for TIM15 { } impl TIM15 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4002_f000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM15 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM15 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM15") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM16 { _marker : PhantomData < * const () > } unsafe impl Send for TIM16 { } impl TIM16 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4003_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM16 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM16 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM16") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM17 { _marker : PhantomData < * const () > } unsafe impl Send for TIM17 { } impl TIM17 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4003_1000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM17 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM17 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM17") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM18 { _marker : PhantomData < * const () > } unsafe impl Send for TIM18 { } impl TIM18 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4003_2000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM18 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM18 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM18") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM19 { _marker : PhantomData < * const () > } unsafe impl Send for TIM19 { } impl TIM19 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4003_3000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM19 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM19 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM19") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM20 { _marker : PhantomData < * const () > } unsafe impl Send for TIM20 { } impl TIM20 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4003_4000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM20 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM20 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM20") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM21 { _marker : PhantomData < * const () > } unsafe impl Send for TIM21 { } impl TIM21 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4003_5000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM21 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM21 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM21") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM22 { _marker : PhantomData < * const () > } unsafe impl Send for TIM22 { } impl TIM22 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4003_6000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM22 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM22 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM22") . finish () } } # [doc = "Timer/Counter Peripheral"]
pub struct TIM23 { _marker : PhantomData < * const () > } unsafe impl Send for TIM23 { } impl TIM23 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tim0 :: RegisterBlock = 0x4003_7000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tim0 :: RegisterBlock { Self :: PTR } } impl Deref for TIM23 { type Target = tim0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIM23 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIM23") . finish () } } # [doc = "UART Peripheral"]
pub struct UARTA { _marker : PhantomData < * const () > } unsafe impl Send for UARTA { } impl UARTA { # [doc = r"Pointer to the register block"]
pub const PTR : * const uarta :: RegisterBlock = 0x4004_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const uarta :: RegisterBlock { Self :: PTR } } impl Deref for UARTA { type Target = uarta :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for UARTA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("UARTA") . finish () } } # [doc = "UART Peripheral"]
pub mod uarta { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data In/Out Register"]
pub data : crate :: Reg < data :: DATA_SPEC > , # [doc = "0x04 - Enable Register"]
pub enable : crate :: Reg < enable :: ENABLE_SPEC > , # [doc = "0x08 - Control Register"]
pub ctrl : crate :: Reg < ctrl :: CTRL_SPEC > , # [doc = "0x0c - Clock Scale Register"]
pub clkscale : crate :: Reg < clkscale :: CLKSCALE_SPEC > , # [doc = "0x10 - Status Register"]
pub rxstatus : crate :: Reg < rxstatus :: RXSTATUS_SPEC > , # [doc = "0x14 - Status Register"]
pub txstatus : crate :: Reg < txstatus :: TXSTATUS_SPEC > , # [doc = "0x18 - Clear FIFO Register"]
pub fifo_clr : crate :: Reg < fifo_clr :: FIFO_CLR_SPEC > , # [doc = "0x1c - Break Transmit Register"]
pub txbreak : crate :: Reg < txbreak :: TXBREAK_SPEC > , # [doc = "0x20 - Address9 Register"]
pub addr9 : crate :: Reg < addr9 :: ADDR9_SPEC > , # [doc = "0x24 - Address9 Mask Register"]
pub addr9mask : crate :: Reg < addr9mask :: ADDR9MASK_SPEC > , # [doc = "0x28 - IRQ Enable Register"]
pub irq_enb : crate :: Reg < irq_enb :: IRQ_ENB_SPEC > , # [doc = "0x2c - IRQ Raw Status Register"]
pub irq_raw : crate :: Reg < irq_raw :: IRQ_RAW_SPEC > , # [doc = "0x30 - IRQ Enabled Status Register"]
pub irq_end : crate :: Reg < irq_end :: IRQ_END_SPEC > , # [doc = "0x34 - IRQ Clear Status Register"]
pub irq_clr : crate :: Reg < irq_clr :: IRQ_CLR_SPEC > , # [doc = "0x38 - Rx FIFO IRQ Trigger Level"]
pub rxfifoirqtrg : crate :: Reg < rxfifoirqtrg :: RXFIFOIRQTRG_SPEC > , # [doc = "0x3c - Tx FIFO IRQ Trigger Level"]
pub txfifoirqtrg : crate :: Reg < txfifoirqtrg :: TXFIFOIRQTRG_SPEC > , # [doc = "0x40 - Rx FIFO RTS Trigger Level"]
pub rxfifortstrg : crate :: Reg < rxfifortstrg :: RXFIFORTSTRG_SPEC > , # [doc = "0x44 - Internal STATE of UART Controller"]
pub state : crate :: Reg < state :: STATE_SPEC > , _reserved18 : [u8 ; 0x0fb4]
, # [doc = "0xffc - Peripheral ID Register"]
pub perid : crate :: Reg < perid :: PERID_SPEC > , } # [doc = "DATA register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data In/Out Register"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data In/Out Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ENABLE register accessor: an alias for `Reg<ENABLE_SPEC>`"]
pub type ENABLE = crate :: Reg < enable :: ENABLE_SPEC > ; # [doc = "Enable Register"]
pub mod enable { # [doc = "Register `ENABLE` reader"]
pub struct R (crate :: R < ENABLE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ENABLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ENABLE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ENABLE_SPEC >) -> Self { R (reader) } } # [doc = "Register `ENABLE` writer"]
pub struct W (crate :: W < ENABLE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ENABLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ENABLE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ENABLE_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXENABLE` reader - Rx Enable"]
pub struct RXENABLE_R (crate :: FieldReader < bool , bool >) ; impl RXENABLE_R { pub (crate) fn new (bits : bool) -> Self { RXENABLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXENABLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXENABLE` writer - Rx Enable"]
pub struct RXENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > RXENABLE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `TXENABLE` reader - Tx Enable"]
pub struct TXENABLE_R (crate :: FieldReader < bool , bool >) ; impl TXENABLE_R { pub (crate) fn new (bits : bool) -> Self { TXENABLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXENABLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXENABLE` writer - Tx Enable"]
pub struct TXENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > TXENABLE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } impl R { # [doc = "Bit 0 - Rx Enable"]
# [inline (always)]
pub fn rxenable (& self) -> RXENABLE_R { RXENABLE_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - Tx Enable"]
# [inline (always)]
pub fn txenable (& self) -> TXENABLE_R { TXENABLE_R :: new (((self . bits >> 1) & 0x01) != 0) } } impl W { # [doc = "Bit 0 - Rx Enable"]
# [inline (always)]
pub fn rxenable (& mut self) -> RXENABLE_W { RXENABLE_W { w : self } } # [doc = "Bit 1 - Tx Enable"]
# [inline (always)]
pub fn txenable (& mut self) -> TXENABLE_W { TXENABLE_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [enable](index.html) module"]
pub struct ENABLE_SPEC ; impl crate :: RegisterSpec for ENABLE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [enable::R](R) reader structure"]
impl crate :: Readable for ENABLE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [enable::W](W) writer structure"]
impl crate :: Writable for ENABLE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ENABLE to value 0"]
impl crate :: Resettable for ENABLE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRL register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PAREN` reader - Parity Enable"]
pub struct PAREN_R (crate :: FieldReader < bool , bool >) ; impl PAREN_R { pub (crate) fn new (bits : bool) -> Self { PAREN_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for PAREN_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `PAREN` writer - Parity Enable"]
pub struct PAREN_W < 'a > { w : & 'a mut W , } impl < 'a > PAREN_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `PAREVEN` reader - Parity Even/Odd(1/0)"]
pub struct PAREVEN_R (crate :: FieldReader < bool , bool >) ; impl PAREVEN_R { pub (crate) fn new (bits : bool) -> Self { PAREVEN_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for PAREVEN_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `PAREVEN` writer - Parity Even/Odd(1/0)"]
pub struct PAREVEN_W < 'a > { w : & 'a mut W , } impl < 'a > PAREVEN_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `PARSTK` reader - Parity Sticky"]
pub struct PARSTK_R (crate :: FieldReader < bool , bool >) ; impl PARSTK_R { pub (crate) fn new (bits : bool) -> Self { PARSTK_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for PARSTK_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `PARSTK` writer - Parity Sticky"]
pub struct PARSTK_W < 'a > { w : & 'a mut W , } impl < 'a > PARSTK_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `STOPBITS` reader - Stop Bits 1/2(0/1)"]
pub struct STOPBITS_R (crate :: FieldReader < bool , bool >) ; impl STOPBITS_R { pub (crate) fn new (bits : bool) -> Self { STOPBITS_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for STOPBITS_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `STOPBITS` writer - Stop Bits 1/2(0/1)"]
pub struct STOPBITS_W < 'a > { w : & 'a mut W , } impl < 'a > STOPBITS_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } # [doc = "Field `WORDSIZE` reader - Word Size in Bits 5/6/7/8(00/01/10/11)"]
pub struct WORDSIZE_R (crate :: FieldReader < u8 , u8 >) ; impl WORDSIZE_R { pub (crate) fn new (bits : u8) -> Self { WORDSIZE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for WORDSIZE_R { type Target = crate :: FieldReader < u8 , u8 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `WORDSIZE` writer - Word Size in Bits 5/6/7/8(00/01/10/11)"]
pub struct WORDSIZE_W < 'a > { w : & 'a mut W , } impl < 'a > WORDSIZE_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x03 << 4)) | ((value as u32 & 0x03) << 4) ; self . w } } # [doc = "Field `LOOPBACK` reader - Loopback Enable"]
pub struct LOOPBACK_R (crate :: FieldReader < bool , bool >) ; impl LOOPBACK_R { pub (crate) fn new (bits : bool) -> Self { LOOPBACK_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for LOOPBACK_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `LOOPBACK` writer - Loopback Enable"]
pub struct LOOPBACK_W < 'a > { w : & 'a mut W , } impl < 'a > LOOPBACK_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | ((value as u32 & 0x01) << 6) ; self . w } } # [doc = "Field `LOOPBACKBLK` reader - Loopback Block"]
pub struct LOOPBACKBLK_R (crate :: FieldReader < bool , bool >) ; impl LOOPBACKBLK_R { pub (crate) fn new (bits : bool) -> Self { LOOPBACKBLK_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for LOOPBACKBLK_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `LOOPBACKBLK` writer - Loopback Block"]
pub struct LOOPBACKBLK_W < 'a > { w : & 'a mut W , } impl < 'a > LOOPBACKBLK_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | ((value as u32 & 0x01) << 7) ; self . w } } # [doc = "Field `AUTOCTS` reader - Enable Auto CTS mode"]
pub struct AUTOCTS_R (crate :: FieldReader < bool , bool >) ; impl AUTOCTS_R { pub (crate) fn new (bits : bool) -> Self { AUTOCTS_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for AUTOCTS_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `AUTOCTS` writer - Enable Auto CTS mode"]
pub struct AUTOCTS_W < 'a > { w : & 'a mut W , } impl < 'a > AUTOCTS_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 8)) | ((value as u32 & 0x01) << 8) ; self . w } } # [doc = "Field `DEFRTS` reader - Default RTSn value"]
pub struct DEFRTS_R (crate :: FieldReader < bool , bool >) ; impl DEFRTS_R { pub (crate) fn new (bits : bool) -> Self { DEFRTS_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for DEFRTS_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `DEFRTS` writer - Default RTSn value"]
pub struct DEFRTS_W < 'a > { w : & 'a mut W , } impl < 'a > DEFRTS_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 9)) | ((value as u32 & 0x01) << 9) ; self . w } } # [doc = "Field `AUTORTS` reader - Enable Auto RTS mode"]
pub struct AUTORTS_R (crate :: FieldReader < bool , bool >) ; impl AUTORTS_R { pub (crate) fn new (bits : bool) -> Self { AUTORTS_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for AUTORTS_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `AUTORTS` writer - Enable Auto RTS mode"]
pub struct AUTORTS_W < 'a > { w : & 'a mut W , } impl < 'a > AUTORTS_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 10)) | ((value as u32 & 0x01) << 10) ; self . w } } # [doc = "Field `BAUD8` reader - Enable BAUD8 mode"]
pub struct BAUD8_R (crate :: FieldReader < bool , bool >) ; impl BAUD8_R { pub (crate) fn new (bits : bool) -> Self { BAUD8_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for BAUD8_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `BAUD8` writer - Enable BAUD8 mode"]
pub struct BAUD8_W < 'a > { w : & 'a mut W , } impl < 'a > BAUD8_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 11)) | ((value as u32 & 0x01) << 11) ; self . w } } impl R { # [doc = "Bit 0 - Parity Enable"]
# [inline (always)]
pub fn paren (& self) -> PAREN_R { PAREN_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - Parity Even/Odd(1/0)"]
# [inline (always)]
pub fn pareven (& self) -> PAREVEN_R { PAREVEN_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - Parity Sticky"]
# [inline (always)]
pub fn parstk (& self) -> PARSTK_R { PARSTK_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - Stop Bits 1/2(0/1)"]
# [inline (always)]
pub fn stopbits (& self) -> STOPBITS_R { STOPBITS_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bits 4:5 - Word Size in Bits 5/6/7/8(00/01/10/11)"]
# [inline (always)]
pub fn wordsize (& self) -> WORDSIZE_R { WORDSIZE_R :: new (((self . bits >> 4) & 0x03) as u8) } # [doc = "Bit 6 - Loopback Enable"]
# [inline (always)]
pub fn loopback (& self) -> LOOPBACK_R { LOOPBACK_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - Loopback Block"]
# [inline (always)]
pub fn loopbackblk (& self) -> LOOPBACKBLK_R { LOOPBACKBLK_R :: new (((self . bits >> 7) & 0x01) != 0) } # [doc = "Bit 8 - Enable Auto CTS mode"]
# [inline (always)]
pub fn autocts (& self) -> AUTOCTS_R { AUTOCTS_R :: new (((self . bits >> 8) & 0x01) != 0) } # [doc = "Bit 9 - Default RTSn value"]
# [inline (always)]
pub fn defrts (& self) -> DEFRTS_R { DEFRTS_R :: new (((self . bits >> 9) & 0x01) != 0) } # [doc = "Bit 10 - Enable Auto RTS mode"]
# [inline (always)]
pub fn autorts (& self) -> AUTORTS_R { AUTORTS_R :: new (((self . bits >> 10) & 0x01) != 0) } # [doc = "Bit 11 - Enable BAUD8 mode"]
# [inline (always)]
pub fn baud8 (& self) -> BAUD8_R { BAUD8_R :: new (((self . bits >> 11) & 0x01) != 0) } } impl W { # [doc = "Bit 0 - Parity Enable"]
# [inline (always)]
pub fn paren (& mut self) -> PAREN_W { PAREN_W { w : self } } # [doc = "Bit 1 - Parity Even/Odd(1/0)"]
# [inline (always)]
pub fn pareven (& mut self) -> PAREVEN_W { PAREVEN_W { w : self } } # [doc = "Bit 2 - Parity Sticky"]
# [inline (always)]
pub fn parstk (& mut self) -> PARSTK_W { PARSTK_W { w : self } } # [doc = "Bit 3 - Stop Bits 1/2(0/1)"]
# [inline (always)]
pub fn stopbits (& mut self) -> STOPBITS_W { STOPBITS_W { w : self } } # [doc = "Bits 4:5 - Word Size in Bits 5/6/7/8(00/01/10/11)"]
# [inline (always)]
pub fn wordsize (& mut self) -> WORDSIZE_W { WORDSIZE_W { w : self } } # [doc = "Bit 6 - Loopback Enable"]
# [inline (always)]
pub fn loopback (& mut self) -> LOOPBACK_W { LOOPBACK_W { w : self } } # [doc = "Bit 7 - Loopback Block"]
# [inline (always)]
pub fn loopbackblk (& mut self) -> LOOPBACKBLK_W { LOOPBACKBLK_W { w : self } } # [doc = "Bit 8 - Enable Auto CTS mode"]
# [inline (always)]
pub fn autocts (& mut self) -> AUTOCTS_W { AUTOCTS_W { w : self } } # [doc = "Bit 9 - Default RTSn value"]
# [inline (always)]
pub fn defrts (& mut self) -> DEFRTS_W { DEFRTS_W { w : self } } # [doc = "Bit 10 - Enable Auto RTS mode"]
# [inline (always)]
pub fn autorts (& mut self) -> AUTORTS_W { AUTORTS_W { w : self } } # [doc = "Bit 11 - Enable BAUD8 mode"]
# [inline (always)]
pub fn baud8 (& mut self) -> BAUD8_W { BAUD8_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CLKSCALE register accessor: an alias for `Reg<CLKSCALE_SPEC>`"]
pub type CLKSCALE = crate :: Reg < clkscale :: CLKSCALE_SPEC > ; # [doc = "Clock Scale Register"]
pub mod clkscale { # [doc = "Register `CLKSCALE` reader"]
pub struct R (crate :: R < CLKSCALE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CLKSCALE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CLKSCALE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CLKSCALE_SPEC >) -> Self { R (reader) } } # [doc = "Register `CLKSCALE` writer"]
pub struct W (crate :: W < CLKSCALE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CLKSCALE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CLKSCALE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CLKSCALE_SPEC >) -> Self { W (writer) } } # [doc = "Field `FRAC` reader - Fractional Divide (64ths)"]
pub struct FRAC_R (crate :: FieldReader < u8 , u8 >) ; impl FRAC_R { pub (crate) fn new (bits : u8) -> Self { FRAC_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for FRAC_R { type Target = crate :: FieldReader < u8 , u8 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `FRAC` writer - Fractional Divide (64ths)"]
pub struct FRAC_W < 'a > { w : & 'a mut W , } impl < 'a > FRAC_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x3f) | (value as u32 & 0x3f) ; self . w } } # [doc = "Field `INT` reader - Integer Divide"]
pub struct INT_R (crate :: FieldReader < u32 , u32 >) ; impl INT_R { pub (crate) fn new (bits : u32) -> Self { INT_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for INT_R { type Target = crate :: FieldReader < u32 , u32 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `INT` writer - Integer Divide"]
pub struct INT_W < 'a > { w : & 'a mut W , } impl < 'a > INT_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u32) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x0003_ffff << 6)) | ((value as u32 & 0x0003_ffff) << 6) ; self . w } } # [doc = "Field `RESET` writer - Reset Baud Counter"]
pub struct RESET_W < 'a > { w : & 'a mut W , } impl < 'a > RESET_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 31)) | ((value as u32 & 0x01) << 31) ; self . w } } impl R { # [doc = "Bits 0:5 - Fractional Divide (64ths)"]
# [inline (always)]
pub fn frac (& self) -> FRAC_R { FRAC_R :: new ((self . bits & 0x3f) as u8) } # [doc = "Bits 6:23 - Integer Divide"]
# [inline (always)]
pub fn int (& self) -> INT_R { INT_R :: new (((self . bits >> 6) & 0x0003_ffff) as u32) } } impl W { # [doc = "Bits 0:5 - Fractional Divide (64ths)"]
# [inline (always)]
pub fn frac (& mut self) -> FRAC_W { FRAC_W { w : self } } # [doc = "Bits 6:23 - Integer Divide"]
# [inline (always)]
pub fn int (& mut self) -> INT_W { INT_W { w : self } } # [doc = "Bit 31 - Reset Baud Counter"]
# [inline (always)]
pub fn reset (& mut self) -> RESET_W { RESET_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clock Scale Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clkscale](index.html) module"]
pub struct CLKSCALE_SPEC ; impl crate :: RegisterSpec for CLKSCALE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [clkscale::R](R) reader structure"]
impl crate :: Readable for CLKSCALE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [clkscale::W](W) writer structure"]
impl crate :: Writable for CLKSCALE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CLKSCALE to value 0"]
impl crate :: Resettable for CLKSCALE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RXSTATUS register accessor: an alias for `Reg<RXSTATUS_SPEC>`"]
pub type RXSTATUS = crate :: Reg < rxstatus :: RXSTATUS_SPEC > ; # [doc = "Status Register"]
pub mod rxstatus { # [doc = "Register `RXSTATUS` reader"]
pub struct R (crate :: R < RXSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `RDAVL` reader - Read Data Available"]
pub struct RDAVL_R (crate :: FieldReader < bool , bool >) ; impl RDAVL_R { pub (crate) fn new (bits : bool) -> Self { RDAVL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RDAVL_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RDNFULL` reader - Read Fifo NOT Full"]
pub struct RDNFULL_R (crate :: FieldReader < bool , bool >) ; impl RDNFULL_R { pub (crate) fn new (bits : bool) -> Self { RDNFULL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RDNFULL_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXBUSY` reader - RX Busy Receiving"]
pub struct RXBUSY_R (crate :: FieldReader < bool , bool >) ; impl RXBUSY_R { pub (crate) fn new (bits : bool) -> Self { RXBUSY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXBUSY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXTO` reader - RX Receive Timeout"]
pub struct RXTO_R (crate :: FieldReader < bool , bool >) ; impl RXTO_R { pub (crate) fn new (bits : bool) -> Self { RXTO_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXTO_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXOVR` reader - Read Fifo Overflow"]
pub struct RXOVR_R (crate :: FieldReader < bool , bool >) ; impl RXOVR_R { pub (crate) fn new (bits : bool) -> Self { RXOVR_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXOVR_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXFRM` reader - RX Framing Error"]
pub struct RXFRM_R (crate :: FieldReader < bool , bool >) ; impl RXFRM_R { pub (crate) fn new (bits : bool) -> Self { RXFRM_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXFRM_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXPAR` reader - RX Parity Error"]
pub struct RXPAR_R (crate :: FieldReader < bool , bool >) ; impl RXPAR_R { pub (crate) fn new (bits : bool) -> Self { RXPAR_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXPAR_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXBRK` reader - RX Break Error"]
pub struct RXBRK_R (crate :: FieldReader < bool , bool >) ; impl RXBRK_R { pub (crate) fn new (bits : bool) -> Self { RXBRK_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXBRK_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXBUSYBRK` reader - RX Busy Receiving Break"]
pub struct RXBUSYBRK_R (crate :: FieldReader < bool , bool >) ; impl RXBUSYBRK_R { pub (crate) fn new (bits : bool) -> Self { RXBUSYBRK_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXBUSYBRK_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXADDR9` reader - Address Match for 9 bit mode"]
pub struct RXADDR9_R (crate :: FieldReader < bool , bool >) ; impl RXADDR9_R { pub (crate) fn new (bits : bool) -> Self { RXADDR9_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXADDR9_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXRTSN` reader - RX RTSn Output Value"]
pub struct RXRTSN_R (crate :: FieldReader < bool , bool >) ; impl RXRTSN_R { pub (crate) fn new (bits : bool) -> Self { RXRTSN_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXRTSN_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - Read Data Available"]
# [inline (always)]
pub fn rdavl (& self) -> RDAVL_R { RDAVL_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - Read Fifo NOT Full"]
# [inline (always)]
pub fn rdnfull (& self) -> RDNFULL_R { RDNFULL_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - RX Busy Receiving"]
# [inline (always)]
pub fn rxbusy (& self) -> RXBUSY_R { RXBUSY_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - RX Receive Timeout"]
# [inline (always)]
pub fn rxto (& self) -> RXTO_R { RXTO_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - Read Fifo Overflow"]
# [inline (always)]
pub fn rxovr (& self) -> RXOVR_R { RXOVR_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - RX Framing Error"]
# [inline (always)]
pub fn rxfrm (& self) -> RXFRM_R { RXFRM_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - RX Parity Error"]
# [inline (always)]
pub fn rxpar (& self) -> RXPAR_R { RXPAR_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - RX Break Error"]
# [inline (always)]
pub fn rxbrk (& self) -> RXBRK_R { RXBRK_R :: new (((self . bits >> 7) & 0x01) != 0) } # [doc = "Bit 8 - RX Busy Receiving Break"]
# [inline (always)]
pub fn rxbusybrk (& self) -> RXBUSYBRK_R { RXBUSYBRK_R :: new (((self . bits >> 8) & 0x01) != 0) } # [doc = "Bit 9 - Address Match for 9 bit mode"]
# [inline (always)]
pub fn rxaddr9 (& self) -> RXADDR9_R { RXADDR9_R :: new (((self . bits >> 9) & 0x01) != 0) } # [doc = "Bit 15 - RX RTSn Output Value"]
# [inline (always)]
pub fn rxrtsn (& self) -> RXRTSN_R { RXRTSN_R :: new (((self . bits >> 15) & 0x01) != 0) } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxstatus](index.html) module"]
pub struct RXSTATUS_SPEC ; impl crate :: RegisterSpec for RXSTATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rxstatus::R](R) reader structure"]
impl crate :: Readable for RXSTATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets RXSTATUS to value 0"]
impl crate :: Resettable for RXSTATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TXSTATUS register accessor: an alias for `Reg<TXSTATUS_SPEC>`"]
pub type TXSTATUS = crate :: Reg < txstatus :: TXSTATUS_SPEC > ; # [doc = "Status Register"]
pub mod txstatus { # [doc = "Register `TXSTATUS` reader"]
pub struct R (crate :: R < TXSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `WRRDY` reader - Write Fifo NOT Full"]
pub struct WRRDY_R (crate :: FieldReader < bool , bool >) ; impl WRRDY_R { pub (crate) fn new (bits : bool) -> Self { WRRDY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for WRRDY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `WRBUSY` reader - Write Fifo Full"]
pub struct WRBUSY_R (crate :: FieldReader < bool , bool >) ; impl WRBUSY_R { pub (crate) fn new (bits : bool) -> Self { WRBUSY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for WRBUSY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXBUSY` reader - TX Busy Transmitting"]
pub struct TXBUSY_R (crate :: FieldReader < bool , bool >) ; impl TXBUSY_R { pub (crate) fn new (bits : bool) -> Self { TXBUSY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXBUSY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `WRLOST` reader - Write Data Lost (Fifo Overflow)"]
pub struct WRLOST_R (crate :: FieldReader < bool , bool >) ; impl WRLOST_R { pub (crate) fn new (bits : bool) -> Self { WRLOST_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for WRLOST_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXCTSN` reader - TX CTSn Input Value"]
pub struct TXCTSN_R (crate :: FieldReader < bool , bool >) ; impl TXCTSN_R { pub (crate) fn new (bits : bool) -> Self { TXCTSN_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXCTSN_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - Write Fifo NOT Full"]
# [inline (always)]
pub fn wrrdy (& self) -> WRRDY_R { WRRDY_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - Write Fifo Full"]
# [inline (always)]
pub fn wrbusy (& self) -> WRBUSY_R { WRBUSY_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - TX Busy Transmitting"]
# [inline (always)]
pub fn txbusy (& self) -> TXBUSY_R { TXBUSY_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - Write Data Lost (Fifo Overflow)"]
# [inline (always)]
pub fn wrlost (& self) -> WRLOST_R { WRLOST_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 15 - TX CTSn Input Value"]
# [inline (always)]
pub fn txctsn (& self) -> TXCTSN_R { TXCTSN_R :: new (((self . bits >> 15) & 0x01) != 0) } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txstatus](index.html) module"]
pub struct TXSTATUS_SPEC ; impl crate :: RegisterSpec for TXSTATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [txstatus::R](R) reader structure"]
impl crate :: Readable for TXSTATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets TXSTATUS to value 0"]
impl crate :: Resettable for TXSTATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "FIFO_CLR register accessor: an alias for `Reg<FIFO_CLR_SPEC>`"]
pub type FIFO_CLR = crate :: Reg < fifo_clr :: FIFO_CLR_SPEC > ; # [doc = "Clear FIFO Register"]
pub mod fifo_clr { # [doc = "Register `FIFO_CLR` writer"]
pub struct W (crate :: W < FIFO_CLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FIFO_CLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FIFO_CLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FIFO_CLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXSTS` writer - Clear Rx Status"]
pub struct RXSTS_W < 'a > { w : & 'a mut W , } impl < 'a > RXSTS_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `TXSTS` writer - Clear Tx Status"]
pub struct TXSTS_W < 'a > { w : & 'a mut W , } impl < 'a > TXSTS_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `RXFIFO` writer - Clear Rx FIFO"]
pub struct RXFIFO_W < 'a > { w : & 'a mut W , } impl < 'a > RXFIFO_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `TXFIFO` writer - Clear Tx FIFO"]
pub struct TXFIFO_W < 'a > { w : & 'a mut W , } impl < 'a > TXFIFO_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } impl W { # [doc = "Bit 0 - Clear Rx Status"]
# [inline (always)]
pub fn rxsts (& mut self) -> RXSTS_W { RXSTS_W { w : self } } # [doc = "Bit 1 - Clear Tx Status"]
# [inline (always)]
pub fn txsts (& mut self) -> TXSTS_W { TXSTS_W { w : self } } # [doc = "Bit 2 - Clear Rx FIFO"]
# [inline (always)]
pub fn rxfifo (& mut self) -> RXFIFO_W { RXFIFO_W { w : self } } # [doc = "Bit 3 - Clear Tx FIFO"]
# [inline (always)]
pub fn txfifo (& mut self) -> TXFIFO_W { TXFIFO_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clear FIFO Register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fifo_clr](index.html) module"]
pub struct FIFO_CLR_SPEC ; impl crate :: RegisterSpec for FIFO_CLR_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [fifo_clr::W](W) writer structure"]
impl crate :: Writable for FIFO_CLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets FIFO_CLR to value 0"]
impl crate :: Resettable for FIFO_CLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TXBREAK register accessor: an alias for `Reg<TXBREAK_SPEC>`"]
pub type TXBREAK = crate :: Reg < txbreak :: TXBREAK_SPEC > ; # [doc = "Break Transmit Register"]
pub mod txbreak { # [doc = "Register `TXBREAK` writer"]
pub struct W (crate :: W < TXBREAK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXBREAK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXBREAK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXBREAK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Break Transmit Register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txbreak](index.html) module"]
pub struct TXBREAK_SPEC ; impl crate :: RegisterSpec for TXBREAK_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [txbreak::W](W) writer structure"]
impl crate :: Writable for TXBREAK_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TXBREAK to value 0"]
impl crate :: Resettable for TXBREAK_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ADDR9 register accessor: an alias for `Reg<ADDR9_SPEC>`"]
pub type ADDR9 = crate :: Reg < addr9 :: ADDR9_SPEC > ; # [doc = "Address9 Register"]
pub mod addr9 { # [doc = "Register `ADDR9` reader"]
pub struct R (crate :: R < ADDR9_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADDR9_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADDR9_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADDR9_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADDR9` writer"]
pub struct W (crate :: W < ADDR9_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADDR9_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADDR9_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADDR9_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Address9 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [addr9](index.html) module"]
pub struct ADDR9_SPEC ; impl crate :: RegisterSpec for ADDR9_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [addr9::R](R) reader structure"]
impl crate :: Readable for ADDR9_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [addr9::W](W) writer structure"]
impl crate :: Writable for ADDR9_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADDR9 to value 0"]
impl crate :: Resettable for ADDR9_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ADDR9MASK register accessor: an alias for `Reg<ADDR9MASK_SPEC>`"]
pub type ADDR9MASK = crate :: Reg < addr9mask :: ADDR9MASK_SPEC > ; # [doc = "Address9 Mask Register"]
pub mod addr9mask { # [doc = "Register `ADDR9MASK` reader"]
pub struct R (crate :: R < ADDR9MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADDR9MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADDR9MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADDR9MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADDR9MASK` writer"]
pub struct W (crate :: W < ADDR9MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADDR9MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADDR9MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADDR9MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Address9 Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [addr9mask](index.html) module"]
pub struct ADDR9MASK_SPEC ; impl crate :: RegisterSpec for ADDR9MASK_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [addr9mask::R](R) reader structure"]
impl crate :: Readable for ADDR9MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [addr9mask::W](W) writer structure"]
impl crate :: Writable for ADDR9MASK_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADDR9MASK to value 0"]
impl crate :: Resettable for ADDR9MASK_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_ENB register accessor: an alias for `Reg<IRQ_ENB_SPEC>`"]
pub type IRQ_ENB = crate :: Reg < irq_enb :: IRQ_ENB_SPEC > ; # [doc = "IRQ Enable Register"]
pub mod irq_enb { # [doc = "Register `IRQ_ENB` reader"]
pub struct R (crate :: R < IRQ_ENB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_ENB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_ENB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_ENB_SPEC >) -> Self { R (reader) } } # [doc = "Register `IRQ_ENB` writer"]
pub struct W (crate :: W < IRQ_ENB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IRQ_ENB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IRQ_ENB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IRQ_ENB_SPEC >) -> Self { W (writer) } } # [doc = "Field `IRQ_RX` reader - RX Interrupt"]
pub struct IRQ_RX_R (crate :: FieldReader < bool , bool >) ; impl IRQ_RX_R { pub (crate) fn new (bits : bool) -> Self { IRQ_RX_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_RX_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_RX` writer - RX Interrupt"]
pub struct IRQ_RX_W < 'a > { w : & 'a mut W , } impl < 'a > IRQ_RX_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `IRQ_RX_STATUS` reader - RX Status Interrupt"]
pub struct IRQ_RX_STATUS_R (crate :: FieldReader < bool , bool >) ; impl IRQ_RX_STATUS_R { pub (crate) fn new (bits : bool) -> Self { IRQ_RX_STATUS_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_RX_STATUS_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_RX_STATUS` writer - RX Status Interrupt"]
pub struct IRQ_RX_STATUS_W < 'a > { w : & 'a mut W , } impl < 'a > IRQ_RX_STATUS_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `IRQ_RX_TO` reader - RX Timeout Interrupt"]
pub struct IRQ_RX_TO_R (crate :: FieldReader < bool , bool >) ; impl IRQ_RX_TO_R { pub (crate) fn new (bits : bool) -> Self { IRQ_RX_TO_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_RX_TO_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_RX_TO` writer - RX Timeout Interrupt"]
pub struct IRQ_RX_TO_W < 'a > { w : & 'a mut W , } impl < 'a > IRQ_RX_TO_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `IRQ_TX` reader - TX Interrupt"]
pub struct IRQ_TX_R (crate :: FieldReader < bool , bool >) ; impl IRQ_TX_R { pub (crate) fn new (bits : bool) -> Self { IRQ_TX_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_TX_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_TX` writer - TX Interrupt"]
pub struct IRQ_TX_W < 'a > { w : & 'a mut W , } impl < 'a > IRQ_TX_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 4)) | ((value as u32 & 0x01) << 4) ; self . w } } # [doc = "Field `IRQ_TX_STATUS` reader - TX Status Interrupt"]
pub struct IRQ_TX_STATUS_R (crate :: FieldReader < bool , bool >) ; impl IRQ_TX_STATUS_R { pub (crate) fn new (bits : bool) -> Self { IRQ_TX_STATUS_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_TX_STATUS_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_TX_STATUS` writer - TX Status Interrupt"]
pub struct IRQ_TX_STATUS_W < 'a > { w : & 'a mut W , } impl < 'a > IRQ_TX_STATUS_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 5)) | ((value as u32 & 0x01) << 5) ; self . w } } # [doc = "Field `IRQ_TX_EMPTY` reader - TX Empty Interrupt"]
pub struct IRQ_TX_EMPTY_R (crate :: FieldReader < bool , bool >) ; impl IRQ_TX_EMPTY_R { pub (crate) fn new (bits : bool) -> Self { IRQ_TX_EMPTY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_TX_EMPTY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_TX_EMPTY` writer - TX Empty Interrupt"]
pub struct IRQ_TX_EMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > IRQ_TX_EMPTY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | ((value as u32 & 0x01) << 6) ; self . w } } # [doc = "Field `IRQ_TX_CTS` reader - TX CTS Change Interrupt"]
pub struct IRQ_TX_CTS_R (crate :: FieldReader < bool , bool >) ; impl IRQ_TX_CTS_R { pub (crate) fn new (bits : bool) -> Self { IRQ_TX_CTS_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_TX_CTS_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_TX_CTS` writer - TX CTS Change Interrupt"]
pub struct IRQ_TX_CTS_W < 'a > { w : & 'a mut W , } impl < 'a > IRQ_TX_CTS_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | ((value as u32 & 0x01) << 7) ; self . w } } impl R { # [doc = "Bit 0 - RX Interrupt"]
# [inline (always)]
pub fn irq_rx (& self) -> IRQ_RX_R { IRQ_RX_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - RX Status Interrupt"]
# [inline (always)]
pub fn irq_rx_status (& self) -> IRQ_RX_STATUS_R { IRQ_RX_STATUS_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - RX Timeout Interrupt"]
# [inline (always)]
pub fn irq_rx_to (& self) -> IRQ_RX_TO_R { IRQ_RX_TO_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 4 - TX Interrupt"]
# [inline (always)]
pub fn irq_tx (& self) -> IRQ_TX_R { IRQ_TX_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - TX Status Interrupt"]
# [inline (always)]
pub fn irq_tx_status (& self) -> IRQ_TX_STATUS_R { IRQ_TX_STATUS_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - TX Empty Interrupt"]
# [inline (always)]
pub fn irq_tx_empty (& self) -> IRQ_TX_EMPTY_R { IRQ_TX_EMPTY_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - TX CTS Change Interrupt"]
# [inline (always)]
pub fn irq_tx_cts (& self) -> IRQ_TX_CTS_R { IRQ_TX_CTS_R :: new (((self . bits >> 7) & 0x01) != 0) } } impl W { # [doc = "Bit 0 - RX Interrupt"]
# [inline (always)]
pub fn irq_rx (& mut self) -> IRQ_RX_W { IRQ_RX_W { w : self } } # [doc = "Bit 1 - RX Status Interrupt"]
# [inline (always)]
pub fn irq_rx_status (& mut self) -> IRQ_RX_STATUS_W { IRQ_RX_STATUS_W { w : self } } # [doc = "Bit 2 - RX Timeout Interrupt"]
# [inline (always)]
pub fn irq_rx_to (& mut self) -> IRQ_RX_TO_W { IRQ_RX_TO_W { w : self } } # [doc = "Bit 4 - TX Interrupt"]
# [inline (always)]
pub fn irq_tx (& mut self) -> IRQ_TX_W { IRQ_TX_W { w : self } } # [doc = "Bit 5 - TX Status Interrupt"]
# [inline (always)]
pub fn irq_tx_status (& mut self) -> IRQ_TX_STATUS_W { IRQ_TX_STATUS_W { w : self } } # [doc = "Bit 6 - TX Empty Interrupt"]
# [inline (always)]
pub fn irq_tx_empty (& mut self) -> IRQ_TX_EMPTY_W { IRQ_TX_EMPTY_W { w : self } } # [doc = "Bit 7 - TX CTS Change Interrupt"]
# [inline (always)]
pub fn irq_tx_cts (& mut self) -> IRQ_TX_CTS_W { IRQ_TX_CTS_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "IRQ Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_enb](index.html) module"]
pub struct IRQ_ENB_SPEC ; impl crate :: RegisterSpec for IRQ_ENB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_enb::R](R) reader structure"]
impl crate :: Readable for IRQ_ENB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [irq_enb::W](W) writer structure"]
impl crate :: Writable for IRQ_ENB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets IRQ_ENB to value 0"]
impl crate :: Resettable for IRQ_ENB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_RAW register accessor: an alias for `Reg<IRQ_RAW_SPEC>`"]
pub type IRQ_RAW = crate :: Reg < irq_raw :: IRQ_RAW_SPEC > ; # [doc = "IRQ Raw Status Register"]
pub mod irq_raw { # [doc = "Register `IRQ_RAW` reader"]
pub struct R (crate :: R < IRQ_RAW_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_RAW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_RAW_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_RAW_SPEC >) -> Self { R (reader) } } # [doc = "Field `IRQ_RX` reader - RX Interrupt"]
pub struct IRQ_RX_R (crate :: FieldReader < bool , bool >) ; impl IRQ_RX_R { pub (crate) fn new (bits : bool) -> Self { IRQ_RX_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_RX_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_RX_STATUS` reader - RX Status Interrupt"]
pub struct IRQ_RX_STATUS_R (crate :: FieldReader < bool , bool >) ; impl IRQ_RX_STATUS_R { pub (crate) fn new (bits : bool) -> Self { IRQ_RX_STATUS_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_RX_STATUS_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_RX_TO` reader - RX Timeout Interrupt"]
pub struct IRQ_RX_TO_R (crate :: FieldReader < bool , bool >) ; impl IRQ_RX_TO_R { pub (crate) fn new (bits : bool) -> Self { IRQ_RX_TO_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_RX_TO_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_TX` reader - TX Interrupt"]
pub struct IRQ_TX_R (crate :: FieldReader < bool , bool >) ; impl IRQ_TX_R { pub (crate) fn new (bits : bool) -> Self { IRQ_TX_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_TX_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_TX_STATUS` reader - TX Status Interrupt"]
pub struct IRQ_TX_STATUS_R (crate :: FieldReader < bool , bool >) ; impl IRQ_TX_STATUS_R { pub (crate) fn new (bits : bool) -> Self { IRQ_TX_STATUS_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_TX_STATUS_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_TX_EMPTY` reader - TX Empty Interrupt"]
pub struct IRQ_TX_EMPTY_R (crate :: FieldReader < bool , bool >) ; impl IRQ_TX_EMPTY_R { pub (crate) fn new (bits : bool) -> Self { IRQ_TX_EMPTY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_TX_EMPTY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_TX_CTS` reader - TX CTS Change Interrupt"]
pub struct IRQ_TX_CTS_R (crate :: FieldReader < bool , bool >) ; impl IRQ_TX_CTS_R { pub (crate) fn new (bits : bool) -> Self { IRQ_TX_CTS_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_TX_CTS_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - RX Interrupt"]
# [inline (always)]
pub fn irq_rx (& self) -> IRQ_RX_R { IRQ_RX_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - RX Status Interrupt"]
# [inline (always)]
pub fn irq_rx_status (& self) -> IRQ_RX_STATUS_R { IRQ_RX_STATUS_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - RX Timeout Interrupt"]
# [inline (always)]
pub fn irq_rx_to (& self) -> IRQ_RX_TO_R { IRQ_RX_TO_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 4 - TX Interrupt"]
# [inline (always)]
pub fn irq_tx (& self) -> IRQ_TX_R { IRQ_TX_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - TX Status Interrupt"]
# [inline (always)]
pub fn irq_tx_status (& self) -> IRQ_TX_STATUS_R { IRQ_TX_STATUS_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - TX Empty Interrupt"]
# [inline (always)]
pub fn irq_tx_empty (& self) -> IRQ_TX_EMPTY_R { IRQ_TX_EMPTY_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - TX CTS Change Interrupt"]
# [inline (always)]
pub fn irq_tx_cts (& self) -> IRQ_TX_CTS_R { IRQ_TX_CTS_R :: new (((self . bits >> 7) & 0x01) != 0) } } # [doc = "IRQ Raw Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_raw](index.html) module"]
pub struct IRQ_RAW_SPEC ; impl crate :: RegisterSpec for IRQ_RAW_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_raw::R](R) reader structure"]
impl crate :: Readable for IRQ_RAW_SPEC { type Reader = R ; } # [doc = "`reset()` method sets IRQ_RAW to value 0"]
impl crate :: Resettable for IRQ_RAW_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_END register accessor: an alias for `Reg<IRQ_END_SPEC>`"]
pub type IRQ_END = crate :: Reg < irq_end :: IRQ_END_SPEC > ; # [doc = "IRQ Enabled Status Register"]
pub mod irq_end { # [doc = "Register `IRQ_END` reader"]
pub struct R (crate :: R < IRQ_END_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_END_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_END_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_END_SPEC >) -> Self { R (reader) } } # [doc = "Field `IRQ_RX` reader - RX Interrupt"]
pub struct IRQ_RX_R (crate :: FieldReader < bool , bool >) ; impl IRQ_RX_R { pub (crate) fn new (bits : bool) -> Self { IRQ_RX_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_RX_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_RX_STATUS` reader - RX Status Interrupt"]
pub struct IRQ_RX_STATUS_R (crate :: FieldReader < bool , bool >) ; impl IRQ_RX_STATUS_R { pub (crate) fn new (bits : bool) -> Self { IRQ_RX_STATUS_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_RX_STATUS_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_RX_TO` reader - RX Timeout Interrupt"]
pub struct IRQ_RX_TO_R (crate :: FieldReader < bool , bool >) ; impl IRQ_RX_TO_R { pub (crate) fn new (bits : bool) -> Self { IRQ_RX_TO_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_RX_TO_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_TX` reader - TX Interrupt"]
pub struct IRQ_TX_R (crate :: FieldReader < bool , bool >) ; impl IRQ_TX_R { pub (crate) fn new (bits : bool) -> Self { IRQ_TX_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_TX_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_TX_STATUS` reader - TX Status Interrupt"]
pub struct IRQ_TX_STATUS_R (crate :: FieldReader < bool , bool >) ; impl IRQ_TX_STATUS_R { pub (crate) fn new (bits : bool) -> Self { IRQ_TX_STATUS_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_TX_STATUS_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_TX_EMPTY` reader - TX Empty Interrupt"]
pub struct IRQ_TX_EMPTY_R (crate :: FieldReader < bool , bool >) ; impl IRQ_TX_EMPTY_R { pub (crate) fn new (bits : bool) -> Self { IRQ_TX_EMPTY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_TX_EMPTY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IRQ_TX_CTS` reader - TX CTS Change Interrupt"]
pub struct IRQ_TX_CTS_R (crate :: FieldReader < bool , bool >) ; impl IRQ_TX_CTS_R { pub (crate) fn new (bits : bool) -> Self { IRQ_TX_CTS_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IRQ_TX_CTS_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - RX Interrupt"]
# [inline (always)]
pub fn irq_rx (& self) -> IRQ_RX_R { IRQ_RX_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - RX Status Interrupt"]
# [inline (always)]
pub fn irq_rx_status (& self) -> IRQ_RX_STATUS_R { IRQ_RX_STATUS_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - RX Timeout Interrupt"]
# [inline (always)]
pub fn irq_rx_to (& self) -> IRQ_RX_TO_R { IRQ_RX_TO_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 4 - TX Interrupt"]
# [inline (always)]
pub fn irq_tx (& self) -> IRQ_TX_R { IRQ_TX_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - TX Status Interrupt"]
# [inline (always)]
pub fn irq_tx_status (& self) -> IRQ_TX_STATUS_R { IRQ_TX_STATUS_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - TX Empty Interrupt"]
# [inline (always)]
pub fn irq_tx_empty (& self) -> IRQ_TX_EMPTY_R { IRQ_TX_EMPTY_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - TX CTS Change Interrupt"]
# [inline (always)]
pub fn irq_tx_cts (& self) -> IRQ_TX_CTS_R { IRQ_TX_CTS_R :: new (((self . bits >> 7) & 0x01) != 0) } } # [doc = "IRQ Enabled Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_end](index.html) module"]
pub struct IRQ_END_SPEC ; impl crate :: RegisterSpec for IRQ_END_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_end::R](R) reader structure"]
impl crate :: Readable for IRQ_END_SPEC { type Reader = R ; } # [doc = "`reset()` method sets IRQ_END to value 0"]
impl crate :: Resettable for IRQ_END_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_CLR register accessor: an alias for `Reg<IRQ_CLR_SPEC>`"]
pub type IRQ_CLR = crate :: Reg < irq_clr :: IRQ_CLR_SPEC > ; # [doc = "IRQ Clear Status Register"]
pub mod irq_clr { # [doc = "Register `IRQ_CLR` writer"]
pub struct W (crate :: W < IRQ_CLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IRQ_CLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IRQ_CLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IRQ_CLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `IRQ_RX` writer - RX Interrupt"]
pub struct IRQ_RX_W < 'a > { w : & 'a mut W , } impl < 'a > IRQ_RX_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `IRQ_RX_STATUS` writer - RX Status Interrupt"]
pub struct IRQ_RX_STATUS_W < 'a > { w : & 'a mut W , } impl < 'a > IRQ_RX_STATUS_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `IRQ_RX_TO` writer - RX Timeout Interrupt"]
pub struct IRQ_RX_TO_W < 'a > { w : & 'a mut W , } impl < 'a > IRQ_RX_TO_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `IRQ_TX` writer - TX Interrupt"]
pub struct IRQ_TX_W < 'a > { w : & 'a mut W , } impl < 'a > IRQ_TX_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 4)) | ((value as u32 & 0x01) << 4) ; self . w } } # [doc = "Field `IRQ_TX_STATUS` writer - TX Status Interrupt"]
pub struct IRQ_TX_STATUS_W < 'a > { w : & 'a mut W , } impl < 'a > IRQ_TX_STATUS_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 5)) | ((value as u32 & 0x01) << 5) ; self . w } } # [doc = "Field `IRQ_TX_EMPTY` writer - TX Empty Interrupt"]
pub struct IRQ_TX_EMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > IRQ_TX_EMPTY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | ((value as u32 & 0x01) << 6) ; self . w } } # [doc = "Field `IRQ_TX_CTS` writer - TX CTS Change Interrupt"]
pub struct IRQ_TX_CTS_W < 'a > { w : & 'a mut W , } impl < 'a > IRQ_TX_CTS_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | ((value as u32 & 0x01) << 7) ; self . w } } impl W { # [doc = "Bit 0 - RX Interrupt"]
# [inline (always)]
pub fn irq_rx (& mut self) -> IRQ_RX_W { IRQ_RX_W { w : self } } # [doc = "Bit 1 - RX Status Interrupt"]
# [inline (always)]
pub fn irq_rx_status (& mut self) -> IRQ_RX_STATUS_W { IRQ_RX_STATUS_W { w : self } } # [doc = "Bit 2 - RX Timeout Interrupt"]
# [inline (always)]
pub fn irq_rx_to (& mut self) -> IRQ_RX_TO_W { IRQ_RX_TO_W { w : self } } # [doc = "Bit 4 - TX Interrupt"]
# [inline (always)]
pub fn irq_tx (& mut self) -> IRQ_TX_W { IRQ_TX_W { w : self } } # [doc = "Bit 5 - TX Status Interrupt"]
# [inline (always)]
pub fn irq_tx_status (& mut self) -> IRQ_TX_STATUS_W { IRQ_TX_STATUS_W { w : self } } # [doc = "Bit 6 - TX Empty Interrupt"]
# [inline (always)]
pub fn irq_tx_empty (& mut self) -> IRQ_TX_EMPTY_W { IRQ_TX_EMPTY_W { w : self } } # [doc = "Bit 7 - TX CTS Change Interrupt"]
# [inline (always)]
pub fn irq_tx_cts (& mut self) -> IRQ_TX_CTS_W { IRQ_TX_CTS_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "IRQ Clear Status Register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_clr](index.html) module"]
pub struct IRQ_CLR_SPEC ; impl crate :: RegisterSpec for IRQ_CLR_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [irq_clr::W](W) writer structure"]
impl crate :: Writable for IRQ_CLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets IRQ_CLR to value 0"]
impl crate :: Resettable for IRQ_CLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RXFIFOIRQTRG register accessor: an alias for `Reg<RXFIFOIRQTRG_SPEC>`"]
pub type RXFIFOIRQTRG = crate :: Reg < rxfifoirqtrg :: RXFIFOIRQTRG_SPEC > ; # [doc = "Rx FIFO IRQ Trigger Level"]
pub mod rxfifoirqtrg { # [doc = "Register `RXFIFOIRQTRG` reader"]
pub struct R (crate :: R < RXFIFOIRQTRG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXFIFOIRQTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXFIFOIRQTRG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXFIFOIRQTRG_SPEC >) -> Self { R (reader) } } # [doc = "Register `RXFIFOIRQTRG` writer"]
pub struct W (crate :: W < RXFIFOIRQTRG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RXFIFOIRQTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RXFIFOIRQTRG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RXFIFOIRQTRG_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Rx FIFO IRQ Trigger Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxfifoirqtrg](index.html) module"]
pub struct RXFIFOIRQTRG_SPEC ; impl crate :: RegisterSpec for RXFIFOIRQTRG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rxfifoirqtrg::R](R) reader structure"]
impl crate :: Readable for RXFIFOIRQTRG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rxfifoirqtrg::W](W) writer structure"]
impl crate :: Writable for RXFIFOIRQTRG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RXFIFOIRQTRG to value 0"]
impl crate :: Resettable for RXFIFOIRQTRG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TXFIFOIRQTRG register accessor: an alias for `Reg<TXFIFOIRQTRG_SPEC>`"]
pub type TXFIFOIRQTRG = crate :: Reg < txfifoirqtrg :: TXFIFOIRQTRG_SPEC > ; # [doc = "Tx FIFO IRQ Trigger Level"]
pub mod txfifoirqtrg { # [doc = "Register `TXFIFOIRQTRG` reader"]
pub struct R (crate :: R < TXFIFOIRQTRG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXFIFOIRQTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXFIFOIRQTRG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXFIFOIRQTRG_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXFIFOIRQTRG` writer"]
pub struct W (crate :: W < TXFIFOIRQTRG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXFIFOIRQTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXFIFOIRQTRG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXFIFOIRQTRG_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Tx FIFO IRQ Trigger Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txfifoirqtrg](index.html) module"]
pub struct TXFIFOIRQTRG_SPEC ; impl crate :: RegisterSpec for TXFIFOIRQTRG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [txfifoirqtrg::R](R) reader structure"]
impl crate :: Readable for TXFIFOIRQTRG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txfifoirqtrg::W](W) writer structure"]
impl crate :: Writable for TXFIFOIRQTRG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TXFIFOIRQTRG to value 0"]
impl crate :: Resettable for TXFIFOIRQTRG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RXFIFORTSTRG register accessor: an alias for `Reg<RXFIFORTSTRG_SPEC>`"]
pub type RXFIFORTSTRG = crate :: Reg < rxfifortstrg :: RXFIFORTSTRG_SPEC > ; # [doc = "Rx FIFO RTS Trigger Level"]
pub mod rxfifortstrg { # [doc = "Register `RXFIFORTSTRG` reader"]
pub struct R (crate :: R < RXFIFORTSTRG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXFIFORTSTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXFIFORTSTRG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXFIFORTSTRG_SPEC >) -> Self { R (reader) } } # [doc = "Register `RXFIFORTSTRG` writer"]
pub struct W (crate :: W < RXFIFORTSTRG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RXFIFORTSTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RXFIFORTSTRG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RXFIFORTSTRG_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Rx FIFO RTS Trigger Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxfifortstrg](index.html) module"]
pub struct RXFIFORTSTRG_SPEC ; impl crate :: RegisterSpec for RXFIFORTSTRG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rxfifortstrg::R](R) reader structure"]
impl crate :: Readable for RXFIFORTSTRG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rxfifortstrg::W](W) writer structure"]
impl crate :: Writable for RXFIFORTSTRG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RXFIFORTSTRG to value 0"]
impl crate :: Resettable for RXFIFORTSTRG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATE register accessor: an alias for `Reg<STATE_SPEC>`"]
pub type STATE = crate :: Reg < state :: STATE_SPEC > ; # [doc = "Internal STATE of UART Controller"]
pub mod state { # [doc = "Register `STATE` reader"]
pub struct R (crate :: R < STATE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATE_SPEC >) -> Self { R (reader) } } # [doc = "Internal STATE of UART Controller\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [state](index.html) module"]
pub struct STATE_SPEC ; impl crate :: RegisterSpec for STATE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [state::R](R) reader structure"]
impl crate :: Readable for STATE_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATE to value 0"]
impl crate :: Resettable for STATE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PERID register accessor: an alias for `Reg<PERID_SPEC>`"]
pub type PERID = crate :: Reg < perid :: PERID_SPEC > ; # [doc = "Peripheral ID Register"]
pub mod perid { # [doc = "Register `PERID` reader"]
pub struct R (crate :: R < PERID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERID_SPEC >) -> Self { R (reader) } } # [doc = "Peripheral ID Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perid](index.html) module"]
pub struct PERID_SPEC ; impl crate :: RegisterSpec for PERID_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [perid::R](R) reader structure"]
impl crate :: Readable for PERID_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PERID to value 0x0012_07e1"]
impl crate :: Resettable for PERID_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x0012_07e1 } } } } # [doc = "UART Peripheral"]
pub struct UARTB { _marker : PhantomData < * const () > } unsafe impl Send for UARTB { } impl UARTB { # [doc = r"Pointer to the register block"]
pub const PTR : * const uarta :: RegisterBlock = 0x4004_1000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const uarta :: RegisterBlock { Self :: PTR } } impl Deref for UARTB { type Target = uarta :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for UARTB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("UARTB") . finish () } } # [doc = "SPI Peripheral"]
pub struct SPIA { _marker : PhantomData < * const () > } unsafe impl Send for SPIA { } impl SPIA { # [doc = r"Pointer to the register block"]
pub const PTR : * const spia :: RegisterBlock = 0x4005_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const spia :: RegisterBlock { Self :: PTR } } impl Deref for SPIA { type Target = spia :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SPIA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SPIA") . finish () } } # [doc = "SPI Peripheral"]
pub mod spia { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register 0"]
pub ctrl0 : crate :: Reg < ctrl0 :: CTRL0_SPEC > , # [doc = "0x04 - Control Register 1"]
pub ctrl1 : crate :: Reg < ctrl1 :: CTRL1_SPEC > , # [doc = "0x08 - Data Input/Output"]
pub data : crate :: Reg < data :: DATA_SPEC > , # [doc = "0x0c - Status Register"]
pub status : crate :: Reg < status :: STATUS_SPEC > , # [doc = "0x10 - Clock Pre Scale divide value"]
pub clkprescale : crate :: Reg < clkprescale :: CLKPRESCALE_SPEC > , # [doc = "0x14 - Interrupt Enable Register"]
pub irq_enb : crate :: Reg < irq_enb :: IRQ_ENB_SPEC > , # [doc = "0x18 - Raw Interrupt Status Register"]
pub irq_raw : crate :: Reg < irq_raw :: IRQ_RAW_SPEC > , # [doc = "0x1c - Enabled Interrupt Status Register"]
pub irq_end : crate :: Reg < irq_end :: IRQ_END_SPEC > , # [doc = "0x20 - Clear Interrupt Status Register"]
pub irq_clr : crate :: Reg < irq_clr :: IRQ_CLR_SPEC > , # [doc = "0x24 - Rx FIFO IRQ Trigger Level"]
pub rxfifoirqtrg : crate :: Reg < rxfifoirqtrg :: RXFIFOIRQTRG_SPEC > , # [doc = "0x28 - Tx FIFO IRQ Trigger Level"]
pub txfifoirqtrg : crate :: Reg < txfifoirqtrg :: TXFIFOIRQTRG_SPEC > , # [doc = "0x2c - Clear FIFO Register"]
pub fifo_clr : crate :: Reg < fifo_clr :: FIFO_CLR_SPEC > , # [doc = "0x30 - Internal STATE of SPI Controller"]
pub state : crate :: Reg < state :: STATE_SPEC > , _reserved13 : [u8 ; 0x0fc8]
, # [doc = "0xffc - Peripheral ID Register"]
pub perid : crate :: Reg < perid :: PERID_SPEC > , } # [doc = "CTRL0 register accessor: an alias for `Reg<CTRL0_SPEC>`"]
pub type CTRL0 = crate :: Reg < ctrl0 :: CTRL0_SPEC > ; # [doc = "Control Register 0"]
pub mod ctrl0 { # [doc = "Register `CTRL0` reader"]
pub struct R (crate :: R < CTRL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL0` writer"]
pub struct W (crate :: W < CTRL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `SIZE` reader - Data Size(0x3=>4, 0xf=>16)"]
pub struct SIZE_R (crate :: FieldReader < u8 , u8 >) ; impl SIZE_R { pub (crate) fn new (bits : u8) -> Self { SIZE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for SIZE_R { type Target = crate :: FieldReader < u8 , u8 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `SIZE` writer - Data Size(0x3=>4, 0xf=>16)"]
pub struct SIZE_W < 'a > { w : & 'a mut W , } impl < 'a > SIZE_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x0f) | (value as u32 & 0x0f) ; self . w } } # [doc = "Field `SPO` reader - SPI Clock Polarity"]
pub struct SPO_R (crate :: FieldReader < bool , bool >) ; impl SPO_R { pub (crate) fn new (bits : bool) -> Self { SPO_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for SPO_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `SPO` writer - SPI Clock Polarity"]
pub struct SPO_W < 'a > { w : & 'a mut W , } impl < 'a > SPO_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | ((value as u32 & 0x01) << 6) ; self . w } } # [doc = "Field `SPH` reader - SPI Clock Phase"]
pub struct SPH_R (crate :: FieldReader < bool , bool >) ; impl SPH_R { pub (crate) fn new (bits : bool) -> Self { SPH_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for SPH_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `SPH` writer - SPI Clock Phase"]
pub struct SPH_W < 'a > { w : & 'a mut W , } impl < 'a > SPH_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | ((value as u32 & 0x01) << 7) ; self . w } } # [doc = "Field `SCRDV` reader - Serial Clock Rate divide+1 value"]
pub struct SCRDV_R (crate :: FieldReader < u8 , u8 >) ; impl SCRDV_R { pub (crate) fn new (bits : u8) -> Self { SCRDV_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for SCRDV_R { type Target = crate :: FieldReader < u8 , u8 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `SCRDV` writer - Serial Clock Rate divide+1 value"]
pub struct SCRDV_W < 'a > { w : & 'a mut W , } impl < 'a > SCRDV_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0xff << 8)) | ((value as u32 & 0xff) << 8) ; self . w } } impl R { # [doc = "Bits 0:3 - Data Size(0x3=>4, 0xf=>16)"]
# [inline (always)]
pub fn size (& self) -> SIZE_R { SIZE_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bit 6 - SPI Clock Polarity"]
# [inline (always)]
pub fn spo (& self) -> SPO_R { SPO_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - SPI Clock Phase"]
# [inline (always)]
pub fn sph (& self) -> SPH_R { SPH_R :: new (((self . bits >> 7) & 0x01) != 0) } # [doc = "Bits 8:15 - Serial Clock Rate divide+1 value"]
# [inline (always)]
pub fn scrdv (& self) -> SCRDV_R { SCRDV_R :: new (((self . bits >> 8) & 0xff) as u8) } } impl W { # [doc = "Bits 0:3 - Data Size(0x3=>4, 0xf=>16)"]
# [inline (always)]
pub fn size (& mut self) -> SIZE_W { SIZE_W { w : self } } # [doc = "Bit 6 - SPI Clock Polarity"]
# [inline (always)]
pub fn spo (& mut self) -> SPO_W { SPO_W { w : self } } # [doc = "Bit 7 - SPI Clock Phase"]
# [inline (always)]
pub fn sph (& mut self) -> SPH_W { SPH_W { w : self } } # [doc = "Bits 8:15 - Serial Clock Rate divide+1 value"]
# [inline (always)]
pub fn scrdv (& mut self) -> SCRDV_W { SCRDV_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl0](index.html) module"]
pub struct CTRL0_SPEC ; impl crate :: RegisterSpec for CTRL0_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ctrl0::R](R) reader structure"]
impl crate :: Readable for CTRL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl0::W](W) writer structure"]
impl crate :: Writable for CTRL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRL0 to value 0"]
impl crate :: Resettable for CTRL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRL1 register accessor: an alias for `Reg<CTRL1_SPEC>`"]
pub type CTRL1 = crate :: Reg < ctrl1 :: CTRL1_SPEC > ; # [doc = "Control Register 1"]
pub mod ctrl1 { # [doc = "Register `CTRL1` reader"]
pub struct R (crate :: R < CTRL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL1` writer"]
pub struct W (crate :: W < CTRL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL1_SPEC >) -> Self { W (writer) } } # [doc = "Field `LBM` reader - Loop Back"]
pub struct LBM_R (crate :: FieldReader < bool , bool >) ; impl LBM_R { pub (crate) fn new (bits : bool) -> Self { LBM_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for LBM_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `LBM` writer - Loop Back"]
pub struct LBM_W < 'a > { w : & 'a mut W , } impl < 'a > LBM_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `ENABLE` reader - Enable"]
pub struct ENABLE_R (crate :: FieldReader < bool , bool >) ; impl ENABLE_R { pub (crate) fn new (bits : bool) -> Self { ENABLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ENABLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ENABLE` writer - Enable"]
pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `MS` reader - Master/Slave (0:Master, 1:Slave)"]
pub struct MS_R (crate :: FieldReader < bool , bool >) ; impl MS_R { pub (crate) fn new (bits : bool) -> Self { MS_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for MS_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `MS` writer - Master/Slave (0:Master, 1:Slave)"]
pub struct MS_W < 'a > { w : & 'a mut W , } impl < 'a > MS_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `SOD` reader - Slave output Disable"]
pub struct SOD_R (crate :: FieldReader < bool , bool >) ; impl SOD_R { pub (crate) fn new (bits : bool) -> Self { SOD_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for SOD_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `SOD` writer - Slave output Disable"]
pub struct SOD_W < 'a > { w : & 'a mut W , } impl < 'a > SOD_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } # [doc = "Field `SS` reader - Slave Select"]
pub struct SS_R (crate :: FieldReader < u8 , u8 >) ; impl SS_R { pub (crate) fn new (bits : u8) -> Self { SS_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for SS_R { type Target = crate :: FieldReader < u8 , u8 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `SS` writer - Slave Select"]
pub struct SS_W < 'a > { w : & 'a mut W , } impl < 'a > SS_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x07 << 4)) | ((value as u32 & 0x07) << 4) ; self . w } } # [doc = "Field `BLOCKMODE` reader - Block Mode Enable"]
pub struct BLOCKMODE_R (crate :: FieldReader < bool , bool >) ; impl BLOCKMODE_R { pub (crate) fn new (bits : bool) -> Self { BLOCKMODE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for BLOCKMODE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `BLOCKMODE` writer - Block Mode Enable"]
pub struct BLOCKMODE_W < 'a > { w : & 'a mut W , } impl < 'a > BLOCKMODE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | ((value as u32 & 0x01) << 7) ; self . w } } # [doc = "Field `BMSTART` reader - Block Mode Start Status Enable"]
pub struct BMSTART_R (crate :: FieldReader < bool , bool >) ; impl BMSTART_R { pub (crate) fn new (bits : bool) -> Self { BMSTART_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for BMSTART_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `BMSTART` writer - Block Mode Start Status Enable"]
pub struct BMSTART_W < 'a > { w : & 'a mut W , } impl < 'a > BMSTART_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 8)) | ((value as u32 & 0x01) << 8) ; self . w } } # [doc = "Field `BMSTALL` reader - Block Mode Stall Enable"]
pub struct BMSTALL_R (crate :: FieldReader < bool , bool >) ; impl BMSTALL_R { pub (crate) fn new (bits : bool) -> Self { BMSTALL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for BMSTALL_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `BMSTALL` writer - Block Mode Stall Enable"]
pub struct BMSTALL_W < 'a > { w : & 'a mut W , } impl < 'a > BMSTALL_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 9)) | ((value as u32 & 0x01) << 9) ; self . w } } # [doc = "Field `MDLYCAP` reader - Master Delayed Capture Enable"]
pub struct MDLYCAP_R (crate :: FieldReader < bool , bool >) ; impl MDLYCAP_R { pub (crate) fn new (bits : bool) -> Self { MDLYCAP_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for MDLYCAP_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `MDLYCAP` writer - Master Delayed Capture Enable"]
pub struct MDLYCAP_W < 'a > { w : & 'a mut W , } impl < 'a > MDLYCAP_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 10)) | ((value as u32 & 0x01) << 10) ; self . w } } # [doc = "Field `MTXPAUSE` reader - Master Tx Pause Enable"]
pub struct MTXPAUSE_R (crate :: FieldReader < bool , bool >) ; impl MTXPAUSE_R { pub (crate) fn new (bits : bool) -> Self { MTXPAUSE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for MTXPAUSE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `MTXPAUSE` writer - Master Tx Pause Enable"]
pub struct MTXPAUSE_W < 'a > { w : & 'a mut W , } impl < 'a > MTXPAUSE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 11)) | ((value as u32 & 0x01) << 11) ; self . w } } impl R { # [doc = "Bit 0 - Loop Back"]
# [inline (always)]
pub fn lbm (& self) -> LBM_R { LBM_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - Master/Slave (0:Master, 1:Slave)"]
# [inline (always)]
pub fn ms (& self) -> MS_R { MS_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - Slave output Disable"]
# [inline (always)]
pub fn sod (& self) -> SOD_R { SOD_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bits 4:6 - Slave Select"]
# [inline (always)]
pub fn ss (& self) -> SS_R { SS_R :: new (((self . bits >> 4) & 0x07) as u8) } # [doc = "Bit 7 - Block Mode Enable"]
# [inline (always)]
pub fn blockmode (& self) -> BLOCKMODE_R { BLOCKMODE_R :: new (((self . bits >> 7) & 0x01) != 0) } # [doc = "Bit 8 - Block Mode Start Status Enable"]
# [inline (always)]
pub fn bmstart (& self) -> BMSTART_R { BMSTART_R :: new (((self . bits >> 8) & 0x01) != 0) } # [doc = "Bit 9 - Block Mode Stall Enable"]
# [inline (always)]
pub fn bmstall (& self) -> BMSTALL_R { BMSTALL_R :: new (((self . bits >> 9) & 0x01) != 0) } # [doc = "Bit 10 - Master Delayed Capture Enable"]
# [inline (always)]
pub fn mdlycap (& self) -> MDLYCAP_R { MDLYCAP_R :: new (((self . bits >> 10) & 0x01) != 0) } # [doc = "Bit 11 - Master Tx Pause Enable"]
# [inline (always)]
pub fn mtxpause (& self) -> MTXPAUSE_R { MTXPAUSE_R :: new (((self . bits >> 11) & 0x01) != 0) } } impl W { # [doc = "Bit 0 - Loop Back"]
# [inline (always)]
pub fn lbm (& mut self) -> LBM_W { LBM_W { w : self } } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W { w : self } } # [doc = "Bit 2 - Master/Slave (0:Master, 1:Slave)"]
# [inline (always)]
pub fn ms (& mut self) -> MS_W { MS_W { w : self } } # [doc = "Bit 3 - Slave output Disable"]
# [inline (always)]
pub fn sod (& mut self) -> SOD_W { SOD_W { w : self } } # [doc = "Bits 4:6 - Slave Select"]
# [inline (always)]
pub fn ss (& mut self) -> SS_W { SS_W { w : self } } # [doc = "Bit 7 - Block Mode Enable"]
# [inline (always)]
pub fn blockmode (& mut self) -> BLOCKMODE_W { BLOCKMODE_W { w : self } } # [doc = "Bit 8 - Block Mode Start Status Enable"]
# [inline (always)]
pub fn bmstart (& mut self) -> BMSTART_W { BMSTART_W { w : self } } # [doc = "Bit 9 - Block Mode Stall Enable"]
# [inline (always)]
pub fn bmstall (& mut self) -> BMSTALL_W { BMSTALL_W { w : self } } # [doc = "Bit 10 - Master Delayed Capture Enable"]
# [inline (always)]
pub fn mdlycap (& mut self) -> MDLYCAP_W { MDLYCAP_W { w : self } } # [doc = "Bit 11 - Master Tx Pause Enable"]
# [inline (always)]
pub fn mtxpause (& mut self) -> MTXPAUSE_W { MTXPAUSE_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl1](index.html) module"]
pub struct CTRL1_SPEC ; impl crate :: RegisterSpec for CTRL1_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ctrl1::R](R) reader structure"]
impl crate :: Readable for CTRL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl1::W](W) writer structure"]
impl crate :: Writable for CTRL1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRL1 to value 0"]
impl crate :: Resettable for CTRL1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATA register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data Input/Output"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Input/Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `TFE` reader - Transmit FIFO empty"]
pub struct TFE_R (crate :: FieldReader < bool , bool >) ; impl TFE_R { pub (crate) fn new (bits : bool) -> Self { TFE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TFE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TNF` reader - Transmit FIFO not full"]
pub struct TNF_R (crate :: FieldReader < bool , bool >) ; impl TNF_R { pub (crate) fn new (bits : bool) -> Self { TNF_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TNF_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RNE` reader - Receive FIFO not empty"]
pub struct RNE_R (crate :: FieldReader < bool , bool >) ; impl RNE_R { pub (crate) fn new (bits : bool) -> Self { RNE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RNE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RFF` reader - Receive FIFO Full"]
pub struct RFF_R (crate :: FieldReader < bool , bool >) ; impl RFF_R { pub (crate) fn new (bits : bool) -> Self { RFF_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RFF_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `BUSY` reader - Busy"]
pub struct BUSY_R (crate :: FieldReader < bool , bool >) ; impl BUSY_R { pub (crate) fn new (bits : bool) -> Self { BUSY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for BUSY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXDATAFIRST` reader - Pending Data is first Byte in BLOCKMODE"]
pub struct RXDATAFIRST_R (crate :: FieldReader < bool , bool >) ; impl RXDATAFIRST_R { pub (crate) fn new (bits : bool) -> Self { RXDATAFIRST_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXDATAFIRST_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXTRIGGER` reader - RX FIFO Above Trigger Level"]
pub struct RXTRIGGER_R (crate :: FieldReader < bool , bool >) ; impl RXTRIGGER_R { pub (crate) fn new (bits : bool) -> Self { RXTRIGGER_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXTRIGGER_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXTRIGGER` reader - TX FIFO Below Trigger Level"]
pub struct TXTRIGGER_R (crate :: FieldReader < bool , bool >) ; impl TXTRIGGER_R { pub (crate) fn new (bits : bool) -> Self { TXTRIGGER_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXTRIGGER_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - Transmit FIFO empty"]
# [inline (always)]
pub fn tfe (& self) -> TFE_R { TFE_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - Transmit FIFO not full"]
# [inline (always)]
pub fn tnf (& self) -> TNF_R { TNF_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - Receive FIFO not empty"]
# [inline (always)]
pub fn rne (& self) -> RNE_R { RNE_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - Receive FIFO Full"]
# [inline (always)]
pub fn rff (& self) -> RFF_R { RFF_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - Busy"]
# [inline (always)]
pub fn busy (& self) -> BUSY_R { BUSY_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - Pending Data is first Byte in BLOCKMODE"]
# [inline (always)]
pub fn rxdatafirst (& self) -> RXDATAFIRST_R { RXDATAFIRST_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - RX FIFO Above Trigger Level"]
# [inline (always)]
pub fn rxtrigger (& self) -> RXTRIGGER_R { RXTRIGGER_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - TX FIFO Below Trigger Level"]
# [inline (always)]
pub fn txtrigger (& self) -> TXTRIGGER_R { TXTRIGGER_R :: new (((self . bits >> 7) & 0x01) != 0) } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CLKPRESCALE register accessor: an alias for `Reg<CLKPRESCALE_SPEC>`"]
pub type CLKPRESCALE = crate :: Reg < clkprescale :: CLKPRESCALE_SPEC > ; # [doc = "Clock Pre Scale divide value"]
pub mod clkprescale { # [doc = "Register `CLKPRESCALE` reader"]
pub struct R (crate :: R < CLKPRESCALE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CLKPRESCALE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CLKPRESCALE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CLKPRESCALE_SPEC >) -> Self { R (reader) } } # [doc = "Register `CLKPRESCALE` writer"]
pub struct W (crate :: W < CLKPRESCALE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CLKPRESCALE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CLKPRESCALE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CLKPRESCALE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clock Pre Scale divide value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clkprescale](index.html) module"]
pub struct CLKPRESCALE_SPEC ; impl crate :: RegisterSpec for CLKPRESCALE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [clkprescale::R](R) reader structure"]
impl crate :: Readable for CLKPRESCALE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [clkprescale::W](W) writer structure"]
impl crate :: Writable for CLKPRESCALE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CLKPRESCALE to value 0"]
impl crate :: Resettable for CLKPRESCALE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_ENB register accessor: an alias for `Reg<IRQ_ENB_SPEC>`"]
pub type IRQ_ENB = crate :: Reg < irq_enb :: IRQ_ENB_SPEC > ; # [doc = "Interrupt Enable Register"]
pub mod irq_enb { # [doc = "Register `IRQ_ENB` reader"]
pub struct R (crate :: R < IRQ_ENB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_ENB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_ENB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_ENB_SPEC >) -> Self { R (reader) } } # [doc = "Register `IRQ_ENB` writer"]
pub struct W (crate :: W < IRQ_ENB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IRQ_ENB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IRQ_ENB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IRQ_ENB_SPEC >) -> Self { W (writer) } } # [doc = "Field `RORIM` reader - RX Overrun"]
pub struct RORIM_R (crate :: FieldReader < bool , bool >) ; impl RORIM_R { pub (crate) fn new (bits : bool) -> Self { RORIM_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RORIM_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RORIM` writer - RX Overrun"]
pub struct RORIM_W < 'a > { w : & 'a mut W , } impl < 'a > RORIM_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `RTIM` reader - RX Timeout"]
pub struct RTIM_R (crate :: FieldReader < bool , bool >) ; impl RTIM_R { pub (crate) fn new (bits : bool) -> Self { RTIM_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RTIM_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RTIM` writer - RX Timeout"]
pub struct RTIM_W < 'a > { w : & 'a mut W , } impl < 'a > RTIM_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `RXIM` reader - RX Fifo is at least half full"]
pub struct RXIM_R (crate :: FieldReader < bool , bool >) ; impl RXIM_R { pub (crate) fn new (bits : bool) -> Self { RXIM_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXIM_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXIM` writer - RX Fifo is at least half full"]
pub struct RXIM_W < 'a > { w : & 'a mut W , } impl < 'a > RXIM_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `TXIM` reader - TX Fifo is at least half empty"]
pub struct TXIM_R (crate :: FieldReader < bool , bool >) ; impl TXIM_R { pub (crate) fn new (bits : bool) -> Self { TXIM_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXIM_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXIM` writer - TX Fifo is at least half empty"]
pub struct TXIM_W < 'a > { w : & 'a mut W , } impl < 'a > TXIM_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } impl R { # [doc = "Bit 0 - RX Overrun"]
# [inline (always)]
pub fn rorim (& self) -> RORIM_R { RORIM_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - RX Timeout"]
# [inline (always)]
pub fn rtim (& self) -> RTIM_R { RTIM_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - RX Fifo is at least half full"]
# [inline (always)]
pub fn rxim (& self) -> RXIM_R { RXIM_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - TX Fifo is at least half empty"]
# [inline (always)]
pub fn txim (& self) -> TXIM_R { TXIM_R :: new (((self . bits >> 3) & 0x01) != 0) } } impl W { # [doc = "Bit 0 - RX Overrun"]
# [inline (always)]
pub fn rorim (& mut self) -> RORIM_W { RORIM_W { w : self } } # [doc = "Bit 1 - RX Timeout"]
# [inline (always)]
pub fn rtim (& mut self) -> RTIM_W { RTIM_W { w : self } } # [doc = "Bit 2 - RX Fifo is at least half full"]
# [inline (always)]
pub fn rxim (& mut self) -> RXIM_W { RXIM_W { w : self } } # [doc = "Bit 3 - TX Fifo is at least half empty"]
# [inline (always)]
pub fn txim (& mut self) -> TXIM_W { TXIM_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_enb](index.html) module"]
pub struct IRQ_ENB_SPEC ; impl crate :: RegisterSpec for IRQ_ENB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_enb::R](R) reader structure"]
impl crate :: Readable for IRQ_ENB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [irq_enb::W](W) writer structure"]
impl crate :: Writable for IRQ_ENB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets IRQ_ENB to value 0"]
impl crate :: Resettable for IRQ_ENB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_RAW register accessor: an alias for `Reg<IRQ_RAW_SPEC>`"]
pub type IRQ_RAW = crate :: Reg < irq_raw :: IRQ_RAW_SPEC > ; # [doc = "Raw Interrupt Status Register"]
pub mod irq_raw { # [doc = "Register `IRQ_RAW` reader"]
pub struct R (crate :: R < IRQ_RAW_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_RAW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_RAW_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_RAW_SPEC >) -> Self { R (reader) } } # [doc = "Field `RORIM` reader - RX Overrun"]
pub struct RORIM_R (crate :: FieldReader < bool , bool >) ; impl RORIM_R { pub (crate) fn new (bits : bool) -> Self { RORIM_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RORIM_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RTIM` reader - RX Timeout"]
pub struct RTIM_R (crate :: FieldReader < bool , bool >) ; impl RTIM_R { pub (crate) fn new (bits : bool) -> Self { RTIM_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RTIM_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXIM` reader - RX Fifo is at least half full"]
pub struct RXIM_R (crate :: FieldReader < bool , bool >) ; impl RXIM_R { pub (crate) fn new (bits : bool) -> Self { RXIM_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXIM_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXIM` reader - TX Fifo is at least half empty"]
pub struct TXIM_R (crate :: FieldReader < bool , bool >) ; impl TXIM_R { pub (crate) fn new (bits : bool) -> Self { TXIM_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXIM_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - RX Overrun"]
# [inline (always)]
pub fn rorim (& self) -> RORIM_R { RORIM_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - RX Timeout"]
# [inline (always)]
pub fn rtim (& self) -> RTIM_R { RTIM_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - RX Fifo is at least half full"]
# [inline (always)]
pub fn rxim (& self) -> RXIM_R { RXIM_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - TX Fifo is at least half empty"]
# [inline (always)]
pub fn txim (& self) -> TXIM_R { TXIM_R :: new (((self . bits >> 3) & 0x01) != 0) } } # [doc = "Raw Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_raw](index.html) module"]
pub struct IRQ_RAW_SPEC ; impl crate :: RegisterSpec for IRQ_RAW_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_raw::R](R) reader structure"]
impl crate :: Readable for IRQ_RAW_SPEC { type Reader = R ; } # [doc = "`reset()` method sets IRQ_RAW to value 0"]
impl crate :: Resettable for IRQ_RAW_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_END register accessor: an alias for `Reg<IRQ_END_SPEC>`"]
pub type IRQ_END = crate :: Reg < irq_end :: IRQ_END_SPEC > ; # [doc = "Enabled Interrupt Status Register"]
pub mod irq_end { # [doc = "Register `IRQ_END` reader"]
pub struct R (crate :: R < IRQ_END_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_END_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_END_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_END_SPEC >) -> Self { R (reader) } } # [doc = "Field `RORIM` reader - RX Overrun"]
pub struct RORIM_R (crate :: FieldReader < bool , bool >) ; impl RORIM_R { pub (crate) fn new (bits : bool) -> Self { RORIM_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RORIM_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RTIM` reader - RX Timeout"]
pub struct RTIM_R (crate :: FieldReader < bool , bool >) ; impl RTIM_R { pub (crate) fn new (bits : bool) -> Self { RTIM_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RTIM_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXIM` reader - RX Fifo is at least half full"]
pub struct RXIM_R (crate :: FieldReader < bool , bool >) ; impl RXIM_R { pub (crate) fn new (bits : bool) -> Self { RXIM_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXIM_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXIM` reader - TX Fifo is at least half empty"]
pub struct TXIM_R (crate :: FieldReader < bool , bool >) ; impl TXIM_R { pub (crate) fn new (bits : bool) -> Self { TXIM_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXIM_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - RX Overrun"]
# [inline (always)]
pub fn rorim (& self) -> RORIM_R { RORIM_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - RX Timeout"]
# [inline (always)]
pub fn rtim (& self) -> RTIM_R { RTIM_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - RX Fifo is at least half full"]
# [inline (always)]
pub fn rxim (& self) -> RXIM_R { RXIM_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - TX Fifo is at least half empty"]
# [inline (always)]
pub fn txim (& self) -> TXIM_R { TXIM_R :: new (((self . bits >> 3) & 0x01) != 0) } } # [doc = "Enabled Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_end](index.html) module"]
pub struct IRQ_END_SPEC ; impl crate :: RegisterSpec for IRQ_END_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_end::R](R) reader structure"]
impl crate :: Readable for IRQ_END_SPEC { type Reader = R ; } # [doc = "`reset()` method sets IRQ_END to value 0"]
impl crate :: Resettable for IRQ_END_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_CLR register accessor: an alias for `Reg<IRQ_CLR_SPEC>`"]
pub type IRQ_CLR = crate :: Reg < irq_clr :: IRQ_CLR_SPEC > ; # [doc = "Clear Interrupt Status Register"]
pub mod irq_clr { # [doc = "Register `IRQ_CLR` writer"]
pub struct W (crate :: W < IRQ_CLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IRQ_CLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IRQ_CLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IRQ_CLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `RORIM` writer - RX Overrun"]
pub struct RORIM_W < 'a > { w : & 'a mut W , } impl < 'a > RORIM_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `RTIM` writer - RX Timeout"]
pub struct RTIM_W < 'a > { w : & 'a mut W , } impl < 'a > RTIM_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `RXIM` writer - RX Fifo is at least half full"]
pub struct RXIM_W < 'a > { w : & 'a mut W , } impl < 'a > RXIM_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `TXIM` writer - TX Fifo is at least half empty"]
pub struct TXIM_W < 'a > { w : & 'a mut W , } impl < 'a > TXIM_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } impl W { # [doc = "Bit 0 - RX Overrun"]
# [inline (always)]
pub fn rorim (& mut self) -> RORIM_W { RORIM_W { w : self } } # [doc = "Bit 1 - RX Timeout"]
# [inline (always)]
pub fn rtim (& mut self) -> RTIM_W { RTIM_W { w : self } } # [doc = "Bit 2 - RX Fifo is at least half full"]
# [inline (always)]
pub fn rxim (& mut self) -> RXIM_W { RXIM_W { w : self } } # [doc = "Bit 3 - TX Fifo is at least half empty"]
# [inline (always)]
pub fn txim (& mut self) -> TXIM_W { TXIM_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clear Interrupt Status Register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_clr](index.html) module"]
pub struct IRQ_CLR_SPEC ; impl crate :: RegisterSpec for IRQ_CLR_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [irq_clr::W](W) writer structure"]
impl crate :: Writable for IRQ_CLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets IRQ_CLR to value 0"]
impl crate :: Resettable for IRQ_CLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RXFIFOIRQTRG register accessor: an alias for `Reg<RXFIFOIRQTRG_SPEC>`"]
pub type RXFIFOIRQTRG = crate :: Reg < rxfifoirqtrg :: RXFIFOIRQTRG_SPEC > ; # [doc = "Rx FIFO IRQ Trigger Level"]
pub mod rxfifoirqtrg { # [doc = "Register `RXFIFOIRQTRG` reader"]
pub struct R (crate :: R < RXFIFOIRQTRG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXFIFOIRQTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXFIFOIRQTRG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXFIFOIRQTRG_SPEC >) -> Self { R (reader) } } # [doc = "Register `RXFIFOIRQTRG` writer"]
pub struct W (crate :: W < RXFIFOIRQTRG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RXFIFOIRQTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RXFIFOIRQTRG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RXFIFOIRQTRG_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Rx FIFO IRQ Trigger Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxfifoirqtrg](index.html) module"]
pub struct RXFIFOIRQTRG_SPEC ; impl crate :: RegisterSpec for RXFIFOIRQTRG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rxfifoirqtrg::R](R) reader structure"]
impl crate :: Readable for RXFIFOIRQTRG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rxfifoirqtrg::W](W) writer structure"]
impl crate :: Writable for RXFIFOIRQTRG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RXFIFOIRQTRG to value 0"]
impl crate :: Resettable for RXFIFOIRQTRG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TXFIFOIRQTRG register accessor: an alias for `Reg<TXFIFOIRQTRG_SPEC>`"]
pub type TXFIFOIRQTRG = crate :: Reg < txfifoirqtrg :: TXFIFOIRQTRG_SPEC > ; # [doc = "Tx FIFO IRQ Trigger Level"]
pub mod txfifoirqtrg { # [doc = "Register `TXFIFOIRQTRG` reader"]
pub struct R (crate :: R < TXFIFOIRQTRG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXFIFOIRQTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXFIFOIRQTRG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXFIFOIRQTRG_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXFIFOIRQTRG` writer"]
pub struct W (crate :: W < TXFIFOIRQTRG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXFIFOIRQTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXFIFOIRQTRG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXFIFOIRQTRG_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Tx FIFO IRQ Trigger Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txfifoirqtrg](index.html) module"]
pub struct TXFIFOIRQTRG_SPEC ; impl crate :: RegisterSpec for TXFIFOIRQTRG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [txfifoirqtrg::R](R) reader structure"]
impl crate :: Readable for TXFIFOIRQTRG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txfifoirqtrg::W](W) writer structure"]
impl crate :: Writable for TXFIFOIRQTRG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TXFIFOIRQTRG to value 0"]
impl crate :: Resettable for TXFIFOIRQTRG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "FIFO_CLR register accessor: an alias for `Reg<FIFO_CLR_SPEC>`"]
pub type FIFO_CLR = crate :: Reg < fifo_clr :: FIFO_CLR_SPEC > ; # [doc = "Clear FIFO Register"]
pub mod fifo_clr { # [doc = "Register `FIFO_CLR` writer"]
pub struct W (crate :: W < FIFO_CLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FIFO_CLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FIFO_CLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FIFO_CLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXFIFO` writer - Clear Rx FIFO"]
pub struct RXFIFO_W < 'a > { w : & 'a mut W , } impl < 'a > RXFIFO_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `TXFIFO` writer - Clear Tx FIFO"]
pub struct TXFIFO_W < 'a > { w : & 'a mut W , } impl < 'a > TXFIFO_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } impl W { # [doc = "Bit 0 - Clear Rx FIFO"]
# [inline (always)]
pub fn rxfifo (& mut self) -> RXFIFO_W { RXFIFO_W { w : self } } # [doc = "Bit 1 - Clear Tx FIFO"]
# [inline (always)]
pub fn txfifo (& mut self) -> TXFIFO_W { TXFIFO_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clear FIFO Register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fifo_clr](index.html) module"]
pub struct FIFO_CLR_SPEC ; impl crate :: RegisterSpec for FIFO_CLR_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [fifo_clr::W](W) writer structure"]
impl crate :: Writable for FIFO_CLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets FIFO_CLR to value 0"]
impl crate :: Resettable for FIFO_CLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATE register accessor: an alias for `Reg<STATE_SPEC>`"]
pub type STATE = crate :: Reg < state :: STATE_SPEC > ; # [doc = "Internal STATE of SPI Controller"]
pub mod state { # [doc = "Register `STATE` reader"]
pub struct R (crate :: R < STATE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATE_SPEC >) -> Self { R (reader) } } # [doc = "Internal STATE of SPI Controller\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [state](index.html) module"]
pub struct STATE_SPEC ; impl crate :: RegisterSpec for STATE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [state::R](R) reader structure"]
impl crate :: Readable for STATE_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATE to value 0"]
impl crate :: Resettable for STATE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PERID register accessor: an alias for `Reg<PERID_SPEC>`"]
pub type PERID = crate :: Reg < perid :: PERID_SPEC > ; # [doc = "Peripheral ID Register"]
pub mod perid { # [doc = "Register `PERID` reader"]
pub struct R (crate :: R < PERID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERID_SPEC >) -> Self { R (reader) } } # [doc = "Peripheral ID Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perid](index.html) module"]
pub struct PERID_SPEC ; impl crate :: RegisterSpec for PERID_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [perid::R](R) reader structure"]
impl crate :: Readable for PERID_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PERID to value 0x0012_07e1"]
impl crate :: Resettable for PERID_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x0012_07e1 } } } } # [doc = "SPI Peripheral"]
pub struct SPIB { _marker : PhantomData < * const () > } unsafe impl Send for SPIB { } impl SPIB { # [doc = r"Pointer to the register block"]
pub const PTR : * const spia :: RegisterBlock = 0x4005_1000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const spia :: RegisterBlock { Self :: PTR } } impl Deref for SPIB { type Target = spia :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SPIB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SPIB") . finish () } } # [doc = "SPI Peripheral"]
pub struct SPIC { _marker : PhantomData < * const () > } unsafe impl Send for SPIC { } impl SPIC { # [doc = r"Pointer to the register block"]
pub const PTR : * const spia :: RegisterBlock = 0x4005_2000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const spia :: RegisterBlock { Self :: PTR } } impl Deref for SPIC { type Target = spia :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SPIC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SPIC") . finish () } } # [doc = "I2C Peripheral"]
pub struct I2CA { _marker : PhantomData < * const () > } unsafe impl Send for I2CA { } impl I2CA { # [doc = r"Pointer to the register block"]
pub const PTR : * const i2ca :: RegisterBlock = 0x4006_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const i2ca :: RegisterBlock { Self :: PTR } } impl Deref for I2CA { type Target = i2ca :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for I2CA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2CA") . finish () } } # [doc = "I2C Peripheral"]
pub mod i2ca { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrl : crate :: Reg < ctrl :: CTRL_SPEC > , # [doc = "0x04 - Clock Scale divide value"]
pub clkscale : crate :: Reg < clkscale :: CLKSCALE_SPEC > , # [doc = "0x08 - Word Count value"]
pub words : crate :: Reg < words :: WORDS_SPEC > , # [doc = "0x0c - I2C Address value"]
pub address : crate :: Reg < address :: ADDRESS_SPEC > , # [doc = "0x10 - Data Input/Output"]
pub data : crate :: Reg < data :: DATA_SPEC > , # [doc = "0x14 - Command Register"]
pub cmd : crate :: Reg < cmd :: CMD_SPEC > , # [doc = "0x18 - I2C Controller Status Register"]
pub status : crate :: Reg < status :: STATUS_SPEC > , # [doc = "0x1c - Internal STATE of I2C Master Controller"]
pub state : crate :: Reg < state :: STATE_SPEC > , # [doc = "0x20 - TX Count Register"]
pub txcount : crate :: Reg < txcount :: TXCOUNT_SPEC > , # [doc = "0x24 - RX Count Register"]
pub rxcount : crate :: Reg < rxcount :: RXCOUNT_SPEC > , # [doc = "0x28 - Interrupt Enable Register"]
pub irq_enb : crate :: Reg < irq_enb :: IRQ_ENB_SPEC > , # [doc = "0x2c - Raw Interrupt Status Register"]
pub irq_raw : crate :: Reg < irq_raw :: IRQ_RAW_SPEC > , # [doc = "0x30 - Enabled Interrupt Status Register"]
pub irq_end : crate :: Reg < irq_end :: IRQ_END_SPEC > , # [doc = "0x34 - Clear Interrupt Status Register"]
pub irq_clr : crate :: Reg < irq_clr :: IRQ_CLR_SPEC > , # [doc = "0x38 - Rx FIFO IRQ Trigger Level"]
pub rxfifoirqtrg : crate :: Reg < rxfifoirqtrg :: RXFIFOIRQTRG_SPEC > , # [doc = "0x3c - Tx FIFO IRQ Trigger Level"]
pub txfifoirqtrg : crate :: Reg < txfifoirqtrg :: TXFIFOIRQTRG_SPEC > , # [doc = "0x40 - Clear FIFO Register"]
pub fifo_clr : crate :: Reg < fifo_clr :: FIFO_CLR_SPEC > , # [doc = "0x44 - Timing Config Register"]
pub tmconfig : crate :: Reg < tmconfig :: TMCONFIG_SPEC > , # [doc = "0x48 - Clock Low Timeout Limit Register"]
pub clktolimit : crate :: Reg < clktolimit :: CLKTOLIMIT_SPEC > , _reserved19 : [u8 ; 0xb4]
, # [doc = "0x100 - Slave Control Register"]
pub s0_ctrl : crate :: Reg < s0_ctrl :: S0_CTRL_SPEC > , # [doc = "0x104 - Slave MaxWords Register"]
pub s0_maxwords : crate :: Reg < s0_maxwords :: S0_MAXWORDS_SPEC > , # [doc = "0x108 - Slave I2C Address Value"]
pub s0_address : crate :: Reg < s0_address :: S0_ADDRESS_SPEC > , # [doc = "0x10c - Slave I2C Address Mask value"]
pub s0_addressmask : crate :: Reg < s0_addressmask :: S0_ADDRESSMASK_SPEC > , # [doc = "0x110 - Slave Data Input/Output"]
pub s0_data : crate :: Reg < s0_data :: S0_DATA_SPEC > , # [doc = "0x114 - Slave I2C Last Address value"]
pub s0_lastaddress : crate :: Reg < s0_lastaddress :: S0_LASTADDRESS_SPEC > , # [doc = "0x118 - Slave I2C Controller Status Register"]
pub s0_status : crate :: Reg < s0_status :: S0_STATUS_SPEC > , # [doc = "0x11c - Internal STATE of I2C Slave Controller"]
pub s0_state : crate :: Reg < s0_state :: S0_STATE_SPEC > , # [doc = "0x120 - Slave TX Count Register"]
pub s0_txcount : crate :: Reg < s0_txcount :: S0_TXCOUNT_SPEC > , # [doc = "0x124 - Slave RX Count Register"]
pub s0_rxcount : crate :: Reg < s0_rxcount :: S0_RXCOUNT_SPEC > , # [doc = "0x128 - Slave Interrupt Enable Register"]
pub s0_irq_enb : crate :: Reg < s0_irq_enb :: S0_IRQ_ENB_SPEC > , # [doc = "0x12c - Slave Raw Interrupt Status Register"]
pub s0_irq_raw : crate :: Reg < s0_irq_raw :: S0_IRQ_RAW_SPEC > , # [doc = "0x130 - Slave Enabled Interrupt Status Register"]
pub s0_irq_end : crate :: Reg < s0_irq_end :: S0_IRQ_END_SPEC > , # [doc = "0x134 - Slave Clear Interrupt Status Register"]
pub s0_irq_clr : crate :: Reg < s0_irq_clr :: S0_IRQ_CLR_SPEC > , # [doc = "0x138 - Slave Rx FIFO IRQ Trigger Level"]
pub s0_rxfifoirqtrg : crate :: Reg < s0_rxfifoirqtrg :: S0_RXFIFOIRQTRG_SPEC > , # [doc = "0x13c - Slave Tx FIFO IRQ Trigger Level"]
pub s0_txfifoirqtrg : crate :: Reg < s0_txfifoirqtrg :: S0_TXFIFOIRQTRG_SPEC > , # [doc = "0x140 - Slave Clear FIFO Register"]
pub s0_fifo_clr : crate :: Reg < s0_fifo_clr :: S0_FIFO_CLR_SPEC > , # [doc = "0x144 - Slave I2C Address B Value"]
pub s0_addressb : crate :: Reg < s0_addressb :: S0_ADDRESSB_SPEC > , # [doc = "0x148 - Slave I2C Address B Mask value"]
pub s0_addressmaskb : crate :: Reg < s0_addressmaskb :: S0_ADDRESSMASKB_SPEC > , _reserved38 : [u8 ; 0x0eb0]
, # [doc = "0xffc - Peripheral ID Register"]
pub perid : crate :: Reg < perid :: PERID_SPEC > , } # [doc = "CTRL register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CLKENABLED` reader - I2C CLK Enabled"]
pub struct CLKENABLED_R (crate :: FieldReader < bool , bool >) ; impl CLKENABLED_R { pub (crate) fn new (bits : bool) -> Self { CLKENABLED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for CLKENABLED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `CLKENABLED` writer - I2C CLK Enabled"]
pub struct CLKENABLED_W < 'a > { w : & 'a mut W , } impl < 'a > CLKENABLED_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `ENABLED` reader - I2C Activated"]
pub struct ENABLED_R (crate :: FieldReader < bool , bool >) ; impl ENABLED_R { pub (crate) fn new (bits : bool) -> Self { ENABLED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ENABLED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ENABLED` writer - I2C Activated"]
pub struct ENABLED_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLED_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `ENABLE` reader - I2C Active"]
pub struct ENABLE_R (crate :: FieldReader < bool , bool >) ; impl ENABLE_R { pub (crate) fn new (bits : bool) -> Self { ENABLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ENABLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ENABLE` writer - I2C Active"]
pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `TXFEMD` reader - TX FIFIO Empty Mode"]
pub struct TXFEMD_R (crate :: FieldReader < bool , bool >) ; impl TXFEMD_R { pub (crate) fn new (bits : bool) -> Self { TXFEMD_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXFEMD_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXFEMD` writer - TX FIFIO Empty Mode"]
pub struct TXFEMD_W < 'a > { w : & 'a mut W , } impl < 'a > TXFEMD_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } # [doc = "Field `RXFFMD` reader - RX FIFO Full Mode"]
pub struct RXFFMD_R (crate :: FieldReader < bool , bool >) ; impl RXFFMD_R { pub (crate) fn new (bits : bool) -> Self { RXFFMD_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXFFMD_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXFFMD` writer - RX FIFO Full Mode"]
pub struct RXFFMD_W < 'a > { w : & 'a mut W , } impl < 'a > RXFFMD_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 4)) | ((value as u32 & 0x01) << 4) ; self . w } } # [doc = "Field `ALGFILTER` reader - Enable Input Analog Glitch Filter"]
pub struct ALGFILTER_R (crate :: FieldReader < bool , bool >) ; impl ALGFILTER_R { pub (crate) fn new (bits : bool) -> Self { ALGFILTER_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ALGFILTER_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ALGFILTER` writer - Enable Input Analog Glitch Filter"]
pub struct ALGFILTER_W < 'a > { w : & 'a mut W , } impl < 'a > ALGFILTER_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 5)) | ((value as u32 & 0x01) << 5) ; self . w } } # [doc = "Field `DLGFILTER` reader - Enable Input Digital Glitch Filter"]
pub struct DLGFILTER_R (crate :: FieldReader < bool , bool >) ; impl DLGFILTER_R { pub (crate) fn new (bits : bool) -> Self { DLGFILTER_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for DLGFILTER_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `DLGFILTER` writer - Enable Input Digital Glitch Filter"]
pub struct DLGFILTER_W < 'a > { w : & 'a mut W , } impl < 'a > DLGFILTER_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | ((value as u32 & 0x01) << 6) ; self . w } } # [doc = "Field `LOOPBACK` reader - Enable LoopBack Mode"]
pub struct LOOPBACK_R (crate :: FieldReader < bool , bool >) ; impl LOOPBACK_R { pub (crate) fn new (bits : bool) -> Self { LOOPBACK_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for LOOPBACK_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `LOOPBACK` writer - Enable LoopBack Mode"]
pub struct LOOPBACK_W < 'a > { w : & 'a mut W , } impl < 'a > LOOPBACK_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 8)) | ((value as u32 & 0x01) << 8) ; self . w } } # [doc = "Field `TMCONFIGENB` reader - Enable Timing Config Register"]
pub struct TMCONFIGENB_R (crate :: FieldReader < bool , bool >) ; impl TMCONFIGENB_R { pub (crate) fn new (bits : bool) -> Self { TMCONFIGENB_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TMCONFIGENB_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TMCONFIGENB` writer - Enable Timing Config Register"]
pub struct TMCONFIGENB_W < 'a > { w : & 'a mut W , } impl < 'a > TMCONFIGENB_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 9)) | ((value as u32 & 0x01) << 9) ; self . w } } impl R { # [doc = "Bit 0 - I2C CLK Enabled"]
# [inline (always)]
pub fn clkenabled (& self) -> CLKENABLED_R { CLKENABLED_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - I2C Activated"]
# [inline (always)]
pub fn enabled (& self) -> ENABLED_R { ENABLED_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - I2C Active"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - TX FIFIO Empty Mode"]
# [inline (always)]
pub fn txfemd (& self) -> TXFEMD_R { TXFEMD_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - RX FIFO Full Mode"]
# [inline (always)]
pub fn rxffmd (& self) -> RXFFMD_R { RXFFMD_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - Enable Input Analog Glitch Filter"]
# [inline (always)]
pub fn algfilter (& self) -> ALGFILTER_R { ALGFILTER_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - Enable Input Digital Glitch Filter"]
# [inline (always)]
pub fn dlgfilter (& self) -> DLGFILTER_R { DLGFILTER_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 8 - Enable LoopBack Mode"]
# [inline (always)]
pub fn loopback (& self) -> LOOPBACK_R { LOOPBACK_R :: new (((self . bits >> 8) & 0x01) != 0) } # [doc = "Bit 9 - Enable Timing Config Register"]
# [inline (always)]
pub fn tmconfigenb (& self) -> TMCONFIGENB_R { TMCONFIGENB_R :: new (((self . bits >> 9) & 0x01) != 0) } } impl W { # [doc = "Bit 0 - I2C CLK Enabled"]
# [inline (always)]
pub fn clkenabled (& mut self) -> CLKENABLED_W { CLKENABLED_W { w : self } } # [doc = "Bit 1 - I2C Activated"]
# [inline (always)]
pub fn enabled (& mut self) -> ENABLED_W { ENABLED_W { w : self } } # [doc = "Bit 2 - I2C Active"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W { w : self } } # [doc = "Bit 3 - TX FIFIO Empty Mode"]
# [inline (always)]
pub fn txfemd (& mut self) -> TXFEMD_W { TXFEMD_W { w : self } } # [doc = "Bit 4 - RX FIFO Full Mode"]
# [inline (always)]
pub fn rxffmd (& mut self) -> RXFFMD_W { RXFFMD_W { w : self } } # [doc = "Bit 5 - Enable Input Analog Glitch Filter"]
# [inline (always)]
pub fn algfilter (& mut self) -> ALGFILTER_W { ALGFILTER_W { w : self } } # [doc = "Bit 6 - Enable Input Digital Glitch Filter"]
# [inline (always)]
pub fn dlgfilter (& mut self) -> DLGFILTER_W { DLGFILTER_W { w : self } } # [doc = "Bit 8 - Enable LoopBack Mode"]
# [inline (always)]
pub fn loopback (& mut self) -> LOOPBACK_W { LOOPBACK_W { w : self } } # [doc = "Bit 9 - Enable Timing Config Register"]
# [inline (always)]
pub fn tmconfigenb (& mut self) -> TMCONFIGENB_W { TMCONFIGENB_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CLKSCALE register accessor: an alias for `Reg<CLKSCALE_SPEC>`"]
pub type CLKSCALE = crate :: Reg < clkscale :: CLKSCALE_SPEC > ; # [doc = "Clock Scale divide value"]
pub mod clkscale { # [doc = "Register `CLKSCALE` reader"]
pub struct R (crate :: R < CLKSCALE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CLKSCALE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CLKSCALE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CLKSCALE_SPEC >) -> Self { R (reader) } } # [doc = "Register `CLKSCALE` writer"]
pub struct W (crate :: W < CLKSCALE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CLKSCALE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CLKSCALE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CLKSCALE_SPEC >) -> Self { W (writer) } } # [doc = "Field `VALUE` reader - Enable FastMode"]
pub struct VALUE_R (crate :: FieldReader < u32 , u32 >) ; impl VALUE_R { pub (crate) fn new (bits : u32) -> Self { VALUE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for VALUE_R { type Target = crate :: FieldReader < u32 , u32 > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `VALUE` writer - Enable FastMode"]
pub struct VALUE_W < 'a > { w : & 'a mut W , } impl < 'a > VALUE_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u32) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x7fff_ffff) | (value as u32 & 0x7fff_ffff) ; self . w } } # [doc = "Field `FASTMODE` reader - Enable FastMode"]
pub struct FASTMODE_R (crate :: FieldReader < bool , bool >) ; impl FASTMODE_R { pub (crate) fn new (bits : bool) -> Self { FASTMODE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for FASTMODE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `FASTMODE` writer - Enable FastMode"]
pub struct FASTMODE_W < 'a > { w : & 'a mut W , } impl < 'a > FASTMODE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 31)) | ((value as u32 & 0x01) << 31) ; self . w } } impl R { # [doc = "Bits 0:30 - Enable FastMode"]
# [inline (always)]
pub fn value (& self) -> VALUE_R { VALUE_R :: new ((self . bits & 0x7fff_ffff) as u32) } # [doc = "Bit 31 - Enable FastMode"]
# [inline (always)]
pub fn fastmode (& self) -> FASTMODE_R { FASTMODE_R :: new (((self . bits >> 31) & 0x01) != 0) } } impl W { # [doc = "Bits 0:30 - Enable FastMode"]
# [inline (always)]
pub fn value (& mut self) -> VALUE_W { VALUE_W { w : self } } # [doc = "Bit 31 - Enable FastMode"]
# [inline (always)]
pub fn fastmode (& mut self) -> FASTMODE_W { FASTMODE_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clock Scale divide value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clkscale](index.html) module"]
pub struct CLKSCALE_SPEC ; impl crate :: RegisterSpec for CLKSCALE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [clkscale::R](R) reader structure"]
impl crate :: Readable for CLKSCALE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [clkscale::W](W) writer structure"]
impl crate :: Writable for CLKSCALE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CLKSCALE to value 0"]
impl crate :: Resettable for CLKSCALE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "WORDS register accessor: an alias for `Reg<WORDS_SPEC>`"]
pub type WORDS = crate :: Reg < words :: WORDS_SPEC > ; # [doc = "Word Count value"]
pub mod words { # [doc = "Register `WORDS` reader"]
pub struct R (crate :: R < WORDS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WORDS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WORDS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WORDS_SPEC >) -> Self { R (reader) } } # [doc = "Register `WORDS` writer"]
pub struct W (crate :: W < WORDS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WORDS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WORDS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WORDS_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Word Count value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [words](index.html) module"]
pub struct WORDS_SPEC ; impl crate :: RegisterSpec for WORDS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [words::R](R) reader structure"]
impl crate :: Readable for WORDS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [words::W](W) writer structure"]
impl crate :: Writable for WORDS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets WORDS to value 0"]
impl crate :: Resettable for WORDS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ADDRESS register accessor: an alias for `Reg<ADDRESS_SPEC>`"]
pub type ADDRESS = crate :: Reg < address :: ADDRESS_SPEC > ; # [doc = "I2C Address value"]
pub mod address { # [doc = "Register `ADDRESS` reader"]
pub struct R (crate :: R < ADDRESS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADDRESS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADDRESS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADDRESS_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADDRESS` writer"]
pub struct W (crate :: W < ADDRESS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADDRESS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADDRESS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADDRESS_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2C Address value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [address](index.html) module"]
pub struct ADDRESS_SPEC ; impl crate :: RegisterSpec for ADDRESS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [address::R](R) reader structure"]
impl crate :: Readable for ADDRESS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [address::W](W) writer structure"]
impl crate :: Writable for ADDRESS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADDRESS to value 0"]
impl crate :: Resettable for ADDRESS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATA register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data Input/Output"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Input/Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CMD register accessor: an alias for `Reg<CMD_SPEC>`"]
pub type CMD = crate :: Reg < cmd :: CMD_SPEC > ; # [doc = "Command Register"]
pub mod cmd { # [doc = "Register `CMD` reader"]
pub struct R (crate :: R < CMD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CMD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CMD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CMD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMD` writer"]
pub struct W (crate :: W < CMD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CMD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CMD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CMD_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Command Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmd](index.html) module"]
pub struct CMD_SPEC ; impl crate :: RegisterSpec for CMD_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cmd::R](R) reader structure"]
impl crate :: Readable for CMD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cmd::W](W) writer structure"]
impl crate :: Writable for CMD_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CMD to value 0"]
impl crate :: Resettable for CMD_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "I2C Controller Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `WAITING` reader - Controller is Waiting"]
pub struct WAITING_R (crate :: FieldReader < bool , bool >) ; impl WAITING_R { pub (crate) fn new (bits : bool) -> Self { WAITING_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for WAITING_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `WAITING` writer - Controller is Waiting"]
pub struct WAITING_W < 'a > { w : & 'a mut W , } impl < 'a > WAITING_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `STALLED` reader - Controller is Stalled"]
pub struct STALLED_R (crate :: FieldReader < bool , bool >) ; impl STALLED_R { pub (crate) fn new (bits : bool) -> Self { STALLED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for STALLED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `STALLED` writer - Controller is Stalled"]
pub struct STALLED_W < 'a > { w : & 'a mut W , } impl < 'a > STALLED_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } # [doc = "Field `ARBLOST` reader - I2C Arbitration was lost"]
pub struct ARBLOST_R (crate :: FieldReader < bool , bool >) ; impl ARBLOST_R { pub (crate) fn new (bits : bool) -> Self { ARBLOST_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ARBLOST_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ARBLOST` writer - I2C Arbitration was lost"]
pub struct ARBLOST_W < 'a > { w : & 'a mut W , } impl < 'a > ARBLOST_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 4)) | ((value as u32 & 0x01) << 4) ; self . w } } # [doc = "Field `NACKADDR` reader - I2C Address was not Acknowledged"]
pub struct NACKADDR_R (crate :: FieldReader < bool , bool >) ; impl NACKADDR_R { pub (crate) fn new (bits : bool) -> Self { NACKADDR_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for NACKADDR_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `NACKADDR` writer - I2C Address was not Acknowledged"]
pub struct NACKADDR_W < 'a > { w : & 'a mut W , } impl < 'a > NACKADDR_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 5)) | ((value as u32 & 0x01) << 5) ; self . w } } # [doc = "Field `NACKDATA` reader - I2C Data was not Acknowledged"]
pub struct NACKDATA_R (crate :: FieldReader < bool , bool >) ; impl NACKDATA_R { pub (crate) fn new (bits : bool) -> Self { NACKDATA_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for NACKDATA_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `NACKDATA` writer - I2C Data was not Acknowledged"]
pub struct NACKDATA_W < 'a > { w : & 'a mut W , } impl < 'a > NACKDATA_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | ((value as u32 & 0x01) << 6) ; self . w } } # [doc = "Field `RXNEMPTY` reader - RX FIFO is Not Empty"]
pub struct RXNEMPTY_R (crate :: FieldReader < bool , bool >) ; impl RXNEMPTY_R { pub (crate) fn new (bits : bool) -> Self { RXNEMPTY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXNEMPTY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXNEMPTY` writer - RX FIFO is Not Empty"]
pub struct RXNEMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > RXNEMPTY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 8)) | ((value as u32 & 0x01) << 8) ; self . w } } # [doc = "Field `RXFULL` reader - RX FIFO is Full"]
pub struct RXFULL_R (crate :: FieldReader < bool , bool >) ; impl RXFULL_R { pub (crate) fn new (bits : bool) -> Self { RXFULL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXFULL_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXFULL` writer - RX FIFO is Full"]
pub struct RXFULL_W < 'a > { w : & 'a mut W , } impl < 'a > RXFULL_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 9)) | ((value as u32 & 0x01) << 9) ; self . w } } # [doc = "Field `RXTRIGGER` reader - RX FIFO Above Trigger Level"]
pub struct RXTRIGGER_R (crate :: FieldReader < bool , bool >) ; impl RXTRIGGER_R { pub (crate) fn new (bits : bool) -> Self { RXTRIGGER_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXTRIGGER_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXTRIGGER` writer - RX FIFO Above Trigger Level"]
pub struct RXTRIGGER_W < 'a > { w : & 'a mut W , } impl < 'a > RXTRIGGER_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 11)) | ((value as u32 & 0x01) << 11) ; self . w } } # [doc = "Field `TXEMPTY` reader - TX FIFO is Empty"]
pub struct TXEMPTY_R (crate :: FieldReader < bool , bool >) ; impl TXEMPTY_R { pub (crate) fn new (bits : bool) -> Self { TXEMPTY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXEMPTY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXEMPTY` writer - TX FIFO is Empty"]
pub struct TXEMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > TXEMPTY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 12)) | ((value as u32 & 0x01) << 12) ; self . w } } # [doc = "Field `TXNFULL` reader - TX FIFO is Full"]
pub struct TXNFULL_R (crate :: FieldReader < bool , bool >) ; impl TXNFULL_R { pub (crate) fn new (bits : bool) -> Self { TXNFULL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXNFULL_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXNFULL` writer - TX FIFO is Full"]
pub struct TXNFULL_W < 'a > { w : & 'a mut W , } impl < 'a > TXNFULL_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 13)) | ((value as u32 & 0x01) << 13) ; self . w } } # [doc = "Field `TXTRIGGER` reader - TX FIFO Below Trigger Level"]
pub struct TXTRIGGER_R (crate :: FieldReader < bool , bool >) ; impl TXTRIGGER_R { pub (crate) fn new (bits : bool) -> Self { TXTRIGGER_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXTRIGGER_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXTRIGGER` writer - TX FIFO Below Trigger Level"]
pub struct TXTRIGGER_W < 'a > { w : & 'a mut W , } impl < 'a > TXTRIGGER_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 15)) | ((value as u32 & 0x01) << 15) ; self . w } } # [doc = "Field `RAW_SDA` reader - I2C Raw SDA value"]
pub struct RAW_SDA_R (crate :: FieldReader < bool , bool >) ; impl RAW_SDA_R { pub (crate) fn new (bits : bool) -> Self { RAW_SDA_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RAW_SDA_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RAW_SDA` writer - I2C Raw SDA value"]
pub struct RAW_SDA_W < 'a > { w : & 'a mut W , } impl < 'a > RAW_SDA_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 30)) | ((value as u32 & 0x01) << 30) ; self . w } } # [doc = "Field `RAW_SCL` reader - I2C Raw SCL value"]
pub struct RAW_SCL_R (crate :: FieldReader < bool , bool >) ; impl RAW_SCL_R { pub (crate) fn new (bits : bool) -> Self { RAW_SCL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RAW_SCL_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RAW_SCL` writer - I2C Raw SCL value"]
pub struct RAW_SCL_W < 'a > { w : & 'a mut W , } impl < 'a > RAW_SCL_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 31)) | ((value as u32 & 0x01) << 31) ; self . w } } impl R { # [doc = "Bit 2 - Controller is Waiting"]
# [inline (always)]
pub fn waiting (& self) -> WAITING_R { WAITING_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - Controller is Stalled"]
# [inline (always)]
pub fn stalled (& self) -> STALLED_R { STALLED_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - I2C Arbitration was lost"]
# [inline (always)]
pub fn arblost (& self) -> ARBLOST_R { ARBLOST_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - I2C Address was not Acknowledged"]
# [inline (always)]
pub fn nackaddr (& self) -> NACKADDR_R { NACKADDR_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - I2C Data was not Acknowledged"]
# [inline (always)]
pub fn nackdata (& self) -> NACKDATA_R { NACKDATA_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 8 - RX FIFO is Not Empty"]
# [inline (always)]
pub fn rxnempty (& self) -> RXNEMPTY_R { RXNEMPTY_R :: new (((self . bits >> 8) & 0x01) != 0) } # [doc = "Bit 9 - RX FIFO is Full"]
# [inline (always)]
pub fn rxfull (& self) -> RXFULL_R { RXFULL_R :: new (((self . bits >> 9) & 0x01) != 0) } # [doc = "Bit 11 - RX FIFO Above Trigger Level"]
# [inline (always)]
pub fn rxtrigger (& self) -> RXTRIGGER_R { RXTRIGGER_R :: new (((self . bits >> 11) & 0x01) != 0) } # [doc = "Bit 12 - TX FIFO is Empty"]
# [inline (always)]
pub fn txempty (& self) -> TXEMPTY_R { TXEMPTY_R :: new (((self . bits >> 12) & 0x01) != 0) } # [doc = "Bit 13 - TX FIFO is Full"]
# [inline (always)]
pub fn txnfull (& self) -> TXNFULL_R { TXNFULL_R :: new (((self . bits >> 13) & 0x01) != 0) } # [doc = "Bit 15 - TX FIFO Below Trigger Level"]
# [inline (always)]
pub fn txtrigger (& self) -> TXTRIGGER_R { TXTRIGGER_R :: new (((self . bits >> 15) & 0x01) != 0) } # [doc = "Bit 30 - I2C Raw SDA value"]
# [inline (always)]
pub fn raw_sda (& self) -> RAW_SDA_R { RAW_SDA_R :: new (((self . bits >> 30) & 0x01) != 0) } # [doc = "Bit 31 - I2C Raw SCL value"]
# [inline (always)]
pub fn raw_scl (& self) -> RAW_SCL_R { RAW_SCL_R :: new (((self . bits >> 31) & 0x01) != 0) } } impl W { # [doc = "Bit 2 - Controller is Waiting"]
# [inline (always)]
pub fn waiting (& mut self) -> WAITING_W { WAITING_W { w : self } } # [doc = "Bit 3 - Controller is Stalled"]
# [inline (always)]
pub fn stalled (& mut self) -> STALLED_W { STALLED_W { w : self } } # [doc = "Bit 4 - I2C Arbitration was lost"]
# [inline (always)]
pub fn arblost (& mut self) -> ARBLOST_W { ARBLOST_W { w : self } } # [doc = "Bit 5 - I2C Address was not Acknowledged"]
# [inline (always)]
pub fn nackaddr (& mut self) -> NACKADDR_W { NACKADDR_W { w : self } } # [doc = "Bit 6 - I2C Data was not Acknowledged"]
# [inline (always)]
pub fn nackdata (& mut self) -> NACKDATA_W { NACKDATA_W { w : self } } # [doc = "Bit 8 - RX FIFO is Not Empty"]
# [inline (always)]
pub fn rxnempty (& mut self) -> RXNEMPTY_W { RXNEMPTY_W { w : self } } # [doc = "Bit 9 - RX FIFO is Full"]
# [inline (always)]
pub fn rxfull (& mut self) -> RXFULL_W { RXFULL_W { w : self } } # [doc = "Bit 11 - RX FIFO Above Trigger Level"]
# [inline (always)]
pub fn rxtrigger (& mut self) -> RXTRIGGER_W { RXTRIGGER_W { w : self } } # [doc = "Bit 12 - TX FIFO is Empty"]
# [inline (always)]
pub fn txempty (& mut self) -> TXEMPTY_W { TXEMPTY_W { w : self } } # [doc = "Bit 13 - TX FIFO is Full"]
# [inline (always)]
pub fn txnfull (& mut self) -> TXNFULL_W { TXNFULL_W { w : self } } # [doc = "Bit 15 - TX FIFO Below Trigger Level"]
# [inline (always)]
pub fn txtrigger (& mut self) -> TXTRIGGER_W { TXTRIGGER_W { w : self } } # [doc = "Bit 30 - I2C Raw SDA value"]
# [inline (always)]
pub fn raw_sda (& mut self) -> RAW_SDA_W { RAW_SDA_W { w : self } } # [doc = "Bit 31 - I2C Raw SCL value"]
# [inline (always)]
pub fn raw_scl (& mut self) -> RAW_SCL_W { RAW_SCL_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2C Controller Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATE register accessor: an alias for `Reg<STATE_SPEC>`"]
pub type STATE = crate :: Reg < state :: STATE_SPEC > ; # [doc = "Internal STATE of I2C Master Controller"]
pub mod state { # [doc = "Register `STATE` reader"]
pub struct R (crate :: R < STATE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATE_SPEC >) -> Self { R (reader) } } # [doc = "Internal STATE of I2C Master Controller\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [state](index.html) module"]
pub struct STATE_SPEC ; impl crate :: RegisterSpec for STATE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [state::R](R) reader structure"]
impl crate :: Readable for STATE_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATE to value 0"]
impl crate :: Resettable for STATE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TXCOUNT register accessor: an alias for `Reg<TXCOUNT_SPEC>`"]
pub type TXCOUNT = crate :: Reg < txcount :: TXCOUNT_SPEC > ; # [doc = "TX Count Register"]
pub mod txcount { # [doc = "Register `TXCOUNT` reader"]
pub struct R (crate :: R < TXCOUNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXCOUNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXCOUNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXCOUNT_SPEC >) -> Self { R (reader) } } # [doc = "TX Count Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txcount](index.html) module"]
pub struct TXCOUNT_SPEC ; impl crate :: RegisterSpec for TXCOUNT_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [txcount::R](R) reader structure"]
impl crate :: Readable for TXCOUNT_SPEC { type Reader = R ; } # [doc = "`reset()` method sets TXCOUNT to value 0"]
impl crate :: Resettable for TXCOUNT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RXCOUNT register accessor: an alias for `Reg<RXCOUNT_SPEC>`"]
pub type RXCOUNT = crate :: Reg < rxcount :: RXCOUNT_SPEC > ; # [doc = "RX Count Register"]
pub mod rxcount { # [doc = "Register `RXCOUNT` reader"]
pub struct R (crate :: R < RXCOUNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXCOUNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXCOUNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXCOUNT_SPEC >) -> Self { R (reader) } } # [doc = "RX Count Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxcount](index.html) module"]
pub struct RXCOUNT_SPEC ; impl crate :: RegisterSpec for RXCOUNT_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rxcount::R](R) reader structure"]
impl crate :: Readable for RXCOUNT_SPEC { type Reader = R ; } # [doc = "`reset()` method sets RXCOUNT to value 0"]
impl crate :: Resettable for RXCOUNT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_ENB register accessor: an alias for `Reg<IRQ_ENB_SPEC>`"]
pub type IRQ_ENB = crate :: Reg < irq_enb :: IRQ_ENB_SPEC > ; # [doc = "Interrupt Enable Register"]
pub mod irq_enb { # [doc = "Register `IRQ_ENB` reader"]
pub struct R (crate :: R < IRQ_ENB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_ENB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_ENB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_ENB_SPEC >) -> Self { R (reader) } } # [doc = "Register `IRQ_ENB` writer"]
pub struct W (crate :: W < IRQ_ENB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IRQ_ENB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IRQ_ENB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IRQ_ENB_SPEC >) -> Self { W (writer) } } # [doc = "Field `I2CIDLE` reader - I2C Bus is Idle"]
pub struct I2CIDLE_R (crate :: FieldReader < bool , bool >) ; impl I2CIDLE_R { pub (crate) fn new (bits : bool) -> Self { I2CIDLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for I2CIDLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `I2CIDLE` writer - I2C Bus is Idle"]
pub struct I2CIDLE_W < 'a > { w : & 'a mut W , } impl < 'a > I2CIDLE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `IDLE` reader - Controller is Idle"]
pub struct IDLE_R (crate :: FieldReader < bool , bool >) ; impl IDLE_R { pub (crate) fn new (bits : bool) -> Self { IDLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IDLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IDLE` writer - Controller is Idle"]
pub struct IDLE_W < 'a > { w : & 'a mut W , } impl < 'a > IDLE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `WAITING` reader - Controller is Waiting"]
pub struct WAITING_R (crate :: FieldReader < bool , bool >) ; impl WAITING_R { pub (crate) fn new (bits : bool) -> Self { WAITING_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for WAITING_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `WAITING` writer - Controller is Waiting"]
pub struct WAITING_W < 'a > { w : & 'a mut W , } impl < 'a > WAITING_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `STALLED` reader - Controller is Stalled"]
pub struct STALLED_R (crate :: FieldReader < bool , bool >) ; impl STALLED_R { pub (crate) fn new (bits : bool) -> Self { STALLED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for STALLED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `STALLED` writer - Controller is Stalled"]
pub struct STALLED_W < 'a > { w : & 'a mut W , } impl < 'a > STALLED_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } # [doc = "Field `ARBLOST` reader - I2C Arbitration was lost"]
pub struct ARBLOST_R (crate :: FieldReader < bool , bool >) ; impl ARBLOST_R { pub (crate) fn new (bits : bool) -> Self { ARBLOST_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ARBLOST_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ARBLOST` writer - I2C Arbitration was lost"]
pub struct ARBLOST_W < 'a > { w : & 'a mut W , } impl < 'a > ARBLOST_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 4)) | ((value as u32 & 0x01) << 4) ; self . w } } # [doc = "Field `NACKADDR` reader - I2C Address was not Acknowledged"]
pub struct NACKADDR_R (crate :: FieldReader < bool , bool >) ; impl NACKADDR_R { pub (crate) fn new (bits : bool) -> Self { NACKADDR_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for NACKADDR_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `NACKADDR` writer - I2C Address was not Acknowledged"]
pub struct NACKADDR_W < 'a > { w : & 'a mut W , } impl < 'a > NACKADDR_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 5)) | ((value as u32 & 0x01) << 5) ; self . w } } # [doc = "Field `NACKDATA` reader - I2C Data was not Acknowledged"]
pub struct NACKDATA_R (crate :: FieldReader < bool , bool >) ; impl NACKDATA_R { pub (crate) fn new (bits : bool) -> Self { NACKDATA_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for NACKDATA_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `NACKDATA` writer - I2C Data was not Acknowledged"]
pub struct NACKDATA_W < 'a > { w : & 'a mut W , } impl < 'a > NACKDATA_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | ((value as u32 & 0x01) << 6) ; self . w } } # [doc = "Field `CLKLOTO` reader - I2C Clock Low Timeout"]
pub struct CLKLOTO_R (crate :: FieldReader < bool , bool >) ; impl CLKLOTO_R { pub (crate) fn new (bits : bool) -> Self { CLKLOTO_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for CLKLOTO_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `CLKLOTO` writer - I2C Clock Low Timeout"]
pub struct CLKLOTO_W < 'a > { w : & 'a mut W , } impl < 'a > CLKLOTO_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | ((value as u32 & 0x01) << 7) ; self . w } } # [doc = "Field `TXOVERFLOW` reader - TX FIFO Overflowed"]
pub struct TXOVERFLOW_R (crate :: FieldReader < bool , bool >) ; impl TXOVERFLOW_R { pub (crate) fn new (bits : bool) -> Self { TXOVERFLOW_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXOVERFLOW_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXOVERFLOW` writer - TX FIFO Overflowed"]
pub struct TXOVERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > TXOVERFLOW_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 10)) | ((value as u32 & 0x01) << 10) ; self . w } } # [doc = "Field `RXOVERFLOW` reader - TX FIFO Overflowed"]
pub struct RXOVERFLOW_R (crate :: FieldReader < bool , bool >) ; impl RXOVERFLOW_R { pub (crate) fn new (bits : bool) -> Self { RXOVERFLOW_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXOVERFLOW_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXOVERFLOW` writer - TX FIFO Overflowed"]
pub struct RXOVERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > RXOVERFLOW_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 11)) | ((value as u32 & 0x01) << 11) ; self . w } } # [doc = "Field `TXREADY` reader - TX FIFO Ready"]
pub struct TXREADY_R (crate :: FieldReader < bool , bool >) ; impl TXREADY_R { pub (crate) fn new (bits : bool) -> Self { TXREADY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXREADY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXREADY` writer - TX FIFO Ready"]
pub struct TXREADY_W < 'a > { w : & 'a mut W , } impl < 'a > TXREADY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 12)) | ((value as u32 & 0x01) << 12) ; self . w } } # [doc = "Field `RXREADY` reader - RX FIFO Ready"]
pub struct RXREADY_R (crate :: FieldReader < bool , bool >) ; impl RXREADY_R { pub (crate) fn new (bits : bool) -> Self { RXREADY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXREADY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXREADY` writer - RX FIFO Ready"]
pub struct RXREADY_W < 'a > { w : & 'a mut W , } impl < 'a > RXREADY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 13)) | ((value as u32 & 0x01) << 13) ; self . w } } # [doc = "Field `TXEMPTY` reader - TX FIFO Empty"]
pub struct TXEMPTY_R (crate :: FieldReader < bool , bool >) ; impl TXEMPTY_R { pub (crate) fn new (bits : bool) -> Self { TXEMPTY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXEMPTY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXEMPTY` writer - TX FIFO Empty"]
pub struct TXEMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > TXEMPTY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 14)) | ((value as u32 & 0x01) << 14) ; self . w } } # [doc = "Field `RXFULL` reader - RX FIFO Full"]
pub struct RXFULL_R (crate :: FieldReader < bool , bool >) ; impl RXFULL_R { pub (crate) fn new (bits : bool) -> Self { RXFULL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXFULL_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXFULL` writer - RX FIFO Full"]
pub struct RXFULL_W < 'a > { w : & 'a mut W , } impl < 'a > RXFULL_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 15)) | ((value as u32 & 0x01) << 15) ; self . w } } impl R { # [doc = "Bit 0 - I2C Bus is Idle"]
# [inline (always)]
pub fn i2cidle (& self) -> I2CIDLE_R { I2CIDLE_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - Controller is Idle"]
# [inline (always)]
pub fn idle (& self) -> IDLE_R { IDLE_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - Controller is Waiting"]
# [inline (always)]
pub fn waiting (& self) -> WAITING_R { WAITING_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - Controller is Stalled"]
# [inline (always)]
pub fn stalled (& self) -> STALLED_R { STALLED_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - I2C Arbitration was lost"]
# [inline (always)]
pub fn arblost (& self) -> ARBLOST_R { ARBLOST_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - I2C Address was not Acknowledged"]
# [inline (always)]
pub fn nackaddr (& self) -> NACKADDR_R { NACKADDR_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - I2C Data was not Acknowledged"]
# [inline (always)]
pub fn nackdata (& self) -> NACKDATA_R { NACKDATA_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - I2C Clock Low Timeout"]
# [inline (always)]
pub fn clkloto (& self) -> CLKLOTO_R { CLKLOTO_R :: new (((self . bits >> 7) & 0x01) != 0) } # [doc = "Bit 10 - TX FIFO Overflowed"]
# [inline (always)]
pub fn txoverflow (& self) -> TXOVERFLOW_R { TXOVERFLOW_R :: new (((self . bits >> 10) & 0x01) != 0) } # [doc = "Bit 11 - TX FIFO Overflowed"]
# [inline (always)]
pub fn rxoverflow (& self) -> RXOVERFLOW_R { RXOVERFLOW_R :: new (((self . bits >> 11) & 0x01) != 0) } # [doc = "Bit 12 - TX FIFO Ready"]
# [inline (always)]
pub fn txready (& self) -> TXREADY_R { TXREADY_R :: new (((self . bits >> 12) & 0x01) != 0) } # [doc = "Bit 13 - RX FIFO Ready"]
# [inline (always)]
pub fn rxready (& self) -> RXREADY_R { RXREADY_R :: new (((self . bits >> 13) & 0x01) != 0) } # [doc = "Bit 14 - TX FIFO Empty"]
# [inline (always)]
pub fn txempty (& self) -> TXEMPTY_R { TXEMPTY_R :: new (((self . bits >> 14) & 0x01) != 0) } # [doc = "Bit 15 - RX FIFO Full"]
# [inline (always)]
pub fn rxfull (& self) -> RXFULL_R { RXFULL_R :: new (((self . bits >> 15) & 0x01) != 0) } } impl W { # [doc = "Bit 0 - I2C Bus is Idle"]
# [inline (always)]
pub fn i2cidle (& mut self) -> I2CIDLE_W { I2CIDLE_W { w : self } } # [doc = "Bit 1 - Controller is Idle"]
# [inline (always)]
pub fn idle (& mut self) -> IDLE_W { IDLE_W { w : self } } # [doc = "Bit 2 - Controller is Waiting"]
# [inline (always)]
pub fn waiting (& mut self) -> WAITING_W { WAITING_W { w : self } } # [doc = "Bit 3 - Controller is Stalled"]
# [inline (always)]
pub fn stalled (& mut self) -> STALLED_W { STALLED_W { w : self } } # [doc = "Bit 4 - I2C Arbitration was lost"]
# [inline (always)]
pub fn arblost (& mut self) -> ARBLOST_W { ARBLOST_W { w : self } } # [doc = "Bit 5 - I2C Address was not Acknowledged"]
# [inline (always)]
pub fn nackaddr (& mut self) -> NACKADDR_W { NACKADDR_W { w : self } } # [doc = "Bit 6 - I2C Data was not Acknowledged"]
# [inline (always)]
pub fn nackdata (& mut self) -> NACKDATA_W { NACKDATA_W { w : self } } # [doc = "Bit 7 - I2C Clock Low Timeout"]
# [inline (always)]
pub fn clkloto (& mut self) -> CLKLOTO_W { CLKLOTO_W { w : self } } # [doc = "Bit 10 - TX FIFO Overflowed"]
# [inline (always)]
pub fn txoverflow (& mut self) -> TXOVERFLOW_W { TXOVERFLOW_W { w : self } } # [doc = "Bit 11 - TX FIFO Overflowed"]
# [inline (always)]
pub fn rxoverflow (& mut self) -> RXOVERFLOW_W { RXOVERFLOW_W { w : self } } # [doc = "Bit 12 - TX FIFO Ready"]
# [inline (always)]
pub fn txready (& mut self) -> TXREADY_W { TXREADY_W { w : self } } # [doc = "Bit 13 - RX FIFO Ready"]
# [inline (always)]
pub fn rxready (& mut self) -> RXREADY_W { RXREADY_W { w : self } } # [doc = "Bit 14 - TX FIFO Empty"]
# [inline (always)]
pub fn txempty (& mut self) -> TXEMPTY_W { TXEMPTY_W { w : self } } # [doc = "Bit 15 - RX FIFO Full"]
# [inline (always)]
pub fn rxfull (& mut self) -> RXFULL_W { RXFULL_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_enb](index.html) module"]
pub struct IRQ_ENB_SPEC ; impl crate :: RegisterSpec for IRQ_ENB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_enb::R](R) reader structure"]
impl crate :: Readable for IRQ_ENB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [irq_enb::W](W) writer structure"]
impl crate :: Writable for IRQ_ENB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets IRQ_ENB to value 0"]
impl crate :: Resettable for IRQ_ENB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_RAW register accessor: an alias for `Reg<IRQ_RAW_SPEC>`"]
pub type IRQ_RAW = crate :: Reg < irq_raw :: IRQ_RAW_SPEC > ; # [doc = "Raw Interrupt Status Register"]
pub mod irq_raw { # [doc = "Register `IRQ_RAW` reader"]
pub struct R (crate :: R < IRQ_RAW_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_RAW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_RAW_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_RAW_SPEC >) -> Self { R (reader) } } # [doc = "Field `I2CIDLE` reader - I2C Bus is Idle"]
pub struct I2CIDLE_R (crate :: FieldReader < bool , bool >) ; impl I2CIDLE_R { pub (crate) fn new (bits : bool) -> Self { I2CIDLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for I2CIDLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IDLE` reader - Controller is Idle"]
pub struct IDLE_R (crate :: FieldReader < bool , bool >) ; impl IDLE_R { pub (crate) fn new (bits : bool) -> Self { IDLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IDLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `WAITING` reader - Controller is Waiting"]
pub struct WAITING_R (crate :: FieldReader < bool , bool >) ; impl WAITING_R { pub (crate) fn new (bits : bool) -> Self { WAITING_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for WAITING_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `STALLED` reader - Controller is Stalled"]
pub struct STALLED_R (crate :: FieldReader < bool , bool >) ; impl STALLED_R { pub (crate) fn new (bits : bool) -> Self { STALLED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for STALLED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ARBLOST` reader - I2C Arbitration was lost"]
pub struct ARBLOST_R (crate :: FieldReader < bool , bool >) ; impl ARBLOST_R { pub (crate) fn new (bits : bool) -> Self { ARBLOST_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ARBLOST_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `NACKADDR` reader - I2C Address was not Acknowledged"]
pub struct NACKADDR_R (crate :: FieldReader < bool , bool >) ; impl NACKADDR_R { pub (crate) fn new (bits : bool) -> Self { NACKADDR_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for NACKADDR_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `NACKDATA` reader - I2C Data was not Acknowledged"]
pub struct NACKDATA_R (crate :: FieldReader < bool , bool >) ; impl NACKDATA_R { pub (crate) fn new (bits : bool) -> Self { NACKDATA_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for NACKDATA_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `CLKLOTO` reader - I2C Clock Low Timeout"]
pub struct CLKLOTO_R (crate :: FieldReader < bool , bool >) ; impl CLKLOTO_R { pub (crate) fn new (bits : bool) -> Self { CLKLOTO_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for CLKLOTO_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXOVERFLOW` reader - TX FIFO Overflowed"]
pub struct TXOVERFLOW_R (crate :: FieldReader < bool , bool >) ; impl TXOVERFLOW_R { pub (crate) fn new (bits : bool) -> Self { TXOVERFLOW_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXOVERFLOW_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXOVERFLOW` reader - TX FIFO Overflowed"]
pub struct RXOVERFLOW_R (crate :: FieldReader < bool , bool >) ; impl RXOVERFLOW_R { pub (crate) fn new (bits : bool) -> Self { RXOVERFLOW_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXOVERFLOW_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXREADY` reader - TX FIFO Ready"]
pub struct TXREADY_R (crate :: FieldReader < bool , bool >) ; impl TXREADY_R { pub (crate) fn new (bits : bool) -> Self { TXREADY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXREADY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXREADY` reader - RX FIFO Ready"]
pub struct RXREADY_R (crate :: FieldReader < bool , bool >) ; impl RXREADY_R { pub (crate) fn new (bits : bool) -> Self { RXREADY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXREADY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXEMPTY` reader - TX FIFO Empty"]
pub struct TXEMPTY_R (crate :: FieldReader < bool , bool >) ; impl TXEMPTY_R { pub (crate) fn new (bits : bool) -> Self { TXEMPTY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXEMPTY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXFULL` reader - RX FIFO Full"]
pub struct RXFULL_R (crate :: FieldReader < bool , bool >) ; impl RXFULL_R { pub (crate) fn new (bits : bool) -> Self { RXFULL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXFULL_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - I2C Bus is Idle"]
# [inline (always)]
pub fn i2cidle (& self) -> I2CIDLE_R { I2CIDLE_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - Controller is Idle"]
# [inline (always)]
pub fn idle (& self) -> IDLE_R { IDLE_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - Controller is Waiting"]
# [inline (always)]
pub fn waiting (& self) -> WAITING_R { WAITING_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - Controller is Stalled"]
# [inline (always)]
pub fn stalled (& self) -> STALLED_R { STALLED_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - I2C Arbitration was lost"]
# [inline (always)]
pub fn arblost (& self) -> ARBLOST_R { ARBLOST_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - I2C Address was not Acknowledged"]
# [inline (always)]
pub fn nackaddr (& self) -> NACKADDR_R { NACKADDR_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - I2C Data was not Acknowledged"]
# [inline (always)]
pub fn nackdata (& self) -> NACKDATA_R { NACKDATA_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - I2C Clock Low Timeout"]
# [inline (always)]
pub fn clkloto (& self) -> CLKLOTO_R { CLKLOTO_R :: new (((self . bits >> 7) & 0x01) != 0) } # [doc = "Bit 10 - TX FIFO Overflowed"]
# [inline (always)]
pub fn txoverflow (& self) -> TXOVERFLOW_R { TXOVERFLOW_R :: new (((self . bits >> 10) & 0x01) != 0) } # [doc = "Bit 11 - TX FIFO Overflowed"]
# [inline (always)]
pub fn rxoverflow (& self) -> RXOVERFLOW_R { RXOVERFLOW_R :: new (((self . bits >> 11) & 0x01) != 0) } # [doc = "Bit 12 - TX FIFO Ready"]
# [inline (always)]
pub fn txready (& self) -> TXREADY_R { TXREADY_R :: new (((self . bits >> 12) & 0x01) != 0) } # [doc = "Bit 13 - RX FIFO Ready"]
# [inline (always)]
pub fn rxready (& self) -> RXREADY_R { RXREADY_R :: new (((self . bits >> 13) & 0x01) != 0) } # [doc = "Bit 14 - TX FIFO Empty"]
# [inline (always)]
pub fn txempty (& self) -> TXEMPTY_R { TXEMPTY_R :: new (((self . bits >> 14) & 0x01) != 0) } # [doc = "Bit 15 - RX FIFO Full"]
# [inline (always)]
pub fn rxfull (& self) -> RXFULL_R { RXFULL_R :: new (((self . bits >> 15) & 0x01) != 0) } } # [doc = "Raw Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_raw](index.html) module"]
pub struct IRQ_RAW_SPEC ; impl crate :: RegisterSpec for IRQ_RAW_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_raw::R](R) reader structure"]
impl crate :: Readable for IRQ_RAW_SPEC { type Reader = R ; } # [doc = "`reset()` method sets IRQ_RAW to value 0"]
impl crate :: Resettable for IRQ_RAW_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_END register accessor: an alias for `Reg<IRQ_END_SPEC>`"]
pub type IRQ_END = crate :: Reg < irq_end :: IRQ_END_SPEC > ; # [doc = "Enabled Interrupt Status Register"]
pub mod irq_end { # [doc = "Register `IRQ_END` reader"]
pub struct R (crate :: R < IRQ_END_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_END_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_END_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_END_SPEC >) -> Self { R (reader) } } # [doc = "Field `I2CIDLE` reader - I2C Bus is Idle"]
pub struct I2CIDLE_R (crate :: FieldReader < bool , bool >) ; impl I2CIDLE_R { pub (crate) fn new (bits : bool) -> Self { I2CIDLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for I2CIDLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IDLE` reader - Controller is Idle"]
pub struct IDLE_R (crate :: FieldReader < bool , bool >) ; impl IDLE_R { pub (crate) fn new (bits : bool) -> Self { IDLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IDLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `WAITING` reader - Controller is Waiting"]
pub struct WAITING_R (crate :: FieldReader < bool , bool >) ; impl WAITING_R { pub (crate) fn new (bits : bool) -> Self { WAITING_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for WAITING_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `STALLED` reader - Controller is Stalled"]
pub struct STALLED_R (crate :: FieldReader < bool , bool >) ; impl STALLED_R { pub (crate) fn new (bits : bool) -> Self { STALLED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for STALLED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ARBLOST` reader - I2C Arbitration was lost"]
pub struct ARBLOST_R (crate :: FieldReader < bool , bool >) ; impl ARBLOST_R { pub (crate) fn new (bits : bool) -> Self { ARBLOST_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ARBLOST_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `NACKADDR` reader - I2C Address was not Acknowledged"]
pub struct NACKADDR_R (crate :: FieldReader < bool , bool >) ; impl NACKADDR_R { pub (crate) fn new (bits : bool) -> Self { NACKADDR_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for NACKADDR_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `NACKDATA` reader - I2C Data was not Acknowledged"]
pub struct NACKDATA_R (crate :: FieldReader < bool , bool >) ; impl NACKDATA_R { pub (crate) fn new (bits : bool) -> Self { NACKDATA_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for NACKDATA_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `CLKLOTO` reader - I2C Clock Low Timeout"]
pub struct CLKLOTO_R (crate :: FieldReader < bool , bool >) ; impl CLKLOTO_R { pub (crate) fn new (bits : bool) -> Self { CLKLOTO_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for CLKLOTO_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXOVERFLOW` reader - TX FIFO Overflowed"]
pub struct TXOVERFLOW_R (crate :: FieldReader < bool , bool >) ; impl TXOVERFLOW_R { pub (crate) fn new (bits : bool) -> Self { TXOVERFLOW_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXOVERFLOW_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXOVERFLOW` reader - TX FIFO Overflowed"]
pub struct RXOVERFLOW_R (crate :: FieldReader < bool , bool >) ; impl RXOVERFLOW_R { pub (crate) fn new (bits : bool) -> Self { RXOVERFLOW_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXOVERFLOW_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXREADY` reader - TX FIFO Ready"]
pub struct TXREADY_R (crate :: FieldReader < bool , bool >) ; impl TXREADY_R { pub (crate) fn new (bits : bool) -> Self { TXREADY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXREADY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXREADY` reader - RX FIFO Ready"]
pub struct RXREADY_R (crate :: FieldReader < bool , bool >) ; impl RXREADY_R { pub (crate) fn new (bits : bool) -> Self { RXREADY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXREADY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXEMPTY` reader - TX FIFO Empty"]
pub struct TXEMPTY_R (crate :: FieldReader < bool , bool >) ; impl TXEMPTY_R { pub (crate) fn new (bits : bool) -> Self { TXEMPTY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXEMPTY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXFULL` reader - RX FIFO Full"]
pub struct RXFULL_R (crate :: FieldReader < bool , bool >) ; impl RXFULL_R { pub (crate) fn new (bits : bool) -> Self { RXFULL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXFULL_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - I2C Bus is Idle"]
# [inline (always)]
pub fn i2cidle (& self) -> I2CIDLE_R { I2CIDLE_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - Controller is Idle"]
# [inline (always)]
pub fn idle (& self) -> IDLE_R { IDLE_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - Controller is Waiting"]
# [inline (always)]
pub fn waiting (& self) -> WAITING_R { WAITING_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - Controller is Stalled"]
# [inline (always)]
pub fn stalled (& self) -> STALLED_R { STALLED_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - I2C Arbitration was lost"]
# [inline (always)]
pub fn arblost (& self) -> ARBLOST_R { ARBLOST_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - I2C Address was not Acknowledged"]
# [inline (always)]
pub fn nackaddr (& self) -> NACKADDR_R { NACKADDR_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - I2C Data was not Acknowledged"]
# [inline (always)]
pub fn nackdata (& self) -> NACKDATA_R { NACKDATA_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - I2C Clock Low Timeout"]
# [inline (always)]
pub fn clkloto (& self) -> CLKLOTO_R { CLKLOTO_R :: new (((self . bits >> 7) & 0x01) != 0) } # [doc = "Bit 10 - TX FIFO Overflowed"]
# [inline (always)]
pub fn txoverflow (& self) -> TXOVERFLOW_R { TXOVERFLOW_R :: new (((self . bits >> 10) & 0x01) != 0) } # [doc = "Bit 11 - TX FIFO Overflowed"]
# [inline (always)]
pub fn rxoverflow (& self) -> RXOVERFLOW_R { RXOVERFLOW_R :: new (((self . bits >> 11) & 0x01) != 0) } # [doc = "Bit 12 - TX FIFO Ready"]
# [inline (always)]
pub fn txready (& self) -> TXREADY_R { TXREADY_R :: new (((self . bits >> 12) & 0x01) != 0) } # [doc = "Bit 13 - RX FIFO Ready"]
# [inline (always)]
pub fn rxready (& self) -> RXREADY_R { RXREADY_R :: new (((self . bits >> 13) & 0x01) != 0) } # [doc = "Bit 14 - TX FIFO Empty"]
# [inline (always)]
pub fn txempty (& self) -> TXEMPTY_R { TXEMPTY_R :: new (((self . bits >> 14) & 0x01) != 0) } # [doc = "Bit 15 - RX FIFO Full"]
# [inline (always)]
pub fn rxfull (& self) -> RXFULL_R { RXFULL_R :: new (((self . bits >> 15) & 0x01) != 0) } } # [doc = "Enabled Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_end](index.html) module"]
pub struct IRQ_END_SPEC ; impl crate :: RegisterSpec for IRQ_END_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [irq_end::R](R) reader structure"]
impl crate :: Readable for IRQ_END_SPEC { type Reader = R ; } # [doc = "`reset()` method sets IRQ_END to value 0"]
impl crate :: Resettable for IRQ_END_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IRQ_CLR register accessor: an alias for `Reg<IRQ_CLR_SPEC>`"]
pub type IRQ_CLR = crate :: Reg < irq_clr :: IRQ_CLR_SPEC > ; # [doc = "Clear Interrupt Status Register"]
pub mod irq_clr { # [doc = "Register `IRQ_CLR` writer"]
pub struct W (crate :: W < IRQ_CLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IRQ_CLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IRQ_CLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IRQ_CLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `I2CIDLE` writer - I2C Bus is Idle"]
pub struct I2CIDLE_W < 'a > { w : & 'a mut W , } impl < 'a > I2CIDLE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `IDLE` writer - Controller is Idle"]
pub struct IDLE_W < 'a > { w : & 'a mut W , } impl < 'a > IDLE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `WAITING` writer - Controller is Waiting"]
pub struct WAITING_W < 'a > { w : & 'a mut W , } impl < 'a > WAITING_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `STALLED` writer - Controller is Stalled"]
pub struct STALLED_W < 'a > { w : & 'a mut W , } impl < 'a > STALLED_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } # [doc = "Field `ARBLOST` writer - I2C Arbitration was lost"]
pub struct ARBLOST_W < 'a > { w : & 'a mut W , } impl < 'a > ARBLOST_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 4)) | ((value as u32 & 0x01) << 4) ; self . w } } # [doc = "Field `NACKADDR` writer - I2C Address was not Acknowledged"]
pub struct NACKADDR_W < 'a > { w : & 'a mut W , } impl < 'a > NACKADDR_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 5)) | ((value as u32 & 0x01) << 5) ; self . w } } # [doc = "Field `NACKDATA` writer - I2C Data was not Acknowledged"]
pub struct NACKDATA_W < 'a > { w : & 'a mut W , } impl < 'a > NACKDATA_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | ((value as u32 & 0x01) << 6) ; self . w } } # [doc = "Field `CLKLOTO` writer - I2C Clock Low Timeout"]
pub struct CLKLOTO_W < 'a > { w : & 'a mut W , } impl < 'a > CLKLOTO_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | ((value as u32 & 0x01) << 7) ; self . w } } # [doc = "Field `TXOVERFLOW` writer - TX FIFO Overflowed"]
pub struct TXOVERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > TXOVERFLOW_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 10)) | ((value as u32 & 0x01) << 10) ; self . w } } # [doc = "Field `RXOVERFLOW` writer - TX FIFO Overflowed"]
pub struct RXOVERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > RXOVERFLOW_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 11)) | ((value as u32 & 0x01) << 11) ; self . w } } # [doc = "Field `TXREADY` writer - TX FIFO Ready"]
pub struct TXREADY_W < 'a > { w : & 'a mut W , } impl < 'a > TXREADY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 12)) | ((value as u32 & 0x01) << 12) ; self . w } } # [doc = "Field `RXREADY` writer - RX FIFO Ready"]
pub struct RXREADY_W < 'a > { w : & 'a mut W , } impl < 'a > RXREADY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 13)) | ((value as u32 & 0x01) << 13) ; self . w } } # [doc = "Field `TXEMPTY` writer - TX FIFO Empty"]
pub struct TXEMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > TXEMPTY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 14)) | ((value as u32 & 0x01) << 14) ; self . w } } # [doc = "Field `RXFULL` writer - RX FIFO Full"]
pub struct RXFULL_W < 'a > { w : & 'a mut W , } impl < 'a > RXFULL_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 15)) | ((value as u32 & 0x01) << 15) ; self . w } } impl W { # [doc = "Bit 0 - I2C Bus is Idle"]
# [inline (always)]
pub fn i2cidle (& mut self) -> I2CIDLE_W { I2CIDLE_W { w : self } } # [doc = "Bit 1 - Controller is Idle"]
# [inline (always)]
pub fn idle (& mut self) -> IDLE_W { IDLE_W { w : self } } # [doc = "Bit 2 - Controller is Waiting"]
# [inline (always)]
pub fn waiting (& mut self) -> WAITING_W { WAITING_W { w : self } } # [doc = "Bit 3 - Controller is Stalled"]
# [inline (always)]
pub fn stalled (& mut self) -> STALLED_W { STALLED_W { w : self } } # [doc = "Bit 4 - I2C Arbitration was lost"]
# [inline (always)]
pub fn arblost (& mut self) -> ARBLOST_W { ARBLOST_W { w : self } } # [doc = "Bit 5 - I2C Address was not Acknowledged"]
# [inline (always)]
pub fn nackaddr (& mut self) -> NACKADDR_W { NACKADDR_W { w : self } } # [doc = "Bit 6 - I2C Data was not Acknowledged"]
# [inline (always)]
pub fn nackdata (& mut self) -> NACKDATA_W { NACKDATA_W { w : self } } # [doc = "Bit 7 - I2C Clock Low Timeout"]
# [inline (always)]
pub fn clkloto (& mut self) -> CLKLOTO_W { CLKLOTO_W { w : self } } # [doc = "Bit 10 - TX FIFO Overflowed"]
# [inline (always)]
pub fn txoverflow (& mut self) -> TXOVERFLOW_W { TXOVERFLOW_W { w : self } } # [doc = "Bit 11 - TX FIFO Overflowed"]
# [inline (always)]
pub fn rxoverflow (& mut self) -> RXOVERFLOW_W { RXOVERFLOW_W { w : self } } # [doc = "Bit 12 - TX FIFO Ready"]
# [inline (always)]
pub fn txready (& mut self) -> TXREADY_W { TXREADY_W { w : self } } # [doc = "Bit 13 - RX FIFO Ready"]
# [inline (always)]
pub fn rxready (& mut self) -> RXREADY_W { RXREADY_W { w : self } } # [doc = "Bit 14 - TX FIFO Empty"]
# [inline (always)]
pub fn txempty (& mut self) -> TXEMPTY_W { TXEMPTY_W { w : self } } # [doc = "Bit 15 - RX FIFO Full"]
# [inline (always)]
pub fn rxfull (& mut self) -> RXFULL_W { RXFULL_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clear Interrupt Status Register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_clr](index.html) module"]
pub struct IRQ_CLR_SPEC ; impl crate :: RegisterSpec for IRQ_CLR_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [irq_clr::W](W) writer structure"]
impl crate :: Writable for IRQ_CLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets IRQ_CLR to value 0"]
impl crate :: Resettable for IRQ_CLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RXFIFOIRQTRG register accessor: an alias for `Reg<RXFIFOIRQTRG_SPEC>`"]
pub type RXFIFOIRQTRG = crate :: Reg < rxfifoirqtrg :: RXFIFOIRQTRG_SPEC > ; # [doc = "Rx FIFO IRQ Trigger Level"]
pub mod rxfifoirqtrg { # [doc = "Register `RXFIFOIRQTRG` reader"]
pub struct R (crate :: R < RXFIFOIRQTRG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXFIFOIRQTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXFIFOIRQTRG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXFIFOIRQTRG_SPEC >) -> Self { R (reader) } } # [doc = "Register `RXFIFOIRQTRG` writer"]
pub struct W (crate :: W < RXFIFOIRQTRG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RXFIFOIRQTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RXFIFOIRQTRG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RXFIFOIRQTRG_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Rx FIFO IRQ Trigger Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxfifoirqtrg](index.html) module"]
pub struct RXFIFOIRQTRG_SPEC ; impl crate :: RegisterSpec for RXFIFOIRQTRG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [rxfifoirqtrg::R](R) reader structure"]
impl crate :: Readable for RXFIFOIRQTRG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rxfifoirqtrg::W](W) writer structure"]
impl crate :: Writable for RXFIFOIRQTRG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RXFIFOIRQTRG to value 0"]
impl crate :: Resettable for RXFIFOIRQTRG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TXFIFOIRQTRG register accessor: an alias for `Reg<TXFIFOIRQTRG_SPEC>`"]
pub type TXFIFOIRQTRG = crate :: Reg < txfifoirqtrg :: TXFIFOIRQTRG_SPEC > ; # [doc = "Tx FIFO IRQ Trigger Level"]
pub mod txfifoirqtrg { # [doc = "Register `TXFIFOIRQTRG` reader"]
pub struct R (crate :: R < TXFIFOIRQTRG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXFIFOIRQTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXFIFOIRQTRG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXFIFOIRQTRG_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXFIFOIRQTRG` writer"]
pub struct W (crate :: W < TXFIFOIRQTRG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXFIFOIRQTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXFIFOIRQTRG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXFIFOIRQTRG_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Tx FIFO IRQ Trigger Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txfifoirqtrg](index.html) module"]
pub struct TXFIFOIRQTRG_SPEC ; impl crate :: RegisterSpec for TXFIFOIRQTRG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [txfifoirqtrg::R](R) reader structure"]
impl crate :: Readable for TXFIFOIRQTRG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txfifoirqtrg::W](W) writer structure"]
impl crate :: Writable for TXFIFOIRQTRG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TXFIFOIRQTRG to value 0"]
impl crate :: Resettable for TXFIFOIRQTRG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "FIFO_CLR register accessor: an alias for `Reg<FIFO_CLR_SPEC>`"]
pub type FIFO_CLR = crate :: Reg < fifo_clr :: FIFO_CLR_SPEC > ; # [doc = "Clear FIFO Register"]
pub mod fifo_clr { # [doc = "Register `FIFO_CLR` writer"]
pub struct W (crate :: W < FIFO_CLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FIFO_CLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FIFO_CLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FIFO_CLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXFIFO` writer - Clear Rx FIFO"]
pub struct RXFIFO_W < 'a > { w : & 'a mut W , } impl < 'a > RXFIFO_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `TXFIFO` writer - Clear Tx FIFO"]
pub struct TXFIFO_W < 'a > { w : & 'a mut W , } impl < 'a > TXFIFO_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } impl W { # [doc = "Bit 0 - Clear Rx FIFO"]
# [inline (always)]
pub fn rxfifo (& mut self) -> RXFIFO_W { RXFIFO_W { w : self } } # [doc = "Bit 1 - Clear Tx FIFO"]
# [inline (always)]
pub fn txfifo (& mut self) -> TXFIFO_W { TXFIFO_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clear FIFO Register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fifo_clr](index.html) module"]
pub struct FIFO_CLR_SPEC ; impl crate :: RegisterSpec for FIFO_CLR_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [fifo_clr::W](W) writer structure"]
impl crate :: Writable for FIFO_CLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets FIFO_CLR to value 0"]
impl crate :: Resettable for FIFO_CLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TMCONFIG register accessor: an alias for `Reg<TMCONFIG_SPEC>`"]
pub type TMCONFIG = crate :: Reg < tmconfig :: TMCONFIG_SPEC > ; # [doc = "Timing Config Register"]
pub mod tmconfig { # [doc = "Register `TMCONFIG` reader"]
pub struct R (crate :: R < TMCONFIG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TMCONFIG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TMCONFIG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TMCONFIG_SPEC >) -> Self { R (reader) } } # [doc = "Register `TMCONFIG` writer"]
pub struct W (crate :: W < TMCONFIG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TMCONFIG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TMCONFIG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TMCONFIG_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timing Config Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tmconfig](index.html) module"]
pub struct TMCONFIG_SPEC ; impl crate :: RegisterSpec for TMCONFIG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [tmconfig::R](R) reader structure"]
impl crate :: Readable for TMCONFIG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tmconfig::W](W) writer structure"]
impl crate :: Writable for TMCONFIG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TMCONFIG to value 0"]
impl crate :: Resettable for TMCONFIG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CLKTOLIMIT register accessor: an alias for `Reg<CLKTOLIMIT_SPEC>`"]
pub type CLKTOLIMIT = crate :: Reg < clktolimit :: CLKTOLIMIT_SPEC > ; # [doc = "Clock Low Timeout Limit Register"]
pub mod clktolimit { # [doc = "Register `CLKTOLIMIT` reader"]
pub struct R (crate :: R < CLKTOLIMIT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CLKTOLIMIT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CLKTOLIMIT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CLKTOLIMIT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CLKTOLIMIT` writer"]
pub struct W (crate :: W < CLKTOLIMIT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CLKTOLIMIT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CLKTOLIMIT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CLKTOLIMIT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clock Low Timeout Limit Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clktolimit](index.html) module"]
pub struct CLKTOLIMIT_SPEC ; impl crate :: RegisterSpec for CLKTOLIMIT_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [clktolimit::R](R) reader structure"]
impl crate :: Readable for CLKTOLIMIT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [clktolimit::W](W) writer structure"]
impl crate :: Writable for CLKTOLIMIT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CLKTOLIMIT to value 0"]
impl crate :: Resettable for CLKTOLIMIT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_CTRL register accessor: an alias for `Reg<S0_CTRL_SPEC>`"]
pub type S0_CTRL = crate :: Reg < s0_ctrl :: S0_CTRL_SPEC > ; # [doc = "Slave Control Register"]
pub mod s0_ctrl { # [doc = "Register `S0_CTRL` reader"]
pub struct R (crate :: R < S0_CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < S0_CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < S0_CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < S0_CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `S0_CTRL` writer"]
pub struct W (crate :: W < S0_CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < S0_CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < S0_CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < S0_CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CLKENABLED` reader - I2C Enabled"]
pub struct CLKENABLED_R (crate :: FieldReader < bool , bool >) ; impl CLKENABLED_R { pub (crate) fn new (bits : bool) -> Self { CLKENABLED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for CLKENABLED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `CLKENABLED` writer - I2C Enabled"]
pub struct CLKENABLED_W < 'a > { w : & 'a mut W , } impl < 'a > CLKENABLED_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `ENABLED` reader - I2C Activated"]
pub struct ENABLED_R (crate :: FieldReader < bool , bool >) ; impl ENABLED_R { pub (crate) fn new (bits : bool) -> Self { ENABLED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ENABLED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ENABLED` writer - I2C Activated"]
pub struct ENABLED_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLED_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `ENABLE` reader - I2C Active"]
pub struct ENABLE_R (crate :: FieldReader < bool , bool >) ; impl ENABLE_R { pub (crate) fn new (bits : bool) -> Self { ENABLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ENABLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ENABLE` writer - I2C Active"]
pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `TXFEMD` reader - TX FIFIO Empty Mode"]
pub struct TXFEMD_R (crate :: FieldReader < bool , bool >) ; impl TXFEMD_R { pub (crate) fn new (bits : bool) -> Self { TXFEMD_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXFEMD_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXFEMD` writer - TX FIFIO Empty Mode"]
pub struct TXFEMD_W < 'a > { w : & 'a mut W , } impl < 'a > TXFEMD_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } # [doc = "Field `RXFFMD` reader - RX FIFO Full Mode"]
pub struct RXFFMD_R (crate :: FieldReader < bool , bool >) ; impl RXFFMD_R { pub (crate) fn new (bits : bool) -> Self { RXFFMD_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXFFMD_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXFFMD` writer - RX FIFO Full Mode"]
pub struct RXFFMD_W < 'a > { w : & 'a mut W , } impl < 'a > RXFFMD_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 4)) | ((value as u32 & 0x01) << 4) ; self . w } } impl R { # [doc = "Bit 0 - I2C Enabled"]
# [inline (always)]
pub fn clkenabled (& self) -> CLKENABLED_R { CLKENABLED_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - I2C Activated"]
# [inline (always)]
pub fn enabled (& self) -> ENABLED_R { ENABLED_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - I2C Active"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - TX FIFIO Empty Mode"]
# [inline (always)]
pub fn txfemd (& self) -> TXFEMD_R { TXFEMD_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - RX FIFO Full Mode"]
# [inline (always)]
pub fn rxffmd (& self) -> RXFFMD_R { RXFFMD_R :: new (((self . bits >> 4) & 0x01) != 0) } } impl W { # [doc = "Bit 0 - I2C Enabled"]
# [inline (always)]
pub fn clkenabled (& mut self) -> CLKENABLED_W { CLKENABLED_W { w : self } } # [doc = "Bit 1 - I2C Activated"]
# [inline (always)]
pub fn enabled (& mut self) -> ENABLED_W { ENABLED_W { w : self } } # [doc = "Bit 2 - I2C Active"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W { w : self } } # [doc = "Bit 3 - TX FIFIO Empty Mode"]
# [inline (always)]
pub fn txfemd (& mut self) -> TXFEMD_W { TXFEMD_W { w : self } } # [doc = "Bit 4 - RX FIFO Full Mode"]
# [inline (always)]
pub fn rxffmd (& mut self) -> RXFFMD_W { RXFFMD_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Slave Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_ctrl](index.html) module"]
pub struct S0_CTRL_SPEC ; impl crate :: RegisterSpec for S0_CTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [s0_ctrl::R](R) reader structure"]
impl crate :: Readable for S0_CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [s0_ctrl::W](W) writer structure"]
impl crate :: Writable for S0_CTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets S0_CTRL to value 0"]
impl crate :: Resettable for S0_CTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_MAXWORDS register accessor: an alias for `Reg<S0_MAXWORDS_SPEC>`"]
pub type S0_MAXWORDS = crate :: Reg < s0_maxwords :: S0_MAXWORDS_SPEC > ; # [doc = "Slave MaxWords Register"]
pub mod s0_maxwords { # [doc = "Register `S0_MAXWORDS` reader"]
pub struct R (crate :: R < S0_MAXWORDS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < S0_MAXWORDS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < S0_MAXWORDS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < S0_MAXWORDS_SPEC >) -> Self { R (reader) } } # [doc = "Register `S0_MAXWORDS` writer"]
pub struct W (crate :: W < S0_MAXWORDS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < S0_MAXWORDS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < S0_MAXWORDS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < S0_MAXWORDS_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Slave MaxWords Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_maxwords](index.html) module"]
pub struct S0_MAXWORDS_SPEC ; impl crate :: RegisterSpec for S0_MAXWORDS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [s0_maxwords::R](R) reader structure"]
impl crate :: Readable for S0_MAXWORDS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [s0_maxwords::W](W) writer structure"]
impl crate :: Writable for S0_MAXWORDS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets S0_MAXWORDS to value 0"]
impl crate :: Resettable for S0_MAXWORDS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_ADDRESS register accessor: an alias for `Reg<S0_ADDRESS_SPEC>`"]
pub type S0_ADDRESS = crate :: Reg < s0_address :: S0_ADDRESS_SPEC > ; # [doc = "Slave I2C Address Value"]
pub mod s0_address { # [doc = "Register `S0_ADDRESS` reader"]
pub struct R (crate :: R < S0_ADDRESS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < S0_ADDRESS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < S0_ADDRESS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < S0_ADDRESS_SPEC >) -> Self { R (reader) } } # [doc = "Register `S0_ADDRESS` writer"]
pub struct W (crate :: W < S0_ADDRESS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < S0_ADDRESS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < S0_ADDRESS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < S0_ADDRESS_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Slave I2C Address Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_address](index.html) module"]
pub struct S0_ADDRESS_SPEC ; impl crate :: RegisterSpec for S0_ADDRESS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [s0_address::R](R) reader structure"]
impl crate :: Readable for S0_ADDRESS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [s0_address::W](W) writer structure"]
impl crate :: Writable for S0_ADDRESS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets S0_ADDRESS to value 0"]
impl crate :: Resettable for S0_ADDRESS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_ADDRESSMASK register accessor: an alias for `Reg<S0_ADDRESSMASK_SPEC>`"]
pub type S0_ADDRESSMASK = crate :: Reg < s0_addressmask :: S0_ADDRESSMASK_SPEC > ; # [doc = "Slave I2C Address Mask value"]
pub mod s0_addressmask { # [doc = "Register `S0_ADDRESSMASK` reader"]
pub struct R (crate :: R < S0_ADDRESSMASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < S0_ADDRESSMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < S0_ADDRESSMASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < S0_ADDRESSMASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `S0_ADDRESSMASK` writer"]
pub struct W (crate :: W < S0_ADDRESSMASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < S0_ADDRESSMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < S0_ADDRESSMASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < S0_ADDRESSMASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Slave I2C Address Mask value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_addressmask](index.html) module"]
pub struct S0_ADDRESSMASK_SPEC ; impl crate :: RegisterSpec for S0_ADDRESSMASK_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [s0_addressmask::R](R) reader structure"]
impl crate :: Readable for S0_ADDRESSMASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [s0_addressmask::W](W) writer structure"]
impl crate :: Writable for S0_ADDRESSMASK_SPEC { type Writer = W ; } # [doc = "`reset()` method sets S0_ADDRESSMASK to value 0"]
impl crate :: Resettable for S0_ADDRESSMASK_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_DATA register accessor: an alias for `Reg<S0_DATA_SPEC>`"]
pub type S0_DATA = crate :: Reg < s0_data :: S0_DATA_SPEC > ; # [doc = "Slave Data Input/Output"]
pub mod s0_data { # [doc = "Register `S0_DATA` reader"]
pub struct R (crate :: R < S0_DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < S0_DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < S0_DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < S0_DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `S0_DATA` writer"]
pub struct W (crate :: W < S0_DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < S0_DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < S0_DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < S0_DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Slave Data Input/Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_data](index.html) module"]
pub struct S0_DATA_SPEC ; impl crate :: RegisterSpec for S0_DATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [s0_data::R](R) reader structure"]
impl crate :: Readable for S0_DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [s0_data::W](W) writer structure"]
impl crate :: Writable for S0_DATA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets S0_DATA to value 0"]
impl crate :: Resettable for S0_DATA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_LASTADDRESS register accessor: an alias for `Reg<S0_LASTADDRESS_SPEC>`"]
pub type S0_LASTADDRESS = crate :: Reg < s0_lastaddress :: S0_LASTADDRESS_SPEC > ; # [doc = "Slave I2C Last Address value"]
pub mod s0_lastaddress { # [doc = "Register `S0_LASTADDRESS` reader"]
pub struct R (crate :: R < S0_LASTADDRESS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < S0_LASTADDRESS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < S0_LASTADDRESS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < S0_LASTADDRESS_SPEC >) -> Self { R (reader) } } # [doc = "Slave I2C Last Address value\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_lastaddress](index.html) module"]
pub struct S0_LASTADDRESS_SPEC ; impl crate :: RegisterSpec for S0_LASTADDRESS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [s0_lastaddress::R](R) reader structure"]
impl crate :: Readable for S0_LASTADDRESS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets S0_LASTADDRESS to value 0"]
impl crate :: Resettable for S0_LASTADDRESS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_STATUS register accessor: an alias for `Reg<S0_STATUS_SPEC>`"]
pub type S0_STATUS = crate :: Reg < s0_status :: S0_STATUS_SPEC > ; # [doc = "Slave I2C Controller Status Register"]
pub mod s0_status { # [doc = "Register `S0_STATUS` reader"]
pub struct R (crate :: R < S0_STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < S0_STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < S0_STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < S0_STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `COMPLETED` reader - Controller Complted a Transaction"]
pub struct COMPLETED_R (crate :: FieldReader < bool , bool >) ; impl COMPLETED_R { pub (crate) fn new (bits : bool) -> Self { COMPLETED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for COMPLETED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IDLE` reader - Controller is Idle"]
pub struct IDLE_R (crate :: FieldReader < bool , bool >) ; impl IDLE_R { pub (crate) fn new (bits : bool) -> Self { IDLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IDLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `WAITING` reader - Controller is Waiting"]
pub struct WAITING_R (crate :: FieldReader < bool , bool >) ; impl WAITING_R { pub (crate) fn new (bits : bool) -> Self { WAITING_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for WAITING_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXSTALLED` reader - Controller is Tx Stalled"]
pub struct TXSTALLED_R (crate :: FieldReader < bool , bool >) ; impl TXSTALLED_R { pub (crate) fn new (bits : bool) -> Self { TXSTALLED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXSTALLED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXSTALLED` reader - Controller is Rx Stalled"]
pub struct RXSTALLED_R (crate :: FieldReader < bool , bool >) ; impl RXSTALLED_R { pub (crate) fn new (bits : bool) -> Self { RXSTALLED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXSTALLED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ADDRESSMATCH` reader - I2C Address Match"]
pub struct ADDRESSMATCH_R (crate :: FieldReader < bool , bool >) ; impl ADDRESSMATCH_R { pub (crate) fn new (bits : bool) -> Self { ADDRESSMATCH_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ADDRESSMATCH_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `NACKDATA` reader - I2C Data was not Acknowledged"]
pub struct NACKDATA_R (crate :: FieldReader < bool , bool >) ; impl NACKDATA_R { pub (crate) fn new (bits : bool) -> Self { NACKDATA_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for NACKDATA_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXDATAFIRST` reader - Pending Data is first Byte following Address"]
pub struct RXDATAFIRST_R (crate :: FieldReader < bool , bool >) ; impl RXDATAFIRST_R { pub (crate) fn new (bits : bool) -> Self { RXDATAFIRST_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXDATAFIRST_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXNEMPTY` reader - RX FIFO is Not Empty"]
pub struct RXNEMPTY_R (crate :: FieldReader < bool , bool >) ; impl RXNEMPTY_R { pub (crate) fn new (bits : bool) -> Self { RXNEMPTY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXNEMPTY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXFULL` reader - RX FIFO is Full"]
pub struct RXFULL_R (crate :: FieldReader < bool , bool >) ; impl RXFULL_R { pub (crate) fn new (bits : bool) -> Self { RXFULL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXFULL_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXTRIGGER` reader - RX FIFO Above Trigger Level"]
pub struct RXTRIGGER_R (crate :: FieldReader < bool , bool >) ; impl RXTRIGGER_R { pub (crate) fn new (bits : bool) -> Self { RXTRIGGER_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXTRIGGER_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXEMPTY` reader - TX FIFO is Empty"]
pub struct TXEMPTY_R (crate :: FieldReader < bool , bool >) ; impl TXEMPTY_R { pub (crate) fn new (bits : bool) -> Self { TXEMPTY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXEMPTY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXNFULL` reader - TX FIFO is Full"]
pub struct TXNFULL_R (crate :: FieldReader < bool , bool >) ; impl TXNFULL_R { pub (crate) fn new (bits : bool) -> Self { TXNFULL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXNFULL_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXTRIGGER` reader - TX FIFO Below Trigger Level"]
pub struct TXTRIGGER_R (crate :: FieldReader < bool , bool >) ; impl TXTRIGGER_R { pub (crate) fn new (bits : bool) -> Self { TXTRIGGER_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXTRIGGER_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RAW_BUSY` reader - I2C Raw Busy value"]
pub struct RAW_BUSY_R (crate :: FieldReader < bool , bool >) ; impl RAW_BUSY_R { pub (crate) fn new (bits : bool) -> Self { RAW_BUSY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RAW_BUSY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RAW_SDA` reader - I2C Raw SDA value"]
pub struct RAW_SDA_R (crate :: FieldReader < bool , bool >) ; impl RAW_SDA_R { pub (crate) fn new (bits : bool) -> Self { RAW_SDA_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RAW_SDA_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RAW_SCL` reader - I2C Raw SCL value"]
pub struct RAW_SCL_R (crate :: FieldReader < bool , bool >) ; impl RAW_SCL_R { pub (crate) fn new (bits : bool) -> Self { RAW_SCL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RAW_SCL_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - Controller Complted a Transaction"]
# [inline (always)]
pub fn completed (& self) -> COMPLETED_R { COMPLETED_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - Controller is Idle"]
# [inline (always)]
pub fn idle (& self) -> IDLE_R { IDLE_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - Controller is Waiting"]
# [inline (always)]
pub fn waiting (& self) -> WAITING_R { WAITING_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - Controller is Tx Stalled"]
# [inline (always)]
pub fn txstalled (& self) -> TXSTALLED_R { TXSTALLED_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - Controller is Rx Stalled"]
# [inline (always)]
pub fn rxstalled (& self) -> RXSTALLED_R { RXSTALLED_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - I2C Address Match"]
# [inline (always)]
pub fn addressmatch (& self) -> ADDRESSMATCH_R { ADDRESSMATCH_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - I2C Data was not Acknowledged"]
# [inline (always)]
pub fn nackdata (& self) -> NACKDATA_R { NACKDATA_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - Pending Data is first Byte following Address"]
# [inline (always)]
pub fn rxdatafirst (& self) -> RXDATAFIRST_R { RXDATAFIRST_R :: new (((self . bits >> 7) & 0x01) != 0) } # [doc = "Bit 8 - RX FIFO is Not Empty"]
# [inline (always)]
pub fn rxnempty (& self) -> RXNEMPTY_R { RXNEMPTY_R :: new (((self . bits >> 8) & 0x01) != 0) } # [doc = "Bit 9 - RX FIFO is Full"]
# [inline (always)]
pub fn rxfull (& self) -> RXFULL_R { RXFULL_R :: new (((self . bits >> 9) & 0x01) != 0) } # [doc = "Bit 11 - RX FIFO Above Trigger Level"]
# [inline (always)]
pub fn rxtrigger (& self) -> RXTRIGGER_R { RXTRIGGER_R :: new (((self . bits >> 11) & 0x01) != 0) } # [doc = "Bit 12 - TX FIFO is Empty"]
# [inline (always)]
pub fn txempty (& self) -> TXEMPTY_R { TXEMPTY_R :: new (((self . bits >> 12) & 0x01) != 0) } # [doc = "Bit 13 - TX FIFO is Full"]
# [inline (always)]
pub fn txnfull (& self) -> TXNFULL_R { TXNFULL_R :: new (((self . bits >> 13) & 0x01) != 0) } # [doc = "Bit 15 - TX FIFO Below Trigger Level"]
# [inline (always)]
pub fn txtrigger (& self) -> TXTRIGGER_R { TXTRIGGER_R :: new (((self . bits >> 15) & 0x01) != 0) } # [doc = "Bit 29 - I2C Raw Busy value"]
# [inline (always)]
pub fn raw_busy (& self) -> RAW_BUSY_R { RAW_BUSY_R :: new (((self . bits >> 29) & 0x01) != 0) } # [doc = "Bit 30 - I2C Raw SDA value"]
# [inline (always)]
pub fn raw_sda (& self) -> RAW_SDA_R { RAW_SDA_R :: new (((self . bits >> 30) & 0x01) != 0) } # [doc = "Bit 31 - I2C Raw SCL value"]
# [inline (always)]
pub fn raw_scl (& self) -> RAW_SCL_R { RAW_SCL_R :: new (((self . bits >> 31) & 0x01) != 0) } } # [doc = "Slave I2C Controller Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_status](index.html) module"]
pub struct S0_STATUS_SPEC ; impl crate :: RegisterSpec for S0_STATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [s0_status::R](R) reader structure"]
impl crate :: Readable for S0_STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets S0_STATUS to value 0"]
impl crate :: Resettable for S0_STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_STATE register accessor: an alias for `Reg<S0_STATE_SPEC>`"]
pub type S0_STATE = crate :: Reg < s0_state :: S0_STATE_SPEC > ; # [doc = "Internal STATE of I2C Slave Controller"]
pub mod s0_state { # [doc = "Register `S0_STATE` reader"]
pub struct R (crate :: R < S0_STATE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < S0_STATE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < S0_STATE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < S0_STATE_SPEC >) -> Self { R (reader) } } # [doc = "Internal STATE of I2C Slave Controller\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_state](index.html) module"]
pub struct S0_STATE_SPEC ; impl crate :: RegisterSpec for S0_STATE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [s0_state::R](R) reader structure"]
impl crate :: Readable for S0_STATE_SPEC { type Reader = R ; } # [doc = "`reset()` method sets S0_STATE to value 0"]
impl crate :: Resettable for S0_STATE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_TXCOUNT register accessor: an alias for `Reg<S0_TXCOUNT_SPEC>`"]
pub type S0_TXCOUNT = crate :: Reg < s0_txcount :: S0_TXCOUNT_SPEC > ; # [doc = "Slave TX Count Register"]
pub mod s0_txcount { # [doc = "Register `S0_TXCOUNT` reader"]
pub struct R (crate :: R < S0_TXCOUNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < S0_TXCOUNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < S0_TXCOUNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < S0_TXCOUNT_SPEC >) -> Self { R (reader) } } # [doc = "Slave TX Count Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_txcount](index.html) module"]
pub struct S0_TXCOUNT_SPEC ; impl crate :: RegisterSpec for S0_TXCOUNT_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [s0_txcount::R](R) reader structure"]
impl crate :: Readable for S0_TXCOUNT_SPEC { type Reader = R ; } # [doc = "`reset()` method sets S0_TXCOUNT to value 0"]
impl crate :: Resettable for S0_TXCOUNT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_RXCOUNT register accessor: an alias for `Reg<S0_RXCOUNT_SPEC>`"]
pub type S0_RXCOUNT = crate :: Reg < s0_rxcount :: S0_RXCOUNT_SPEC > ; # [doc = "Slave RX Count Register"]
pub mod s0_rxcount { # [doc = "Register `S0_RXCOUNT` reader"]
pub struct R (crate :: R < S0_RXCOUNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < S0_RXCOUNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < S0_RXCOUNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < S0_RXCOUNT_SPEC >) -> Self { R (reader) } } # [doc = "Slave RX Count Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_rxcount](index.html) module"]
pub struct S0_RXCOUNT_SPEC ; impl crate :: RegisterSpec for S0_RXCOUNT_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [s0_rxcount::R](R) reader structure"]
impl crate :: Readable for S0_RXCOUNT_SPEC { type Reader = R ; } # [doc = "`reset()` method sets S0_RXCOUNT to value 0"]
impl crate :: Resettable for S0_RXCOUNT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_IRQ_ENB register accessor: an alias for `Reg<S0_IRQ_ENB_SPEC>`"]
pub type S0_IRQ_ENB = crate :: Reg < s0_irq_enb :: S0_IRQ_ENB_SPEC > ; # [doc = "Slave Interrupt Enable Register"]
pub mod s0_irq_enb { # [doc = "Register `S0_IRQ_ENB` reader"]
pub struct R (crate :: R < S0_IRQ_ENB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < S0_IRQ_ENB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < S0_IRQ_ENB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < S0_IRQ_ENB_SPEC >) -> Self { R (reader) } } # [doc = "Register `S0_IRQ_ENB` writer"]
pub struct W (crate :: W < S0_IRQ_ENB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < S0_IRQ_ENB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < S0_IRQ_ENB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < S0_IRQ_ENB_SPEC >) -> Self { W (writer) } } # [doc = "Field `COMPLETED` reader - Controller Complted a Transaction"]
pub struct COMPLETED_R (crate :: FieldReader < bool , bool >) ; impl COMPLETED_R { pub (crate) fn new (bits : bool) -> Self { COMPLETED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for COMPLETED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `COMPLETED` writer - Controller Complted a Transaction"]
pub struct COMPLETED_W < 'a > { w : & 'a mut W , } impl < 'a > COMPLETED_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `IDLE` reader - Controller is Idle"]
pub struct IDLE_R (crate :: FieldReader < bool , bool >) ; impl IDLE_R { pub (crate) fn new (bits : bool) -> Self { IDLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IDLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IDLE` writer - Controller is Idle"]
pub struct IDLE_W < 'a > { w : & 'a mut W , } impl < 'a > IDLE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `WAITING` reader - Controller is Waiting"]
pub struct WAITING_R (crate :: FieldReader < bool , bool >) ; impl WAITING_R { pub (crate) fn new (bits : bool) -> Self { WAITING_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for WAITING_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `WAITING` writer - Controller is Waiting"]
pub struct WAITING_W < 'a > { w : & 'a mut W , } impl < 'a > WAITING_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `TXSTALLED` reader - Controller is Tx Stalled"]
pub struct TXSTALLED_R (crate :: FieldReader < bool , bool >) ; impl TXSTALLED_R { pub (crate) fn new (bits : bool) -> Self { TXSTALLED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXSTALLED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXSTALLED` writer - Controller is Tx Stalled"]
pub struct TXSTALLED_W < 'a > { w : & 'a mut W , } impl < 'a > TXSTALLED_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } # [doc = "Field `RXSTALLED` reader - Controller is Rx Stalled"]
pub struct RXSTALLED_R (crate :: FieldReader < bool , bool >) ; impl RXSTALLED_R { pub (crate) fn new (bits : bool) -> Self { RXSTALLED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXSTALLED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXSTALLED` writer - Controller is Rx Stalled"]
pub struct RXSTALLED_W < 'a > { w : & 'a mut W , } impl < 'a > RXSTALLED_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 4)) | ((value as u32 & 0x01) << 4) ; self . w } } # [doc = "Field `ADDRESSMATCH` reader - I2C Address Match"]
pub struct ADDRESSMATCH_R (crate :: FieldReader < bool , bool >) ; impl ADDRESSMATCH_R { pub (crate) fn new (bits : bool) -> Self { ADDRESSMATCH_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ADDRESSMATCH_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ADDRESSMATCH` writer - I2C Address Match"]
pub struct ADDRESSMATCH_W < 'a > { w : & 'a mut W , } impl < 'a > ADDRESSMATCH_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 5)) | ((value as u32 & 0x01) << 5) ; self . w } } # [doc = "Field `NACKDATA` reader - I2C Data was not Acknowledged"]
pub struct NACKDATA_R (crate :: FieldReader < bool , bool >) ; impl NACKDATA_R { pub (crate) fn new (bits : bool) -> Self { NACKDATA_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for NACKDATA_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `NACKDATA` writer - I2C Data was not Acknowledged"]
pub struct NACKDATA_W < 'a > { w : & 'a mut W , } impl < 'a > NACKDATA_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | ((value as u32 & 0x01) << 6) ; self . w } } # [doc = "Field `RXDATAFIRST` reader - Pending Data is first Byte following Address"]
pub struct RXDATAFIRST_R (crate :: FieldReader < bool , bool >) ; impl RXDATAFIRST_R { pub (crate) fn new (bits : bool) -> Self { RXDATAFIRST_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXDATAFIRST_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXDATAFIRST` writer - Pending Data is first Byte following Address"]
pub struct RXDATAFIRST_W < 'a > { w : & 'a mut W , } impl < 'a > RXDATAFIRST_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | ((value as u32 & 0x01) << 7) ; self . w } } # [doc = "Field `I2C_START` reader - I2C Start Condition"]
pub struct I2C_START_R (crate :: FieldReader < bool , bool >) ; impl I2C_START_R { pub (crate) fn new (bits : bool) -> Self { I2C_START_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for I2C_START_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `I2C_START` writer - I2C Start Condition"]
pub struct I2C_START_W < 'a > { w : & 'a mut W , } impl < 'a > I2C_START_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 8)) | ((value as u32 & 0x01) << 8) ; self . w } } # [doc = "Field `I2C_STOP` reader - I2C Stop Condition"]
pub struct I2C_STOP_R (crate :: FieldReader < bool , bool >) ; impl I2C_STOP_R { pub (crate) fn new (bits : bool) -> Self { I2C_STOP_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for I2C_STOP_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `I2C_STOP` writer - I2C Stop Condition"]
pub struct I2C_STOP_W < 'a > { w : & 'a mut W , } impl < 'a > I2C_STOP_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 9)) | ((value as u32 & 0x01) << 9) ; self . w } } # [doc = "Field `TXUNDERFLOW` reader - TX FIFO Underflowed"]
pub struct TXUNDERFLOW_R (crate :: FieldReader < bool , bool >) ; impl TXUNDERFLOW_R { pub (crate) fn new (bits : bool) -> Self { TXUNDERFLOW_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXUNDERFLOW_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXUNDERFLOW` writer - TX FIFO Underflowed"]
pub struct TXUNDERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > TXUNDERFLOW_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 10)) | ((value as u32 & 0x01) << 10) ; self . w } } # [doc = "Field `RXOVERFLOW` reader - TX FIFO Overflowed"]
pub struct RXOVERFLOW_R (crate :: FieldReader < bool , bool >) ; impl RXOVERFLOW_R { pub (crate) fn new (bits : bool) -> Self { RXOVERFLOW_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXOVERFLOW_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXOVERFLOW` writer - TX FIFO Overflowed"]
pub struct RXOVERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > RXOVERFLOW_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 11)) | ((value as u32 & 0x01) << 11) ; self . w } } # [doc = "Field `TXREADY` reader - TX FIFO Ready"]
pub struct TXREADY_R (crate :: FieldReader < bool , bool >) ; impl TXREADY_R { pub (crate) fn new (bits : bool) -> Self { TXREADY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXREADY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXREADY` writer - TX FIFO Ready"]
pub struct TXREADY_W < 'a > { w : & 'a mut W , } impl < 'a > TXREADY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 12)) | ((value as u32 & 0x01) << 12) ; self . w } } # [doc = "Field `RXREADY` reader - RX FIFO Ready"]
pub struct RXREADY_R (crate :: FieldReader < bool , bool >) ; impl RXREADY_R { pub (crate) fn new (bits : bool) -> Self { RXREADY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXREADY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXREADY` writer - RX FIFO Ready"]
pub struct RXREADY_W < 'a > { w : & 'a mut W , } impl < 'a > RXREADY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 13)) | ((value as u32 & 0x01) << 13) ; self . w } } # [doc = "Field `TXEMPTY` reader - TX FIFO Empty"]
pub struct TXEMPTY_R (crate :: FieldReader < bool , bool >) ; impl TXEMPTY_R { pub (crate) fn new (bits : bool) -> Self { TXEMPTY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXEMPTY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXEMPTY` writer - TX FIFO Empty"]
pub struct TXEMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > TXEMPTY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 14)) | ((value as u32 & 0x01) << 14) ; self . w } } # [doc = "Field `RXFULL` reader - RX FIFO Full"]
pub struct RXFULL_R (crate :: FieldReader < bool , bool >) ; impl RXFULL_R { pub (crate) fn new (bits : bool) -> Self { RXFULL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXFULL_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXFULL` writer - RX FIFO Full"]
pub struct RXFULL_W < 'a > { w : & 'a mut W , } impl < 'a > RXFULL_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 15)) | ((value as u32 & 0x01) << 15) ; self . w } } impl R { # [doc = "Bit 0 - Controller Complted a Transaction"]
# [inline (always)]
pub fn completed (& self) -> COMPLETED_R { COMPLETED_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - Controller is Idle"]
# [inline (always)]
pub fn idle (& self) -> IDLE_R { IDLE_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - Controller is Waiting"]
# [inline (always)]
pub fn waiting (& self) -> WAITING_R { WAITING_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - Controller is Tx Stalled"]
# [inline (always)]
pub fn txstalled (& self) -> TXSTALLED_R { TXSTALLED_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - Controller is Rx Stalled"]
# [inline (always)]
pub fn rxstalled (& self) -> RXSTALLED_R { RXSTALLED_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - I2C Address Match"]
# [inline (always)]
pub fn addressmatch (& self) -> ADDRESSMATCH_R { ADDRESSMATCH_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - I2C Data was not Acknowledged"]
# [inline (always)]
pub fn nackdata (& self) -> NACKDATA_R { NACKDATA_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - Pending Data is first Byte following Address"]
# [inline (always)]
pub fn rxdatafirst (& self) -> RXDATAFIRST_R { RXDATAFIRST_R :: new (((self . bits >> 7) & 0x01) != 0) } # [doc = "Bit 8 - I2C Start Condition"]
# [inline (always)]
pub fn i2c_start (& self) -> I2C_START_R { I2C_START_R :: new (((self . bits >> 8) & 0x01) != 0) } # [doc = "Bit 9 - I2C Stop Condition"]
# [inline (always)]
pub fn i2c_stop (& self) -> I2C_STOP_R { I2C_STOP_R :: new (((self . bits >> 9) & 0x01) != 0) } # [doc = "Bit 10 - TX FIFO Underflowed"]
# [inline (always)]
pub fn txunderflow (& self) -> TXUNDERFLOW_R { TXUNDERFLOW_R :: new (((self . bits >> 10) & 0x01) != 0) } # [doc = "Bit 11 - TX FIFO Overflowed"]
# [inline (always)]
pub fn rxoverflow (& self) -> RXOVERFLOW_R { RXOVERFLOW_R :: new (((self . bits >> 11) & 0x01) != 0) } # [doc = "Bit 12 - TX FIFO Ready"]
# [inline (always)]
pub fn txready (& self) -> TXREADY_R { TXREADY_R :: new (((self . bits >> 12) & 0x01) != 0) } # [doc = "Bit 13 - RX FIFO Ready"]
# [inline (always)]
pub fn rxready (& self) -> RXREADY_R { RXREADY_R :: new (((self . bits >> 13) & 0x01) != 0) } # [doc = "Bit 14 - TX FIFO Empty"]
# [inline (always)]
pub fn txempty (& self) -> TXEMPTY_R { TXEMPTY_R :: new (((self . bits >> 14) & 0x01) != 0) } # [doc = "Bit 15 - RX FIFO Full"]
# [inline (always)]
pub fn rxfull (& self) -> RXFULL_R { RXFULL_R :: new (((self . bits >> 15) & 0x01) != 0) } } impl W { # [doc = "Bit 0 - Controller Complted a Transaction"]
# [inline (always)]
pub fn completed (& mut self) -> COMPLETED_W { COMPLETED_W { w : self } } # [doc = "Bit 1 - Controller is Idle"]
# [inline (always)]
pub fn idle (& mut self) -> IDLE_W { IDLE_W { w : self } } # [doc = "Bit 2 - Controller is Waiting"]
# [inline (always)]
pub fn waiting (& mut self) -> WAITING_W { WAITING_W { w : self } } # [doc = "Bit 3 - Controller is Tx Stalled"]
# [inline (always)]
pub fn txstalled (& mut self) -> TXSTALLED_W { TXSTALLED_W { w : self } } # [doc = "Bit 4 - Controller is Rx Stalled"]
# [inline (always)]
pub fn rxstalled (& mut self) -> RXSTALLED_W { RXSTALLED_W { w : self } } # [doc = "Bit 5 - I2C Address Match"]
# [inline (always)]
pub fn addressmatch (& mut self) -> ADDRESSMATCH_W { ADDRESSMATCH_W { w : self } } # [doc = "Bit 6 - I2C Data was not Acknowledged"]
# [inline (always)]
pub fn nackdata (& mut self) -> NACKDATA_W { NACKDATA_W { w : self } } # [doc = "Bit 7 - Pending Data is first Byte following Address"]
# [inline (always)]
pub fn rxdatafirst (& mut self) -> RXDATAFIRST_W { RXDATAFIRST_W { w : self } } # [doc = "Bit 8 - I2C Start Condition"]
# [inline (always)]
pub fn i2c_start (& mut self) -> I2C_START_W { I2C_START_W { w : self } } # [doc = "Bit 9 - I2C Stop Condition"]
# [inline (always)]
pub fn i2c_stop (& mut self) -> I2C_STOP_W { I2C_STOP_W { w : self } } # [doc = "Bit 10 - TX FIFO Underflowed"]
# [inline (always)]
pub fn txunderflow (& mut self) -> TXUNDERFLOW_W { TXUNDERFLOW_W { w : self } } # [doc = "Bit 11 - TX FIFO Overflowed"]
# [inline (always)]
pub fn rxoverflow (& mut self) -> RXOVERFLOW_W { RXOVERFLOW_W { w : self } } # [doc = "Bit 12 - TX FIFO Ready"]
# [inline (always)]
pub fn txready (& mut self) -> TXREADY_W { TXREADY_W { w : self } } # [doc = "Bit 13 - RX FIFO Ready"]
# [inline (always)]
pub fn rxready (& mut self) -> RXREADY_W { RXREADY_W { w : self } } # [doc = "Bit 14 - TX FIFO Empty"]
# [inline (always)]
pub fn txempty (& mut self) -> TXEMPTY_W { TXEMPTY_W { w : self } } # [doc = "Bit 15 - RX FIFO Full"]
# [inline (always)]
pub fn rxfull (& mut self) -> RXFULL_W { RXFULL_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Slave Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_irq_enb](index.html) module"]
pub struct S0_IRQ_ENB_SPEC ; impl crate :: RegisterSpec for S0_IRQ_ENB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [s0_irq_enb::R](R) reader structure"]
impl crate :: Readable for S0_IRQ_ENB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [s0_irq_enb::W](W) writer structure"]
impl crate :: Writable for S0_IRQ_ENB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets S0_IRQ_ENB to value 0"]
impl crate :: Resettable for S0_IRQ_ENB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_IRQ_RAW register accessor: an alias for `Reg<S0_IRQ_RAW_SPEC>`"]
pub type S0_IRQ_RAW = crate :: Reg < s0_irq_raw :: S0_IRQ_RAW_SPEC > ; # [doc = "Slave Raw Interrupt Status Register"]
pub mod s0_irq_raw { # [doc = "Register `S0_IRQ_RAW` reader"]
pub struct R (crate :: R < S0_IRQ_RAW_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < S0_IRQ_RAW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < S0_IRQ_RAW_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < S0_IRQ_RAW_SPEC >) -> Self { R (reader) } } # [doc = "Field `COMPLETED` reader - Controller Complted a Transaction"]
pub struct COMPLETED_R (crate :: FieldReader < bool , bool >) ; impl COMPLETED_R { pub (crate) fn new (bits : bool) -> Self { COMPLETED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for COMPLETED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IDLE` reader - Controller is Idle"]
pub struct IDLE_R (crate :: FieldReader < bool , bool >) ; impl IDLE_R { pub (crate) fn new (bits : bool) -> Self { IDLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IDLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `WAITING` reader - Controller is Waiting"]
pub struct WAITING_R (crate :: FieldReader < bool , bool >) ; impl WAITING_R { pub (crate) fn new (bits : bool) -> Self { WAITING_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for WAITING_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXSTALLED` reader - Controller is Tx Stalled"]
pub struct TXSTALLED_R (crate :: FieldReader < bool , bool >) ; impl TXSTALLED_R { pub (crate) fn new (bits : bool) -> Self { TXSTALLED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXSTALLED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXSTALLED` reader - Controller is Rx Stalled"]
pub struct RXSTALLED_R (crate :: FieldReader < bool , bool >) ; impl RXSTALLED_R { pub (crate) fn new (bits : bool) -> Self { RXSTALLED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXSTALLED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ADDRESSMATCH` reader - I2C Address Match"]
pub struct ADDRESSMATCH_R (crate :: FieldReader < bool , bool >) ; impl ADDRESSMATCH_R { pub (crate) fn new (bits : bool) -> Self { ADDRESSMATCH_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ADDRESSMATCH_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `NACKDATA` reader - I2C Data was not Acknowledged"]
pub struct NACKDATA_R (crate :: FieldReader < bool , bool >) ; impl NACKDATA_R { pub (crate) fn new (bits : bool) -> Self { NACKDATA_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for NACKDATA_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXDATAFIRST` reader - Pending Data is first Byte following Address"]
pub struct RXDATAFIRST_R (crate :: FieldReader < bool , bool >) ; impl RXDATAFIRST_R { pub (crate) fn new (bits : bool) -> Self { RXDATAFIRST_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXDATAFIRST_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `I2C_START` reader - I2C Start Condition"]
pub struct I2C_START_R (crate :: FieldReader < bool , bool >) ; impl I2C_START_R { pub (crate) fn new (bits : bool) -> Self { I2C_START_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for I2C_START_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `I2C_STOP` reader - I2C Stop Condition"]
pub struct I2C_STOP_R (crate :: FieldReader < bool , bool >) ; impl I2C_STOP_R { pub (crate) fn new (bits : bool) -> Self { I2C_STOP_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for I2C_STOP_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXUNDERFLOW` reader - TX FIFO Underflowed"]
pub struct TXUNDERFLOW_R (crate :: FieldReader < bool , bool >) ; impl TXUNDERFLOW_R { pub (crate) fn new (bits : bool) -> Self { TXUNDERFLOW_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXUNDERFLOW_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXOVERFLOW` reader - TX FIFO Overflowed"]
pub struct RXOVERFLOW_R (crate :: FieldReader < bool , bool >) ; impl RXOVERFLOW_R { pub (crate) fn new (bits : bool) -> Self { RXOVERFLOW_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXOVERFLOW_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXREADY` reader - TX FIFO Ready"]
pub struct TXREADY_R (crate :: FieldReader < bool , bool >) ; impl TXREADY_R { pub (crate) fn new (bits : bool) -> Self { TXREADY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXREADY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXREADY` reader - RX FIFO Ready"]
pub struct RXREADY_R (crate :: FieldReader < bool , bool >) ; impl RXREADY_R { pub (crate) fn new (bits : bool) -> Self { RXREADY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXREADY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXEMPTY` reader - TX FIFO Empty"]
pub struct TXEMPTY_R (crate :: FieldReader < bool , bool >) ; impl TXEMPTY_R { pub (crate) fn new (bits : bool) -> Self { TXEMPTY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXEMPTY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXFULL` reader - RX FIFO Full"]
pub struct RXFULL_R (crate :: FieldReader < bool , bool >) ; impl RXFULL_R { pub (crate) fn new (bits : bool) -> Self { RXFULL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXFULL_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - Controller Complted a Transaction"]
# [inline (always)]
pub fn completed (& self) -> COMPLETED_R { COMPLETED_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - Controller is Idle"]
# [inline (always)]
pub fn idle (& self) -> IDLE_R { IDLE_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - Controller is Waiting"]
# [inline (always)]
pub fn waiting (& self) -> WAITING_R { WAITING_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - Controller is Tx Stalled"]
# [inline (always)]
pub fn txstalled (& self) -> TXSTALLED_R { TXSTALLED_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - Controller is Rx Stalled"]
# [inline (always)]
pub fn rxstalled (& self) -> RXSTALLED_R { RXSTALLED_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - I2C Address Match"]
# [inline (always)]
pub fn addressmatch (& self) -> ADDRESSMATCH_R { ADDRESSMATCH_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - I2C Data was not Acknowledged"]
# [inline (always)]
pub fn nackdata (& self) -> NACKDATA_R { NACKDATA_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - Pending Data is first Byte following Address"]
# [inline (always)]
pub fn rxdatafirst (& self) -> RXDATAFIRST_R { RXDATAFIRST_R :: new (((self . bits >> 7) & 0x01) != 0) } # [doc = "Bit 8 - I2C Start Condition"]
# [inline (always)]
pub fn i2c_start (& self) -> I2C_START_R { I2C_START_R :: new (((self . bits >> 8) & 0x01) != 0) } # [doc = "Bit 9 - I2C Stop Condition"]
# [inline (always)]
pub fn i2c_stop (& self) -> I2C_STOP_R { I2C_STOP_R :: new (((self . bits >> 9) & 0x01) != 0) } # [doc = "Bit 10 - TX FIFO Underflowed"]
# [inline (always)]
pub fn txunderflow (& self) -> TXUNDERFLOW_R { TXUNDERFLOW_R :: new (((self . bits >> 10) & 0x01) != 0) } # [doc = "Bit 11 - TX FIFO Overflowed"]
# [inline (always)]
pub fn rxoverflow (& self) -> RXOVERFLOW_R { RXOVERFLOW_R :: new (((self . bits >> 11) & 0x01) != 0) } # [doc = "Bit 12 - TX FIFO Ready"]
# [inline (always)]
pub fn txready (& self) -> TXREADY_R { TXREADY_R :: new (((self . bits >> 12) & 0x01) != 0) } # [doc = "Bit 13 - RX FIFO Ready"]
# [inline (always)]
pub fn rxready (& self) -> RXREADY_R { RXREADY_R :: new (((self . bits >> 13) & 0x01) != 0) } # [doc = "Bit 14 - TX FIFO Empty"]
# [inline (always)]
pub fn txempty (& self) -> TXEMPTY_R { TXEMPTY_R :: new (((self . bits >> 14) & 0x01) != 0) } # [doc = "Bit 15 - RX FIFO Full"]
# [inline (always)]
pub fn rxfull (& self) -> RXFULL_R { RXFULL_R :: new (((self . bits >> 15) & 0x01) != 0) } } # [doc = "Slave Raw Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_irq_raw](index.html) module"]
pub struct S0_IRQ_RAW_SPEC ; impl crate :: RegisterSpec for S0_IRQ_RAW_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [s0_irq_raw::R](R) reader structure"]
impl crate :: Readable for S0_IRQ_RAW_SPEC { type Reader = R ; } # [doc = "`reset()` method sets S0_IRQ_RAW to value 0"]
impl crate :: Resettable for S0_IRQ_RAW_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_IRQ_END register accessor: an alias for `Reg<S0_IRQ_END_SPEC>`"]
pub type S0_IRQ_END = crate :: Reg < s0_irq_end :: S0_IRQ_END_SPEC > ; # [doc = "Slave Enabled Interrupt Status Register"]
pub mod s0_irq_end { # [doc = "Register `S0_IRQ_END` reader"]
pub struct R (crate :: R < S0_IRQ_END_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < S0_IRQ_END_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < S0_IRQ_END_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < S0_IRQ_END_SPEC >) -> Self { R (reader) } } # [doc = "Field `COMPLETED` reader - Controller Complted a Transaction"]
pub struct COMPLETED_R (crate :: FieldReader < bool , bool >) ; impl COMPLETED_R { pub (crate) fn new (bits : bool) -> Self { COMPLETED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for COMPLETED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `IDLE` reader - Controller is Idle"]
pub struct IDLE_R (crate :: FieldReader < bool , bool >) ; impl IDLE_R { pub (crate) fn new (bits : bool) -> Self { IDLE_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for IDLE_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `WAITING` reader - Controller is Waiting"]
pub struct WAITING_R (crate :: FieldReader < bool , bool >) ; impl WAITING_R { pub (crate) fn new (bits : bool) -> Self { WAITING_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for WAITING_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXSTALLED` reader - Controller is Tx Stalled"]
pub struct TXSTALLED_R (crate :: FieldReader < bool , bool >) ; impl TXSTALLED_R { pub (crate) fn new (bits : bool) -> Self { TXSTALLED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXSTALLED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXSTALLED` reader - Controller is Rx Stalled"]
pub struct RXSTALLED_R (crate :: FieldReader < bool , bool >) ; impl RXSTALLED_R { pub (crate) fn new (bits : bool) -> Self { RXSTALLED_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXSTALLED_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `ADDRESSMATCH` reader - I2C Address Match"]
pub struct ADDRESSMATCH_R (crate :: FieldReader < bool , bool >) ; impl ADDRESSMATCH_R { pub (crate) fn new (bits : bool) -> Self { ADDRESSMATCH_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for ADDRESSMATCH_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `NACKDATA` reader - I2C Data was not Acknowledged"]
pub struct NACKDATA_R (crate :: FieldReader < bool , bool >) ; impl NACKDATA_R { pub (crate) fn new (bits : bool) -> Self { NACKDATA_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for NACKDATA_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXDATAFIRST` reader - Pending Data is first Byte following Address"]
pub struct RXDATAFIRST_R (crate :: FieldReader < bool , bool >) ; impl RXDATAFIRST_R { pub (crate) fn new (bits : bool) -> Self { RXDATAFIRST_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXDATAFIRST_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `I2C_START` reader - I2C Start Condition"]
pub struct I2C_START_R (crate :: FieldReader < bool , bool >) ; impl I2C_START_R { pub (crate) fn new (bits : bool) -> Self { I2C_START_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for I2C_START_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `I2C_STOP` reader - I2C Stop Condition"]
pub struct I2C_STOP_R (crate :: FieldReader < bool , bool >) ; impl I2C_STOP_R { pub (crate) fn new (bits : bool) -> Self { I2C_STOP_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for I2C_STOP_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXUNDERFLOW` reader - TX FIFO Underflowed"]
pub struct TXUNDERFLOW_R (crate :: FieldReader < bool , bool >) ; impl TXUNDERFLOW_R { pub (crate) fn new (bits : bool) -> Self { TXUNDERFLOW_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXUNDERFLOW_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXOVERFLOW` reader - TX FIFO Overflowed"]
pub struct RXOVERFLOW_R (crate :: FieldReader < bool , bool >) ; impl RXOVERFLOW_R { pub (crate) fn new (bits : bool) -> Self { RXOVERFLOW_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXOVERFLOW_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXREADY` reader - TX FIFO Ready"]
pub struct TXREADY_R (crate :: FieldReader < bool , bool >) ; impl TXREADY_R { pub (crate) fn new (bits : bool) -> Self { TXREADY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXREADY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXREADY` reader - RX FIFO Ready"]
pub struct RXREADY_R (crate :: FieldReader < bool , bool >) ; impl RXREADY_R { pub (crate) fn new (bits : bool) -> Self { RXREADY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXREADY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `TXEMPTY` reader - TX FIFO Empty"]
pub struct TXEMPTY_R (crate :: FieldReader < bool , bool >) ; impl TXEMPTY_R { pub (crate) fn new (bits : bool) -> Self { TXEMPTY_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for TXEMPTY_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } # [doc = "Field `RXFULL` reader - RX FIFO Full"]
pub struct RXFULL_R (crate :: FieldReader < bool , bool >) ; impl RXFULL_R { pub (crate) fn new (bits : bool) -> Self { RXFULL_R (crate :: FieldReader :: new (bits)) } } impl core :: ops :: Deref for RXFULL_R { type Target = crate :: FieldReader < bool , bool > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl R { # [doc = "Bit 0 - Controller Complted a Transaction"]
# [inline (always)]
pub fn completed (& self) -> COMPLETED_R { COMPLETED_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - Controller is Idle"]
# [inline (always)]
pub fn idle (& self) -> IDLE_R { IDLE_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - Controller is Waiting"]
# [inline (always)]
pub fn waiting (& self) -> WAITING_R { WAITING_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - Controller is Tx Stalled"]
# [inline (always)]
pub fn txstalled (& self) -> TXSTALLED_R { TXSTALLED_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - Controller is Rx Stalled"]
# [inline (always)]
pub fn rxstalled (& self) -> RXSTALLED_R { RXSTALLED_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - I2C Address Match"]
# [inline (always)]
pub fn addressmatch (& self) -> ADDRESSMATCH_R { ADDRESSMATCH_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - I2C Data was not Acknowledged"]
# [inline (always)]
pub fn nackdata (& self) -> NACKDATA_R { NACKDATA_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - Pending Data is first Byte following Address"]
# [inline (always)]
pub fn rxdatafirst (& self) -> RXDATAFIRST_R { RXDATAFIRST_R :: new (((self . bits >> 7) & 0x01) != 0) } # [doc = "Bit 8 - I2C Start Condition"]
# [inline (always)]
pub fn i2c_start (& self) -> I2C_START_R { I2C_START_R :: new (((self . bits >> 8) & 0x01) != 0) } # [doc = "Bit 9 - I2C Stop Condition"]
# [inline (always)]
pub fn i2c_stop (& self) -> I2C_STOP_R { I2C_STOP_R :: new (((self . bits >> 9) & 0x01) != 0) } # [doc = "Bit 10 - TX FIFO Underflowed"]
# [inline (always)]
pub fn txunderflow (& self) -> TXUNDERFLOW_R { TXUNDERFLOW_R :: new (((self . bits >> 10) & 0x01) != 0) } # [doc = "Bit 11 - TX FIFO Overflowed"]
# [inline (always)]
pub fn rxoverflow (& self) -> RXOVERFLOW_R { RXOVERFLOW_R :: new (((self . bits >> 11) & 0x01) != 0) } # [doc = "Bit 12 - TX FIFO Ready"]
# [inline (always)]
pub fn txready (& self) -> TXREADY_R { TXREADY_R :: new (((self . bits >> 12) & 0x01) != 0) } # [doc = "Bit 13 - RX FIFO Ready"]
# [inline (always)]
pub fn rxready (& self) -> RXREADY_R { RXREADY_R :: new (((self . bits >> 13) & 0x01) != 0) } # [doc = "Bit 14 - TX FIFO Empty"]
# [inline (always)]
pub fn txempty (& self) -> TXEMPTY_R { TXEMPTY_R :: new (((self . bits >> 14) & 0x01) != 0) } # [doc = "Bit 15 - RX FIFO Full"]
# [inline (always)]
pub fn rxfull (& self) -> RXFULL_R { RXFULL_R :: new (((self . bits >> 15) & 0x01) != 0) } } # [doc = "Slave Enabled Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_irq_end](index.html) module"]
pub struct S0_IRQ_END_SPEC ; impl crate :: RegisterSpec for S0_IRQ_END_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [s0_irq_end::R](R) reader structure"]
impl crate :: Readable for S0_IRQ_END_SPEC { type Reader = R ; } # [doc = "`reset()` method sets S0_IRQ_END to value 0"]
impl crate :: Resettable for S0_IRQ_END_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_IRQ_CLR register accessor: an alias for `Reg<S0_IRQ_CLR_SPEC>`"]
pub type S0_IRQ_CLR = crate :: Reg < s0_irq_clr :: S0_IRQ_CLR_SPEC > ; # [doc = "Slave Clear Interrupt Status Register"]
pub mod s0_irq_clr { # [doc = "Register `S0_IRQ_CLR` writer"]
pub struct W (crate :: W < S0_IRQ_CLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < S0_IRQ_CLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < S0_IRQ_CLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < S0_IRQ_CLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `COMPLETED` writer - Controller Complted a Transaction"]
pub struct COMPLETED_W < 'a > { w : & 'a mut W , } impl < 'a > COMPLETED_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `IDLE` writer - Controller is Idle"]
pub struct IDLE_W < 'a > { w : & 'a mut W , } impl < 'a > IDLE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } # [doc = "Field `WAITING` writer - Controller is Waiting"]
pub struct WAITING_W < 'a > { w : & 'a mut W , } impl < 'a > WAITING_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | ((value as u32 & 0x01) << 2) ; self . w } } # [doc = "Field `TXSTALLED` writer - Controller is Tx Stalled"]
pub struct TXSTALLED_W < 'a > { w : & 'a mut W , } impl < 'a > TXSTALLED_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | ((value as u32 & 0x01) << 3) ; self . w } } # [doc = "Field `RXSTALLED` writer - Controller is Rx Stalled"]
pub struct RXSTALLED_W < 'a > { w : & 'a mut W , } impl < 'a > RXSTALLED_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 4)) | ((value as u32 & 0x01) << 4) ; self . w } } # [doc = "Field `ADDRESSMATCH` writer - I2C Address Match"]
pub struct ADDRESSMATCH_W < 'a > { w : & 'a mut W , } impl < 'a > ADDRESSMATCH_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 5)) | ((value as u32 & 0x01) << 5) ; self . w } } # [doc = "Field `NACKDATA` writer - I2C Data was not Acknowledged"]
pub struct NACKDATA_W < 'a > { w : & 'a mut W , } impl < 'a > NACKDATA_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | ((value as u32 & 0x01) << 6) ; self . w } } # [doc = "Field `RXDATAFIRST` writer - Pending Data is first Byte following Address"]
pub struct RXDATAFIRST_W < 'a > { w : & 'a mut W , } impl < 'a > RXDATAFIRST_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | ((value as u32 & 0x01) << 7) ; self . w } } # [doc = "Field `I2C_START` writer - I2C Start Condition"]
pub struct I2C_START_W < 'a > { w : & 'a mut W , } impl < 'a > I2C_START_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 8)) | ((value as u32 & 0x01) << 8) ; self . w } } # [doc = "Field `I2C_STOP` writer - I2C Stop Condition"]
pub struct I2C_STOP_W < 'a > { w : & 'a mut W , } impl < 'a > I2C_STOP_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 9)) | ((value as u32 & 0x01) << 9) ; self . w } } # [doc = "Field `TXUNDERFLOW` writer - TX FIFO Underflowed"]
pub struct TXUNDERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > TXUNDERFLOW_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 10)) | ((value as u32 & 0x01) << 10) ; self . w } } # [doc = "Field `RXOVERFLOW` writer - TX FIFO Overflowed"]
pub struct RXOVERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > RXOVERFLOW_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 11)) | ((value as u32 & 0x01) << 11) ; self . w } } # [doc = "Field `TXREADY` writer - TX FIFO Ready"]
pub struct TXREADY_W < 'a > { w : & 'a mut W , } impl < 'a > TXREADY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 12)) | ((value as u32 & 0x01) << 12) ; self . w } } # [doc = "Field `RXREADY` writer - RX FIFO Ready"]
pub struct RXREADY_W < 'a > { w : & 'a mut W , } impl < 'a > RXREADY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 13)) | ((value as u32 & 0x01) << 13) ; self . w } } # [doc = "Field `TXEMPTY` writer - TX FIFO Empty"]
pub struct TXEMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > TXEMPTY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 14)) | ((value as u32 & 0x01) << 14) ; self . w } } # [doc = "Field `RXFULL` writer - RX FIFO Full"]
pub struct RXFULL_W < 'a > { w : & 'a mut W , } impl < 'a > RXFULL_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 15)) | ((value as u32 & 0x01) << 15) ; self . w } } impl W { # [doc = "Bit 0 - Controller Complted a Transaction"]
# [inline (always)]
pub fn completed (& mut self) -> COMPLETED_W { COMPLETED_W { w : self } } # [doc = "Bit 1 - Controller is Idle"]
# [inline (always)]
pub fn idle (& mut self) -> IDLE_W { IDLE_W { w : self } } # [doc = "Bit 2 - Controller is Waiting"]
# [inline (always)]
pub fn waiting (& mut self) -> WAITING_W { WAITING_W { w : self } } # [doc = "Bit 3 - Controller is Tx Stalled"]
# [inline (always)]
pub fn txstalled (& mut self) -> TXSTALLED_W { TXSTALLED_W { w : self } } # [doc = "Bit 4 - Controller is Rx Stalled"]
# [inline (always)]
pub fn rxstalled (& mut self) -> RXSTALLED_W { RXSTALLED_W { w : self } } # [doc = "Bit 5 - I2C Address Match"]
# [inline (always)]
pub fn addressmatch (& mut self) -> ADDRESSMATCH_W { ADDRESSMATCH_W { w : self } } # [doc = "Bit 6 - I2C Data was not Acknowledged"]
# [inline (always)]
pub fn nackdata (& mut self) -> NACKDATA_W { NACKDATA_W { w : self } } # [doc = "Bit 7 - Pending Data is first Byte following Address"]
# [inline (always)]
pub fn rxdatafirst (& mut self) -> RXDATAFIRST_W { RXDATAFIRST_W { w : self } } # [doc = "Bit 8 - I2C Start Condition"]
# [inline (always)]
pub fn i2c_start (& mut self) -> I2C_START_W { I2C_START_W { w : self } } # [doc = "Bit 9 - I2C Stop Condition"]
# [inline (always)]
pub fn i2c_stop (& mut self) -> I2C_STOP_W { I2C_STOP_W { w : self } } # [doc = "Bit 10 - TX FIFO Underflowed"]
# [inline (always)]
pub fn txunderflow (& mut self) -> TXUNDERFLOW_W { TXUNDERFLOW_W { w : self } } # [doc = "Bit 11 - TX FIFO Overflowed"]
# [inline (always)]
pub fn rxoverflow (& mut self) -> RXOVERFLOW_W { RXOVERFLOW_W { w : self } } # [doc = "Bit 12 - TX FIFO Ready"]
# [inline (always)]
pub fn txready (& mut self) -> TXREADY_W { TXREADY_W { w : self } } # [doc = "Bit 13 - RX FIFO Ready"]
# [inline (always)]
pub fn rxready (& mut self) -> RXREADY_W { RXREADY_W { w : self } } # [doc = "Bit 14 - TX FIFO Empty"]
# [inline (always)]
pub fn txempty (& mut self) -> TXEMPTY_W { TXEMPTY_W { w : self } } # [doc = "Bit 15 - RX FIFO Full"]
# [inline (always)]
pub fn rxfull (& mut self) -> RXFULL_W { RXFULL_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Slave Clear Interrupt Status Register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_irq_clr](index.html) module"]
pub struct S0_IRQ_CLR_SPEC ; impl crate :: RegisterSpec for S0_IRQ_CLR_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [s0_irq_clr::W](W) writer structure"]
impl crate :: Writable for S0_IRQ_CLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets S0_IRQ_CLR to value 0"]
impl crate :: Resettable for S0_IRQ_CLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_RXFIFOIRQTRG register accessor: an alias for `Reg<S0_RXFIFOIRQTRG_SPEC>`"]
pub type S0_RXFIFOIRQTRG = crate :: Reg < s0_rxfifoirqtrg :: S0_RXFIFOIRQTRG_SPEC > ; # [doc = "Slave Rx FIFO IRQ Trigger Level"]
pub mod s0_rxfifoirqtrg { # [doc = "Register `S0_RXFIFOIRQTRG` reader"]
pub struct R (crate :: R < S0_RXFIFOIRQTRG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < S0_RXFIFOIRQTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < S0_RXFIFOIRQTRG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < S0_RXFIFOIRQTRG_SPEC >) -> Self { R (reader) } } # [doc = "Register `S0_RXFIFOIRQTRG` writer"]
pub struct W (crate :: W < S0_RXFIFOIRQTRG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < S0_RXFIFOIRQTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < S0_RXFIFOIRQTRG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < S0_RXFIFOIRQTRG_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Slave Rx FIFO IRQ Trigger Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_rxfifoirqtrg](index.html) module"]
pub struct S0_RXFIFOIRQTRG_SPEC ; impl crate :: RegisterSpec for S0_RXFIFOIRQTRG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [s0_rxfifoirqtrg::R](R) reader structure"]
impl crate :: Readable for S0_RXFIFOIRQTRG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [s0_rxfifoirqtrg::W](W) writer structure"]
impl crate :: Writable for S0_RXFIFOIRQTRG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets S0_RXFIFOIRQTRG to value 0"]
impl crate :: Resettable for S0_RXFIFOIRQTRG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_TXFIFOIRQTRG register accessor: an alias for `Reg<S0_TXFIFOIRQTRG_SPEC>`"]
pub type S0_TXFIFOIRQTRG = crate :: Reg < s0_txfifoirqtrg :: S0_TXFIFOIRQTRG_SPEC > ; # [doc = "Slave Tx FIFO IRQ Trigger Level"]
pub mod s0_txfifoirqtrg { # [doc = "Register `S0_TXFIFOIRQTRG` reader"]
pub struct R (crate :: R < S0_TXFIFOIRQTRG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < S0_TXFIFOIRQTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < S0_TXFIFOIRQTRG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < S0_TXFIFOIRQTRG_SPEC >) -> Self { R (reader) } } # [doc = "Register `S0_TXFIFOIRQTRG` writer"]
pub struct W (crate :: W < S0_TXFIFOIRQTRG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < S0_TXFIFOIRQTRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < S0_TXFIFOIRQTRG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < S0_TXFIFOIRQTRG_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Slave Tx FIFO IRQ Trigger Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_txfifoirqtrg](index.html) module"]
pub struct S0_TXFIFOIRQTRG_SPEC ; impl crate :: RegisterSpec for S0_TXFIFOIRQTRG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [s0_txfifoirqtrg::R](R) reader structure"]
impl crate :: Readable for S0_TXFIFOIRQTRG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [s0_txfifoirqtrg::W](W) writer structure"]
impl crate :: Writable for S0_TXFIFOIRQTRG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets S0_TXFIFOIRQTRG to value 0"]
impl crate :: Resettable for S0_TXFIFOIRQTRG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_FIFO_CLR register accessor: an alias for `Reg<S0_FIFO_CLR_SPEC>`"]
pub type S0_FIFO_CLR = crate :: Reg < s0_fifo_clr :: S0_FIFO_CLR_SPEC > ; # [doc = "Slave Clear FIFO Register"]
pub mod s0_fifo_clr { # [doc = "Register `S0_FIFO_CLR` writer"]
pub struct W (crate :: W < S0_FIFO_CLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < S0_FIFO_CLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < S0_FIFO_CLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < S0_FIFO_CLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXFIFO` writer - Clear Rx FIFO"]
pub struct RXFIFO_W < 'a > { w : & 'a mut W , } impl < 'a > RXFIFO_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | (value as u32 & 0x01) ; self . w } } # [doc = "Field `TXFIFO` writer - Clear Tx FIFO"]
pub struct TXFIFO_W < 'a > { w : & 'a mut W , } impl < 'a > TXFIFO_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | ((value as u32 & 0x01) << 1) ; self . w } } impl W { # [doc = "Bit 0 - Clear Rx FIFO"]
# [inline (always)]
pub fn rxfifo (& mut self) -> RXFIFO_W { RXFIFO_W { w : self } } # [doc = "Bit 1 - Clear Tx FIFO"]
# [inline (always)]
pub fn txfifo (& mut self) -> TXFIFO_W { TXFIFO_W { w : self } } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Slave Clear FIFO Register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_fifo_clr](index.html) module"]
pub struct S0_FIFO_CLR_SPEC ; impl crate :: RegisterSpec for S0_FIFO_CLR_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [s0_fifo_clr::W](W) writer structure"]
impl crate :: Writable for S0_FIFO_CLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets S0_FIFO_CLR to value 0"]
impl crate :: Resettable for S0_FIFO_CLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_ADDRESSB register accessor: an alias for `Reg<S0_ADDRESSB_SPEC>`"]
pub type S0_ADDRESSB = crate :: Reg < s0_addressb :: S0_ADDRESSB_SPEC > ; # [doc = "Slave I2C Address B Value"]
pub mod s0_addressb { # [doc = "Register `S0_ADDRESSB` reader"]
pub struct R (crate :: R < S0_ADDRESSB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < S0_ADDRESSB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < S0_ADDRESSB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < S0_ADDRESSB_SPEC >) -> Self { R (reader) } } # [doc = "Register `S0_ADDRESSB` writer"]
pub struct W (crate :: W < S0_ADDRESSB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < S0_ADDRESSB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < S0_ADDRESSB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < S0_ADDRESSB_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Slave I2C Address B Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_addressb](index.html) module"]
pub struct S0_ADDRESSB_SPEC ; impl crate :: RegisterSpec for S0_ADDRESSB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [s0_addressb::R](R) reader structure"]
impl crate :: Readable for S0_ADDRESSB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [s0_addressb::W](W) writer structure"]
impl crate :: Writable for S0_ADDRESSB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets S0_ADDRESSB to value 0"]
impl crate :: Resettable for S0_ADDRESSB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "S0_ADDRESSMASKB register accessor: an alias for `Reg<S0_ADDRESSMASKB_SPEC>`"]
pub type S0_ADDRESSMASKB = crate :: Reg < s0_addressmaskb :: S0_ADDRESSMASKB_SPEC > ; # [doc = "Slave I2C Address B Mask value"]
pub mod s0_addressmaskb { # [doc = "Register `S0_ADDRESSMASKB` reader"]
pub struct R (crate :: R < S0_ADDRESSMASKB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < S0_ADDRESSMASKB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < S0_ADDRESSMASKB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < S0_ADDRESSMASKB_SPEC >) -> Self { R (reader) } } # [doc = "Register `S0_ADDRESSMASKB` writer"]
pub struct W (crate :: W < S0_ADDRESSMASKB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < S0_ADDRESSMASKB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < S0_ADDRESSMASKB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < S0_ADDRESSMASKB_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Slave I2C Address B Mask value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s0_addressmaskb](index.html) module"]
pub struct S0_ADDRESSMASKB_SPEC ; impl crate :: RegisterSpec for S0_ADDRESSMASKB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [s0_addressmaskb::R](R) reader structure"]
impl crate :: Readable for S0_ADDRESSMASKB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [s0_addressmaskb::W](W) writer structure"]
impl crate :: Writable for S0_ADDRESSMASKB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets S0_ADDRESSMASKB to value 0"]
impl crate :: Resettable for S0_ADDRESSMASKB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PERID register accessor: an alias for `Reg<PERID_SPEC>`"]
pub type PERID = crate :: Reg < perid :: PERID_SPEC > ; # [doc = "Peripheral ID Register"]
pub mod perid { # [doc = "Register `PERID` reader"]
pub struct R (crate :: R < PERID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERID_SPEC >) -> Self { R (reader) } } # [doc = "Peripheral ID Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perid](index.html) module"]
pub struct PERID_SPEC ; impl crate :: RegisterSpec for PERID_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [perid::R](R) reader structure"]
impl crate :: Readable for PERID_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PERID to value 0x0014_07e1"]
impl crate :: Resettable for PERID_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x0014_07e1 } } } } # [doc = "I2C Peripheral"]
pub struct I2CB { _marker : PhantomData < * const () > } unsafe impl Send for I2CB { } impl I2CB { # [doc = r"Pointer to the register block"]
pub const PTR : * const i2ca :: RegisterBlock = 0x4006_1000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const i2ca :: RegisterBlock { Self :: PTR } } impl Deref for I2CB { type Target = i2ca :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for I2CB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2CB") . finish () } } # [no_mangle]
static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r"All the peripherals"]
# [allow (non_snake_case)]
pub struct Peripherals { # [doc = "SYSCONFIG"]
pub SYSCONFIG : SYSCONFIG , # [doc = "IRQSEL"]
pub IRQSEL : IRQSEL , # [doc = "IOCONFIG"]
pub IOCONFIG : IOCONFIG , # [doc = "UTILITY"]
pub UTILITY : UTILITY , # [doc = "PORTA"]
pub PORTA : PORTA , # [doc = "PORTB"]
pub PORTB : PORTB , # [doc = "TIM0"]
pub TIM0 : TIM0 , # [doc = "TIM1"]
pub TIM1 : TIM1 , # [doc = "TIM2"]
pub TIM2 : TIM2 , # [doc = "TIM3"]
pub TIM3 : TIM3 , # [doc = "TIM4"]
pub TIM4 : TIM4 , # [doc = "TIM5"]
pub TIM5 : TIM5 , # [doc = "TIM6"]
pub TIM6 : TIM6 , # [doc = "TIM7"]
pub TIM7 : TIM7 , # [doc = "TIM8"]
pub TIM8 : TIM8 , # [doc = "TIM9"]
pub TIM9 : TIM9 , # [doc = "TIM10"]
pub TIM10 : TIM10 , # [doc = "TIM11"]
pub TIM11 : TIM11 , # [doc = "TIM12"]
pub TIM12 : TIM12 , # [doc = "TIM13"]
pub TIM13 : TIM13 , # [doc = "TIM14"]
pub TIM14 : TIM14 , # [doc = "TIM15"]
pub TIM15 : TIM15 , # [doc = "TIM16"]
pub TIM16 : TIM16 , # [doc = "TIM17"]
pub TIM17 : TIM17 , # [doc = "TIM18"]
pub TIM18 : TIM18 , # [doc = "TIM19"]
pub TIM19 : TIM19 , # [doc = "TIM20"]
pub TIM20 : TIM20 , # [doc = "TIM21"]
pub TIM21 : TIM21 , # [doc = "TIM22"]
pub TIM22 : TIM22 , # [doc = "TIM23"]
pub TIM23 : TIM23 , # [doc = "UARTA"]
pub UARTA : UARTA , # [doc = "UARTB"]
pub UARTB : UARTB , # [doc = "SPIA"]
pub SPIA : SPIA , # [doc = "SPIB"]
pub SPIB : SPIB , # [doc = "SPIC"]
pub SPIC : SPIC , # [doc = "I2CA"]
pub I2CA : I2CA , # [doc = "I2CB"]
pub I2CB : I2CB , } impl Peripherals { # [doc = r"Returns all the peripherals *once*"]
# [inline]
pub fn take () -> Option < Self > { cortex_m :: interrupt :: free (| _ | { if unsafe { DEVICE_PERIPHERALS } { None } else { Some (unsafe { Peripherals :: steal () }) } }) } # [doc = r"Unchecked version of `Peripherals::take`"]
# [inline]
pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { SYSCONFIG : SYSCONFIG { _marker : PhantomData } , IRQSEL : IRQSEL { _marker : PhantomData } , IOCONFIG : IOCONFIG { _marker : PhantomData } , UTILITY : UTILITY { _marker : PhantomData } , PORTA : PORTA { _marker : PhantomData } , PORTB : PORTB { _marker : PhantomData } , TIM0 : TIM0 { _marker : PhantomData } , TIM1 : TIM1 { _marker : PhantomData } , TIM2 : TIM2 { _marker : PhantomData } , TIM3 : TIM3 { _marker : PhantomData } , TIM4 : TIM4 { _marker : PhantomData } , TIM5 : TIM5 { _marker : PhantomData } , TIM6 : TIM6 { _marker : PhantomData } , TIM7 : TIM7 { _marker : PhantomData } , TIM8 : TIM8 { _marker : PhantomData } , TIM9 : TIM9 { _marker : PhantomData } , TIM10 : TIM10 { _marker : PhantomData } , TIM11 : TIM11 { _marker : PhantomData } , TIM12 : TIM12 { _marker : PhantomData } , TIM13 : TIM13 { _marker : PhantomData } , TIM14 : TIM14 { _marker : PhantomData } , TIM15 : TIM15 { _marker : PhantomData } , TIM16 : TIM16 { _marker : PhantomData } , TIM17 : TIM17 { _marker : PhantomData } , TIM18 : TIM18 { _marker : PhantomData } , TIM19 : TIM19 { _marker : PhantomData } , TIM20 : TIM20 { _marker : PhantomData } , TIM21 : TIM21 { _marker : PhantomData } , TIM22 : TIM22 { _marker : PhantomData } , TIM23 : TIM23 { _marker : PhantomData } , UARTA : UARTA { _marker : PhantomData } , UARTB : UARTB { _marker : PhantomData } , SPIA : SPIA { _marker : PhantomData } , SPIB : SPIB { _marker : PhantomData } , SPIC : SPIC { _marker : PhantomData } , I2CA : I2CA { _marker : PhantomData } , I2CB : I2CB { _marker : PhantomData } , } } }